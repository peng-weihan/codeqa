from typing import ClassVar, List

from litellm import Type
from pydantic import Field

from moatless_qa.actions.action import Action
from moatless_qa.actions.model import (
    ActionArguments,
    Observation,
    RewardScaleEntry,
    FewShotExample,
)
from moatless_qa.file_context import FileContext

class FinishArgs(ActionArguments):
    """Indicate that the generated code answer is accurate and complete for the user's query."""

    answer: str = Field(
        ...,
        description="The generated answer to the user's query.",
    )

    thoughts: str = Field(
        ...,
        description="Your reasoning about why the generated code answer accurately and completely addresses the user's query.",
    )


    class Config:
        title = "Finish" # Finish providing the answer to the user's query
    
    @property
    def answer(self):
        return self.answer
        
    def to_prompt(self):
        return f"Provide Answer: {self.finish_reason}"

    def equals(self, other: "ActionArguments") -> bool:
        # Keep comparison simple for now, might need adjustment based on usage
        return isinstance(other, FinishArgs) and self.finish_reason == other.finish_reason


class Finish(Action):
    args_schema: ClassVar[Type[ActionArguments]] = FinishArgs

    def execute(
        self,
        args: FinishArgs,
        file_context: FileContext | None = None, # Keep for potential future context use
    ):
        # Return the answer from FinishArgs
        return Observation(message=args.answer, terminal=True)

    @classmethod
    def get_evaluation_criteria(cls, trajectory_length: int) -> List[str]:
        # Adapted criteria for Code QA Answering
        return [
            "**Answer Accuracy:** Evaluate the correctness of the provided code snippet or explanation. Does it accurately answer the user's query?",
            "**Answer Completeness:** Assess if the answer provides all necessary information or code components required by the user's query. Are there missing imports, configurations, or steps?",
            "**Relevance:** Verify that the answer directly addresses the user's specific question or request. Is the provided code/explanation relevant to the context?",
            "**Clarity and Quality:** Evaluate the clarity, conciseness, and overall quality of the code and explanation. Is the code well-formatted and easy to understand? Is the explanation clear?",
            "**Safety and Best Practices:** Check if the provided code follows general safety guidelines and best practices (e.g., avoiding obvious security vulnerabilities, using standard libraries correctly).",
        ]

    @classmethod
    def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:
        # Adapted reward scale for Code QA Answering
        return cls.generate_reward_scale_entries(
            [
                (
                    90,
                    100,
                    "The answer is perfectly accurate, complete, directly relevant, clear, and follows best practices. It fully satisfies the user's query.",
                ),
                (
                    75,
                    89,
                    "The answer is accurate and addresses the main aspects of the query, but might lack minor details, alternative approaches, or optimal clarity/formatting.",
                ),
                (
                    50,
                    74,
                    "The answer is generally correct but is incomplete, misses some nuances of the query, or has minor inaccuracies or issues with clarity/best practices.",
                ),
                (
                    25,
                    49,
                    "The answer contains significant inaccuracies or omissions, only partially addresses the query, or has notable issues with clarity or best practices.",
                ),
                (
                    0,
                    24,
                    "The answer is mostly incorrect, irrelevant to the query, or very poorly presented.",
                ),
                (
                    -49,
                    -1,
                    "The answer is fundamentally flawed, misleading, or potentially harmful (e.g., suggests dangerous code practices).",
                ),
                (
                    -100,
                    -50,
                    "The answer is completely wrong, irrelevant, and demonstrates a misunderstanding of the user's query or the underlying concepts.",
                ),
            ]
        )

    @classmethod
    def get_value_function_prompt(cls) -> str:
        # Adapted value function prompt for Code QA Answering
        return """Your role is to evaluate the proposed final answer generated by an AI agent in response to a user's code-related query. The goal is to ensure the answer is accurate, complete, relevant, and clear."""

    @classmethod
    def get_few_shot_examples(cls) -> List[FewShotExample]:
        # Adapted few-shot examples for Code QA Answering
        return [
            FewShotExample.create(
                user_input="How do I read a file line by line in Python?",
                action=FinishArgs(
                    answer="with open('file.txt', 'r') as file:\n    for line in file:\n        print(line.strip())",
                    thoughts="The provided Python code snippet correctly demonstrates reading a file line by line using a 'with open(...)' statement and a for loop, which is the standard and recommended way. It includes error handling implicitly via 'with'.",
                ),
            ),
            FewShotExample.create(
                user_input="Explain the difference between 'let' and 'const' in JavaScript.",
                action=FinishArgs(
                    answer="'let' allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. 'const' is similar but the variable must be initialized at the time of declaration and cannot be reassigned.",
                    thoughts="The explanation clearly defines both 'let' (block-scoped, reassignable) and 'const' (block-scoped, not reassignable), highlighting the key difference in reassignability. It covers the core concepts accurately.",
                ),
            ),
            FewShotExample.create(
                user_input="Show me how to make an HTTP GET request in Java.",
                action=FinishArgs(
                    answer="HttpClient client = HttpClient.newHttpClient();\nHttpRequest request = HttpRequest.newBuilder()\n    .uri(URI.create('https://example.com'))\n    .build();\nHttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());",
                    thoughts="The Java code uses the built-in `java.net.http.HttpClient` introduced in Java 11, which is the modern approach. It shows creating the client, building the request, sending it, and handling the response.",
                ),
            ),
        ]