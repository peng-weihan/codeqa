[
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "MoatlessError",
    "parameters": [
      "self",
      "message"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 7,
      "end_line": 9
    },
    "code_snippet": "def __init__(self, message: str):\n        self.message = message\n        super().__init__(message)"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CompletionError",
    "parameters": [
      "self",
      "message",
      "last_completion",
      "messages"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 27,
      "end_line": 32
    },
    "code_snippet": "def __init__(\n        self, message: str, last_completion: Any = None, messages: List[dict] = None\n    ):\n        super().__init__(message)\n        self.last_completion = last_completion\n        self.messages = messages or []"
  },
  {
    "name": "expand",
    "docstring": "Handle all node expansion logic in one place",
    "is_method": true,
    "class_name": "Expander",
    "parameters": [
      "self",
      "node",
      "search_tree",
      "force_expansion"
    ],
    "calls": [
      "self._get_agent_settings",
      "Node",
      "node.add_child",
      "logger.info",
      "node.is_fully_expanded",
      "logger.info",
      "logger.info",
      "len",
      "search_tree._generate_unique_id",
      "node.file_context.clone"
    ],
    "code_location": {
      "file": "expander.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 26,
      "end_line": 59
    },
    "code_snippet": "def expand(\n        self, node: Node, search_tree, force_expansion: bool = False\n    ) -> None | Node:\n        \"\"\"Handle all node expansion logic in one place\"\"\"\n        if not force_expansion and node.is_fully_expanded():\n            return None\n\n        # Return the first unexecuted child if one exists\n        for child in node.children:\n            if not child.observation:\n                logger.info(\n                    f\"Found unexecuted child {child.node_id} for node {node.node_id}\"\n     ..."
  },
  {
    "name": "_get_agent_settings",
    "docstring": "Get agent settings for a single expansion.",
    "is_method": true,
    "class_name": "Expander",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "len",
      "random.choice",
      "len"
    ],
    "code_location": {
      "file": "expander.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 61,
      "end_line": 83
    },
    "code_snippet": "def _get_agent_settings(self, node: Node) -> List[AgentSettings]:\n        \"\"\"Get agent settings for a single expansion.\"\"\"\n        if not self.agent_settings:\n            return []\n\n        if self.random_settings:\n            used_settings = {\n                child.agent_settings\n                for child in node.children\n                if child.agent_settings is not None\n            }\n\n            available_settings = [\n                setting\n                for setting in self.agent_setting..."
  },
  {
    "name": "_generate_unique_id",
    "docstring": "",
    "is_method": true,
    "class_name": "Expander",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "len",
      "get_all_nodes",
      "node.get_root"
    ],
    "code_location": {
      "file": "expander.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 85,
      "end_line": 86
    },
    "code_snippet": "def _generate_unique_id(self, node: Node):\n        return len(node.get_root().get_all_nodes())"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 49,
      "end_line": 50
    },
    "code_snippet": "def __init__(self, **data: Any):\n        super().__init__(**data)"
  },
  {
    "name": "serialize_message_history_type",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "message_history_type"
    ],
    "calls": [
      "field_serializer"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 53,
      "end_line": 56
    },
    "code_snippet": "def serialize_message_history_type(\n        self, message_history_type: MessageHistoryType\n    ) -> str:\n        return message_history_type.value"
  },
  {
    "name": "generate",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "logger.debug",
      "node.get_trajectory"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 58,
      "end_line": 70
    },
    "code_snippet": "def generate(self, node: \"Node\") -> List[AllMessageValues]:  # type: ignore\n        logger.debug(\n            f\"Generating message history for Node{node.node_id}: {self.message_history_type}\"\n        )\n        generators = {\n            MessageHistoryType.SUMMARY: self._generate_summary_history,\n            MessageHistoryType.REACT: self._generate_react_history,\n            MessageHistoryType.MESSAGES: self._generate_message_history,\n            MessageHistoryType.MESSAGES_COMPACT: self._generat..."
  },
  {
    "name": "_generate_message_history",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node",
      "previous_nodes"
    ],
    "calls": [
      "enumerate",
      "logger.info",
      "messages.append",
      "messages.extend",
      "messages.append",
      "count_tokens",
      "messages.append",
      "tool_calls.append",
      "count_tokens",
      "tool_responses.append",
      "count_tokens",
      "count_tokens",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "action_step.action.model_dump_json",
      "len",
      "action_step.action.model_dump_json"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 72,
      "end_line": 161
    },
    "code_snippet": "def _generate_message_history(\n        self, node: Node, previous_nodes: List[\"Node\"]\n    ) -> List[dict[str, Any]]:\n        messages = []\n        tool_idx = 0\n        tokens = 0\n\n        for i, previous_node in enumerate(previous_nodes):\n            # Handle user message\n            if previous_node.user_message:\n                message_content = [{\"type\": \"text\", \"text\": previous_node.user_message}]\n\n                # if previous_node.artifact_changes:\n                #     for change in previ..."
  },
  {
    "name": "_generate_compact_message_history",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node",
      "previous_nodes"
    ],
    "calls": [
      "self.get_node_messages",
      "logger.info",
      "ChatCompletionUserMessage",
      "len",
      "tool_calls.append",
      "count_tokens",
      "messages.append",
      "messages.append",
      "count_tokens",
      "action.model_dump_json",
      "ChatCompletionAssistantMessage",
      "ChatCompletionToolMessage",
      "action.model_dump_json",
      "len",
      "node.get_root"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 163,
      "end_line": 220
    },
    "code_snippet": "def _generate_compact_message_history(\n        self, node: Node, previous_nodes: List[\"Node\"]\n    ) -> List[dict[str, Any]]:\n        messages = [\n            ChatCompletionUserMessage(role=\"user\", content=node.get_root().message)\n        ]\n\n        if len(previous_nodes) <= 1:\n            return messages\n\n        node_messages = self.get_node_messages(node)\n\n        tool_idx = 0\n        tokens = 0\n\n        for action, observation in node_messages:\n            tool_calls = []\n            tool_idx..."
  },
  {
    "name": "_generate_react_history",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node",
      "previous_nodes"
    ],
    "calls": [
      "self.get_node_messages",
      "count_tokens",
      "logger.info",
      "ChatCompletionUserMessage",
      "len",
      "action.format_args_for_llm",
      "messages.append",
      "messages.append",
      "join",
      "hasattr",
      "ChatCompletionAssistantMessage",
      "ChatCompletionUserMessage",
      "len",
      "node.get_root",
      "m.get"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 222,
      "end_line": 262
    },
    "code_snippet": "def _generate_react_history(\n        self, node: \"Node\", previous_nodes: List[\"Node\"]\n    ) -> List[AllMessageValues]:\n        messages = [\n            ChatCompletionUserMessage(role=\"user\", content=node.get_root().message)\n        ]\n\n        if len(previous_nodes) <= 1:\n            return messages\n\n        node_messages = self.get_node_messages(node)\n\n        # Convert node messages to react format\n        for action, observation in node_messages:\n            # Add thought and action message\n  ..."
  },
  {
    "name": "_generate_summary_history",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node",
      "previous_nodes"
    ],
    "calls": [
      "enumerate",
      "join",
      "node.file_context.create_prompt",
      "ChatCompletionUserMessage",
      "node.get_root",
      "previous_node.action.to_prompt",
      "formatted_history.append",
      "ChatCompletionUserMessage",
      "logger.warning",
      "hasattr",
      "len"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 264,
      "end_line": 322
    },
    "code_snippet": "def _generate_summary_history(\n        self, node: Node, previous_nodes: List[Node]\n    ) -> List[AllMessageValues]:\n        formatted_history: List[str] = []\n        counter = 0\n\n        if self.include_root_node:\n            content = node.get_root().message\n            if not previous_nodes:\n                return [ChatCompletionUserMessage(role=\"user\", content=content)]\n        else:\n            content = \"\"\n            if not previous_nodes:\n                return []\n\n        for i, previou..."
  },
  {
    "name": "get_node_messages",
    "docstring": "Creates a list of (action, observation) tuples from the node's trajectory.\nRespects token limits while preserving ViewCode context.\n\nReturns:\n    List of tuples where each tuple contains:\n    - ActionArguments object\n    - Observation summary string",
    "is_method": true,
    "class_name": "MessageHistoryGenerator",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.file_context.context_size",
      "count_tokens",
      "set",
      "enumerate",
      "logger.info",
      "node.get_trajectory",
      "reversed",
      "node.get_root",
      "enumerate",
      "set",
      "previous_node.file_context.get_context_files",
      "shown_files.update",
      "count_tokens",
      "count_tokens",
      "previous_node.file_context.get_context_file",
      "current_messages.append",
      "action_step.action.model_dump_json",
      "current_messages.append",
      "files_to_show.add",
      "previous_node.file_context.get_context_file",
      "observations.append",
      "ViewCodeArgs",
      "current_messages.append",
      "shown_files.add",
      "context_file.to_prompt",
      "hasattr",
      "code_spans.append",
      "context_file.to_prompt",
      "CodeSpan",
      "code_spans.append",
      "join",
      "CodeSpan"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 324,
      "end_line": 463
    },
    "code_snippet": "def get_node_messages(self, node: \"Node\") -> List[tuple[ActionArguments, str]]:\n        \"\"\"\n        Creates a list of (action, observation) tuples from the node's trajectory.\n        Respects token limits while preserving ViewCode context.\n\n        Returns:\n            List of tuples where each tuple contains:\n            - ActionArguments object\n            - Observation summary string\n        \"\"\"\n        previous_nodes = node.get_trajectory()[:-1]\n        if not previous_nodes:\n            ret..."
  },
  {
    "name": "is_executed",
    "docstring": "Check if this action step has been executed by verifying if it has observations.",
    "is_method": true,
    "class_name": "ActionStep",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 26,
      "end_line": 28
    },
    "code_snippet": "def is_executed(self) -> bool:\n        \"\"\"Check if this action step has been executed by verifying if it has observations.\"\"\"\n        return self.observation is not None"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionStep",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "self.action.model_dump",
      "super"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 30,
      "end_line": 38
    },
    "code_snippet": "def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n\n        data[\"action\"] = self.action.model_dump(**kwargs)\n        data[\"action\"][\"action_args_class\"] = (\n            f\"{self.action.__class__.__module__}.{self.action.__class__.__name__}\"\n        )\n\n        return data"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionStep",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "ActionArguments.model_validate",
      "super"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 41,
      "end_line": 45
    },
    "code_snippet": "def model_validate(cls, obj: Any, **kwargs) -> \"ActionArguments\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            obj[\"action\"] = ActionArguments.model_validate(obj[\"action\"])\n        return super().model_validate(obj, **kwargs)"
  },
  {
    "name": "action",
    "docstring": "Backward compatibility: Get action from the latest action step",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 116,
      "end_line": 120
    },
    "code_snippet": "def action(self) -> Optional[ActionArguments]:\n        \"\"\"Backward compatibility: Get action from the latest action step\"\"\"\n        if not self.action_steps:\n            return None\n        return self.action_steps[-1].action if self.action_steps else None"
  },
  {
    "name": "action",
    "docstring": "Backward compatibility: Set action on the current/new action step",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "value"
    ],
    "calls": [
      "ActionStep"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 123,
      "end_line": 129
    },
    "code_snippet": "def action(self, value: Optional[ActionArguments]):\n        \"\"\"Backward compatibility: Set action on the current/new action step\"\"\"\n\n        if not self.action_steps:\n            self.action_steps = [ActionStep(action=value)]\n        else:\n            self.action_steps[-1].action = value"
  },
  {
    "name": "observation",
    "docstring": "Backward compatibility: Get observation from the latest action step",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 132,
      "end_line": 136
    },
    "code_snippet": "def observation(self) -> Optional[Observation]:\n        \"\"\"Backward compatibility: Get observation from the latest action step\"\"\"\n        if not self.action_steps:\n            return None\n        return self.action_steps[-1].observation if self.action_steps else None"
  },
  {
    "name": "observation",
    "docstring": "Backward compatibility: Set observation on the current/new action step",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "value"
    ],
    "calls": [
      "self.action_steps.append",
      "ActionStep"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 139,
      "end_line": 148
    },
    "code_snippet": "def observation(self, value: Optional[Observation]):\n        \"\"\"Backward compatibility: Set observation on the current/new action step\"\"\"\n        if value is None:\n            return\n\n        if not self.action_steps:\n            # Create new action step if setting observation on empty node\n            self.action_steps.append(ActionStep(action=self.action, observation=value))\n        else:\n            self.action_steps[-1].observation = value"
  },
  {
    "name": "message",
    "docstring": "Backward compatibility: Get message maps to user_message",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 151,
      "end_line": 153
    },
    "code_snippet": "def message(self) -> Optional[str]:\n        \"\"\"Backward compatibility: Get message maps to user_message\"\"\"\n        return self.user_message"
  },
  {
    "name": "message",
    "docstring": "Backward compatibility: Set message maps to user_message",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "value"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 156,
      "end_line": 158
    },
    "code_snippet": "def message(self, value: Optional[str]):\n        \"\"\"Backward compatibility: Set message maps to user_message\"\"\"\n        self.user_message = value"
  },
  {
    "name": "stub",
    "docstring": "Create a stub node with a unique ID.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "cls"
    ],
    "calls": [
      "kwargs.get",
      "cls",
      "max",
      "kwargs.get"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 161,
      "end_line": 169
    },
    "code_snippet": "def stub(cls, **kwargs):\n        \"\"\"Create a stub node with a unique ID.\"\"\"\n        # Get the highest existing node ID from the kwargs or use 0\n        existing_nodes = kwargs.get(\"children\", [])\n        highest_id = (\n            max([n.node_id for n in existing_nodes] + [kwargs.get(\"node_id\", -1), -1])\n            + 1\n        )\n        return cls(node_id=highest_id, **kwargs)"
  },
  {
    "name": "is_leaf",
    "docstring": "Check if the node is a leaf node (no children).",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "len"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 171,
      "end_line": 173
    },
    "code_snippet": "def is_leaf(self) -> bool:\n        \"\"\"Check if the node is a leaf node (no children).\"\"\"\n        return len(self.children) == 0"
  },
  {
    "name": "expanded_count",
    "docstring": "Get the number of expanded children.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "len"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 175,
      "end_line": 177
    },
    "code_snippet": "def expanded_count(self) -> int:\n        \"\"\"Get the number of expanded children.\"\"\"\n        return len([child for child in self.children])"
  },
  {
    "name": "is_fully_expanded",
    "docstring": "Check if all possible actions have been tried and executed from this node.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.expanded_count"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 179,
      "end_line": 181
    },
    "code_snippet": "def is_fully_expanded(self) -> bool:\n        \"\"\"Check if all possible actions have been tried and executed from this node.\"\"\"\n        return self.expanded_count() >= (self.max_expansions or 1)"
  },
  {
    "name": "is_terminal",
    "docstring": "Determine if the current state is a terminal state.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 183,
      "end_line": 186
    },
    "code_snippet": "def is_terminal(self) -> bool:\n        \"\"\"Determine if the current state is a terminal state.\"\"\"\n\n        return self.terminal"
  },
  {
    "name": "is_finished",
    "docstring": "Determine if the node is succesfully finished",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 188,
      "end_line": 193
    },
    "code_snippet": "def is_finished(self) -> bool:\n        \"\"\"Determine if the node is succesfully finished\"\"\"\n        if self.action and self.action.name == \"Finish\":\n            return True\n\n        return False"
  },
  {
    "name": "add_child",
    "docstring": "Add a child node to this node.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "child_node"
    ],
    "calls": [
      "self.children.append"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 195,
      "end_line": 198
    },
    "code_snippet": "def add_child(self, child_node: \"Node\"):\n        \"\"\"Add a child node to this node.\"\"\"\n        child_node.parent = self\n        self.children.append(child_node)"
  },
  {
    "name": "set_parent",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "parent"
    ],
    "calls": [
      "parent.add_child",
      "ValueError"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 200,
      "end_line": 204
    },
    "code_snippet": "def set_parent(self, parent: \"Node\"):\n        if self.node_id == parent.node_id:\n            raise ValueError(f\"Node can't have same id {self.node_id} parent\")\n        self.parent = parent\n        parent.add_child(self)"
  },
  {
    "name": "get_depth",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 206,
      "end_line": 212
    },
    "code_snippet": "def get_depth(self) -> int:\n        depth = 0\n        node = self\n        while node.parent:\n            depth += 1\n            node = node.parent\n        return depth"
  },
  {
    "name": "is_expandable",
    "docstring": "Check if the node can be expanded further.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.is_terminal",
      "self.is_fully_expanded"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 214,
      "end_line": 220
    },
    "code_snippet": "def is_expandable(self) -> bool:\n        \"\"\"Check if the node can be expanded further.\"\"\"\n        return (\n            not self.is_terminal()\n            and not self.is_fully_expanded()\n            and not self.is_duplicate\n        )"
  },
  {
    "name": "find_duplicate",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "child.equals"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 222,
      "end_line": 230
    },
    "code_snippet": "def find_duplicate(self) -> Optional[\"Node\"]:\n        if not self.parent:\n            return None\n\n        for child in self.parent.children:\n            if child.node_id != self.node_id and child.equals(self):\n                return child\n\n        return None"
  },
  {
    "name": "get_sibling_nodes",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 232,
      "end_line": 238
    },
    "code_snippet": "def get_sibling_nodes(self) -> List[\"Node\"]:\n        if not self.parent:\n            return []\n\n        return [\n            child for child in self.parent.children if child.node_id != self.node_id\n        ]"
  },
  {
    "name": "get_trajectory",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "nodes.insert"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 240,
      "end_line": 247
    },
    "code_snippet": "def get_trajectory(self) -> List[\"Node\"]:\n        nodes = []\n        current_node = self\n        while current_node is not None:\n            nodes.insert(0, current_node)\n            current_node = current_node.parent\n\n        return nodes"
  },
  {
    "name": "get_expandable_descendants",
    "docstring": "Get all expandable descendants of this node, including self if expandable.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.is_expandable",
      "expandable_nodes.append",
      "expandable_nodes.extend",
      "child.get_expandable_descendants"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 249,
      "end_line": 256
    },
    "code_snippet": "def get_expandable_descendants(self) -> List[\"Node\"]:\n        \"\"\"Get all expandable descendants of this node, including self if expandable.\"\"\"\n        expandable_nodes = []\n        if self.is_expandable():\n            expandable_nodes.append(self)\n        for child in self.children:\n            expandable_nodes.extend(child.get_expandable_descendants())\n        return expandable_nodes"
  },
  {
    "name": "get_expanded_descendants",
    "docstring": "Get all expanded descendants of this node, including self if expanded.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.expanded_count",
      "expanded_nodes.append",
      "expanded_nodes.extend",
      "child.get_expanded_descendants"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 258,
      "end_line": 265
    },
    "code_snippet": "def get_expanded_descendants(self) -> List[\"Node\"]:\n        \"\"\"Get all expanded descendants of this node, including self if expanded.\"\"\"\n        expanded_nodes = []\n        if self.expanded_count() > 0:\n            expanded_nodes.append(self)\n        for child in self.children:\n            expanded_nodes.extend(child.get_expanded_descendants())\n        return expanded_nodes"
  },
  {
    "name": "get_all_nodes",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "node._get_all_nodes",
      "self.get_root"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 267,
      "end_line": 273
    },
    "code_snippet": "def get_all_nodes(self) -> List[\"Node\"]:\n        if self.parent:\n            node = self.get_root()\n        else:\n            node = self\n\n        return node._get_all_nodes()"
  },
  {
    "name": "get_leaf_nodes",
    "docstring": "Get all leaf nodes .",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "get_all_nodes",
      "node.is_leaf",
      "self.get_root"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 275,
      "end_line": 277
    },
    "code_snippet": "def get_leaf_nodes(self) -> List[\"Node\"]:\n        \"\"\"Get all leaf nodes .\"\"\"\n        return [node for node in self.get_root().get_all_nodes() if node.is_leaf()]"
  },
  {
    "name": "_get_all_nodes",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "nodes.append",
      "nodes.extend",
      "child._get_all_nodes"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 279,
      "end_line": 284
    },
    "code_snippet": "def _get_all_nodes(self) -> List[\"Node\"]:\n        nodes = []\n        nodes.append(self)\n        for child in self.children:\n            nodes.extend(child._get_all_nodes())\n        return nodes"
  },
  {
    "name": "get_root",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 286,
      "end_line": 290
    },
    "code_snippet": "def get_root(self) -> \"Node\":\n        node = self\n        while node.parent:\n            node = node.parent\n        return node"
  },
  {
    "name": "calculate_mean_reward",
    "docstring": "Calculate the mean trajectory reward for this node.\n\nReturns:\n    float: The mean reward.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "rewards.append",
      "sum",
      "len"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 292,
      "end_line": 305
    },
    "code_snippet": "def calculate_mean_reward(self) -> float:\n        \"\"\"\n        Calculate the mean trajectory reward for this node.\n\n        Returns:\n            float: The mean reward.\n        \"\"\"\n        rewards = []\n        node = self\n        while node is not None:\n            rewards.append(node.value / node.visits if node.visits > 0 else 0)\n            node = node.parent\n\n        return sum(rewards) / len(rewards) if rewards else 0"
  },
  {
    "name": "total_usage",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "Usage",
      "self.completions.values"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 307,
      "end_line": 319
    },
    "code_snippet": "def total_usage(self) -> Usage:\n        total_usage = Usage()\n\n        # Sum usage across all action steps\n        for step in self.action_steps:\n            if step.completion:\n                total_usage += step.completion.usage\n\n        for completion in self.completions.values():\n            if completion:\n                total_usage += completion.usage\n\n        return total_usage"
  },
  {
    "name": "equals",
    "docstring": "",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "self.action.equals"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 321,
      "end_line": 331
    },
    "code_snippet": "def equals(self, other: \"Node\"):\n        if self.action and not other.action:\n            return False\n\n        if not self.action and other.action:\n            return False\n\n        if self.action.name != other.action.name:\n            return False\n\n        return self.action.equals(other.action)"
  },
  {
    "name": "reset",
    "docstring": "Reset the node state to be able to execute it again.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.parent.file_context.clone"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 333,
      "end_line": 343
    },
    "code_snippet": "def reset(self):\n        \"\"\"Reset the node state to be able to execute it again.\"\"\"\n        self.action_steps = []\n        self.user_message = None\n        self.assistant_message = None\n        self.visits = 0\n        self.value = 0.0\n        self.is_duplicate = False\n        if self.parent and self.parent.file_context:\n            self.file_context = self.parent.file_context.clone()\n        self.children = []"
  },
  {
    "name": "clone_and_reset",
    "docstring": "Creates a copy of the node and resets its observation and file context.\n\nReturns:\n    Node: A new node instance with reset state",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_root",
      "root.get_all_nodes",
      "Node",
      "new_node.reset",
      "max",
      "self.possible_actions.copy"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 345,
      "end_line": 373
    },
    "code_snippet": "def clone_and_reset(self) -> \"Node\":\n        \"\"\"\n        Creates a copy of the node and resets its observation and file context.\n\n        Returns:\n            Node: A new node instance with reset state\n        \"\"\"\n        # Find highest node ID in the tree to ensure uniqueness\n        root = self.get_root()\n        all_nodes = root.get_all_nodes()\n        highest_id = max(node.node_id for node in all_nodes) + 1\n\n        # Create a new node with same base attributes but new ID\n        new_node = ..."
  },
  {
    "name": "model_dump",
    "docstring": "Generate a dictionary representation of the node and its descendants.\n\nReturns:\n    Dict[str, Any]: A dictionary representation of the node tree.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "isinstance",
      "self.reward.model_dump",
      "self.observation.model_dump",
      "self.file_context.model_dump",
      "action_step.model_dump",
      "exclude_set.update",
      "isinstance",
      "kwargs.items",
      "super",
      "completion.model_dump",
      "kwargs.get",
      "kwargs.get",
      "child.model_dump",
      "exclude_set.update",
      "self.completions.items",
      "keys"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 375,
      "end_line": 418
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Generate a dictionary representation of the node and its descendants.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the node tree.\n        \"\"\"\n\n        exclude_set = {\"parent\", \"children\"}\n        if \"exclude\" in kwargs:\n            if isinstance(kwargs[\"exclude\"], set):\n                exclude_set.update(kwargs[\"exclude\"])\n            elif isinstance(kwargs[\"exclude\"], dict):\n                exc..."
  },
  {
    "name": "_reconstruct_node",
    "docstring": "Update reconstruction to handle both old and new formats",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "cls",
      "node_data",
      "repo"
    ],
    "calls": [
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.get",
      "node_data.pop",
      "FileContext.from_dict",
      "FeedbackData.model_validate",
      "node_data.get",
      "model_validate",
      "model_validate",
      "ActionStep.model_validate",
      "cls._reconstruct_node",
      "node.children.append",
      "super",
      "super"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 421,
      "end_line": 487
    },
    "code_snippet": "def _reconstruct_node(\n        cls,\n        node_data: Dict[str, Any],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"Update reconstruction to handle both old and new formats\"\"\"\n\n        # Handle legacy format conversion\n        if \"action\" in node_data and not \"action_steps\" in node_data:\n            action = node_data.get(\"action\")\n            observation = node_data.get(\"output\")\n            completions = node_data.get(..."
  },
  {
    "name": "reconstruct",
    "docstring": "Reconstruct a node tree from either dict (tree) or list format.\n\nArgs:\n    data: Either a dict (tree format) or list of dicts (list format)\n    parent: Optional parent node (used internally)\n    repo: Optional repository reference\n\nReturns:\n    Node: Root node of reconstructed tree",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "cls",
      "data",
      "repo"
    ],
    "calls": [
      "isinstance",
      "cls._reconstruct_node",
      "cls._reconstruct_from_list"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 490,
      "end_line": 512
    },
    "code_snippet": "def reconstruct(\n        cls,\n        data: Union[Dict[str, Any], List[Dict[str, Any]]],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"\n        Reconstruct a node tree from either dict (tree) or list format.\n\n        Args:\n            data: Either a dict (tree format) or list of dicts (list format)\n            parent: Optional parent node (used internally)\n            repo: Optional repository reference\n\n        Returns:\n..."
  },
  {
    "name": "_reconstruct_from_list",
    "docstring": "Reconstruct tree from a flat list of nodes.\n\nArgs:\n    node_list: List of serialized nodes\n    repo: Optional repository reference\n\nReturns:\n    Node: Root node of reconstructed tree",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "cls",
      "node_list",
      "repo"
    ],
    "calls": [
      "nodes_by_id.values",
      "node_data.pop",
      "cls._reconstruct_node",
      "ValueError",
      "parent_node.add_child",
      "nodes_by_id.values"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 515,
      "end_line": 550
    },
    "code_snippet": "def _reconstruct_from_list(\n        cls,\n        node_list: List[Dict],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"\n        Reconstruct tree from a flat list of nodes.\n\n        Args:\n            node_list: List of serialized nodes\n            repo: Optional repository reference\n\n        Returns:\n            Node: Root node of reconstructed tree\n        \"\"\"\n        # Create nodes without relationships first\n        node..."
  },
  {
    "name": "dump_as_list",
    "docstring": "Dump all nodes as a flat list structure.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_all_nodes",
      "node.model_dump",
      "node_list.append"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 552,
      "end_line": 566
    },
    "code_snippet": "def dump_as_list(self, **kwargs) -> List[Dict[str, Any]]:\n        \"\"\"\n        Dump all nodes as a flat list structure.\n        \"\"\"\n        nodes = self.get_all_nodes()\n        node_list = []\n\n        for node in nodes:\n            node_data = node.model_dump(exclude={\"parent\", \"children\"}, **kwargs)\n            node_data[\"parent_id\"] = (\n                node.parent.node_id if node.parent is not None else None\n            )\n            node_list.append(node_data)\n\n        return node_list"
  },
  {
    "name": "load_from_file",
    "docstring": "Load node tree from file, supporting both old tree format and new list format.\n\nArgs:\n    file_path (str): Path to the saved node data\n    repo (Repository): Optional repository reference\n\nReturns:\n    Node: Root node of the tree",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "cls",
      "file_path",
      "repo"
    ],
    "calls": [
      "isinstance",
      "open",
      "json.load",
      "cls.reconstruct_from_list",
      "cls.reconstruct"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 569,
      "end_line": 587
    },
    "code_snippet": "def load_from_file(cls, file_path: str, repo: Repository | None = None) -> \"Node\":\n        \"\"\"\n        Load node tree from file, supporting both old tree format and new list format.\n\n        Args:\n            file_path (str): Path to the saved node data\n            repo (Repository): Optional repository reference\n\n        Returns:\n            Node: Root node of the tree\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n\n        if isinstance(data, list):\n       ..."
  },
  {
    "name": "persist",
    "docstring": "Persist the node tree to file.\n\nArgs:\n    file_path (str): The path to save to\n    format (str): Either \"list\" (new) or \"tree\" (legacy)",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "file_path",
      "format"
    ],
    "calls": [
      "self.persist_as_list",
      "self.persist_tree",
      "ValueError"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 589,
      "end_line": 602
    },
    "code_snippet": "def persist(self, file_path: str, format: str = \"list\"):\n        \"\"\"\n        Persist the node tree to file.\n\n        Args:\n            file_path (str): The path to save to\n            format (str): Either \"list\" (new) or \"tree\" (legacy)\n        \"\"\"\n        if format == \"list\":\n            self.persist_as_list(file_path)\n        elif format == \"tree\":\n            self.persist_tree(file_path)\n        else:\n            raise ValueError(\"Format must be either 'list' or 'tree'\")"
  },
  {
    "name": "truncate_children_by_id",
    "docstring": "Truncate children to only include nodes with IDs less than or equal to the specified value.\n\nArgs:\n    max_id (int): Maximum node ID to keep (inclusive)",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self",
      "max_id"
    ],
    "calls": [
      "child.truncate_children_by_id"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 604,
      "end_line": 613
    },
    "code_snippet": "def truncate_children_by_id(self, max_id: int):\n        \"\"\"Truncate children to only include nodes with IDs less than or equal to the specified value.\n\n        Args:\n            max_id (int): Maximum node ID to keep (inclusive)\n        \"\"\"\n        self.children = [child for child in self.children if child.node_id <= max_id]\n        # Recursively truncate remaining children\n        for child in self.children:\n            child.truncate_children_by_id(max_id)"
  },
  {
    "name": "has_unexecuted_actions",
    "docstring": "Check if any action step in this node has not been executed.",
    "is_method": true,
    "class_name": "Node",
    "parameters": [
      "self"
    ],
    "calls": [
      "any",
      "step.is_executed"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 615,
      "end_line": 617
    },
    "code_snippet": "def has_unexecuted_actions(self) -> bool:\n        \"\"\"Check if any action step in this node has not been executed.\"\"\"\n        return any(not step.is_executed() for step in self.action_steps)"
  },
  {
    "name": "generate_ascii_tree",
    "docstring": "Create an ASCII representation of the tree.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "root",
      "current",
      "include_explanation",
      "include_diffs",
      "include_feedback",
      "include_action_details",
      "include_file_context",
      "use_color",
      "show_trajectory"
    ],
    "calls": [
      "_append_ascii_node",
      "join",
      "root.get_root"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 620,
      "end_line": 651
    },
    "code_snippet": "def generate_ascii_tree(\n    root: Node,\n    current: Optional[Node] = None,\n    include_explanation: bool = False,\n    include_diffs: bool = False,\n    include_feedback: bool = False,\n    include_action_details: bool = False,\n    include_file_context: bool = False,\n    use_color: bool = True,\n    show_trajectory: bool = False,\n) -> str:\n    \"\"\"Create an ASCII representation of the tree.\"\"\"\n    tree_lines = [\"MCTS Tree\"]\n    # Make sure we're starting from the actual root node\n    if root.parent..."
  },
  {
    "name": "_append_ascii_node",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "node",
      "prefix",
      "is_last",
      "tree_lines",
      "current",
      "include_explanation",
      "include_diffs",
      "include_feedback",
      "include_action_details",
      "include_file_context",
      "use_color",
      "show_trajectory"
    ],
    "calls": [
      "tree_lines.append",
      "enumerate",
      "current.get_trajectory",
      "state_params.extend",
      "any",
      "color_white",
      "node.is_expandable",
      "node.reward.explanation.strip",
      "_append_wrapped_text",
      "tree_lines.append",
      "_append_wrapped_text",
      "_append_wrapped_text",
      "tree_lines.append",
      "enumerate",
      "tree_lines.append",
      "node.file_context.create_prompt",
      "_append_wrapped_text",
      "_append_ascii_node",
      "state_params.append",
      "str",
      "node.is_expandable",
      "color_green",
      "color_red",
      "tree_lines.append",
      "tree_lines.append",
      "tree_lines.append",
      "node.file_context.is_empty",
      "color_green",
      "color_green",
      "join",
      "node.expanded_count",
      "tree_lines.append",
      "color_red",
      "color_red",
      "color_yellow",
      "color_yellow",
      "tree_lines.append",
      "tree_lines.append",
      "len",
      "step.action.to_prompt"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 654,
      "end_line": 807
    },
    "code_snippet": "def _append_ascii_node(\n    node: Node,\n    prefix: str,\n    is_last: bool,\n    tree_lines: list[str],\n    current: Node | None,\n    include_explanation: bool = False,\n    include_diffs: bool = False,\n    include_feedback: bool = False,\n    include_action_details: bool = False,\n    include_file_context: bool = False,\n    use_color: bool = True,\n    show_trajectory: bool = False,\n) -> None:\n    # Get current trajectory nodes if we have a current node and trajectory marking is enabled\n    current_..."
  },
  {
    "name": "_append_wrapped_text",
    "docstring": "Helper function to wrap and append text with proper prefixes.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "tree_lines",
      "text",
      "prefix",
      "header_prefix"
    ],
    "calls": [
      "text.split",
      "len",
      "tree_lines.append",
      "len",
      "current_line.append",
      "tree_lines.append",
      "len",
      "len",
      "len",
      "join",
      "join"
    ],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 810,
      "end_line": 835
    },
    "code_snippet": "def _append_wrapped_text(\n    tree_lines: list[str], text: str, prefix: str, header_prefix: str = \"│ \"\n):\n    \"\"\"Helper function to wrap and append text with proper prefixes.\"\"\"\n    words = text.split()\n    current_line = []\n    current_length = 0\n    max_line_length = 100 - len(prefix) - len(header_prefix)\n\n    # First line gets the header prefix\n    is_first_line = True\n\n    for word in words:\n        if current_length + len(word) + 1 <= max_line_length:\n            current_line.append(word)\n ..."
  },
  {
    "name": "color_red",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "text"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 838,
      "end_line": 839
    },
    "code_snippet": "def color_red(text: Any) -> str:\n    return f\"\\033[91m{text}\\033[0m\""
  },
  {
    "name": "color_green",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "text"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 842,
      "end_line": 843
    },
    "code_snippet": "def color_green(text: Any) -> str:\n    return f\"\\033[92m{text}\\033[0m\""
  },
  {
    "name": "color_yellow",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "text"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 846,
      "end_line": 847
    },
    "code_snippet": "def color_yellow(text: Any) -> str:\n    return f\"\\033[93m{text}\\033[0m\""
  },
  {
    "name": "color_white",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "text"
    ],
    "calls": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 850,
      "end_line": 851
    },
    "code_snippet": "def color_white(text: Any) -> str:\n    return f\"\\033[97m{text}\\033[0m\""
  },
  {
    "name": "__init__",
    "docstring": "Initializes the ContextFile instance.\n\nArgs:\n    repo (Optional[Repository]): The repository instance, can be None when reconstructing from dict\n    file_path (str): The path to the file within the repository\n    initial_patch (Optional[str]): A Git-formatted patch representing accumulated changes\n    **data: Additional keyword arguments",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "repo",
      "file_path",
      "initial_patch"
    ],
    "calls": [
      "__init__",
      "super",
      "repo.file_exists"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 85,
      "end_line": 104
    },
    "code_snippet": "def __init__(\n        self,\n        repo: Optional[Repository],\n        file_path: str,\n        initial_patch: Optional[str] = None,\n        **data,\n    ):\n        \"\"\"\n        Initializes the ContextFile instance.\n\n        Args:\n            repo (Optional[Repository]): The repository instance, can be None when reconstructing from dict\n            file_path (str): The path to the file within the repository\n            initial_patch (Optional[str]): A Git-formatted patch representing accumulated c..."
  },
  {
    "name": "_add_import_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.add_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 106,
      "end_line": 114
    },
    "code_snippet": "def _add_import_span(self):\n        # TODO: Initiate module or add this lazily?\n        if self.module:\n            # Always include init spans like 'imports' to context file\n            for child in self.module.children:\n                if (\n                    child.type == CodeBlockType.IMPORT\n                ) and child.belongs_to_span.span_id:\n                    self.add_span(child.belongs_to_span.span_id, pinned=True)"
  },
  {
    "name": "get_base_content",
    "docstring": "Retrieves the base content of the file by applying the initial_patch to the original content.\n\nReturns:\n    str: The base content of the file.\n\nRaises:\n    FileNotFoundError: If the file does not exist in the repository.\n    Exception: If applying the initial_patch fails.",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self._repo.file_exists",
      "self._repo.get_file_content",
      "self.apply_patch_to_content",
      "Exception"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 116,
      "end_line": 148
    },
    "code_snippet": "def get_base_content(self) -> str:\n        \"\"\"\n        Retrieves the base content of the file by applying the initial_patch to the original content.\n\n        Returns:\n            str: The base content of the file.\n\n        Raises:\n            FileNotFoundError: If the file does not exist in the repository.\n            Exception: If applying the initial_patch fails.\n        \"\"\"\n        if not self._repo:\n            return None\n\n        if self._cached_base_content is not None:\n            return..."
  },
  {
    "name": "module",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "get_parser_by_path",
      "parser.parse"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 151,
      "end_line": 162
    },
    "code_snippet": "def module(self) -> Module | None:\n        if not self._repo:\n            return None\n\n        if self._cached_module is not None:\n            return self._cached_module\n\n        parser = get_parser_by_path(self.file_path)\n        if parser:\n            self._cached_module = parser.parse(self.content)\n\n        return self._cached_module"
  },
  {
    "name": "content",
    "docstring": "Retrieves the current content of the file by applying the latest patch to the base content.\n\nReturns:\n    str: The current content of the file.",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_base_content",
      "self.apply_patch_to_content",
      "logger.error"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 165,
      "end_line": 187
    },
    "code_snippet": "def content(self) -> str:\n        \"\"\"\n        Retrieves the current content of the file by applying the latest patch to the base content.\n\n        Returns:\n            str: The current content of the file.\n        \"\"\"\n        if self._cached_content is not None:\n            return self._cached_content\n\n        base_content = self.get_base_content()\n        if self.patch:\n            try:\n                self._cached_content = self.apply_patch_to_content(\n                    base_content, self.pa..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "data.pop",
      "data.pop",
      "super"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 189,
      "end_line": 197
    },
    "code_snippet": "def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n        # Ensure these fields are excluded even if exclude=True is not in kwargs\n        data.pop(\"was_edited\", None)\n        data.pop(\"was_viewed\", None)\n        # Ensure 'patch' is always included, even if it's None\n        if \"patch\" not in data:\n            data[\"patch\"] = None\n        return data"
  },
  {
    "name": "span_ids",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 200,
      "end_line": 201
    },
    "code_snippet": "def span_ids(self):\n        return {span.span_id for span in self.spans}"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "show_span_ids",
      "show_line_numbers",
      "exclude_comments",
      "show_outcommented_code",
      "outcomment_code_comment",
      "show_all_spans",
      "only_signatures",
      "max_tokens"
    ],
    "calls": [
      "self._to_prompt",
      "self._to_prompt_with_line_spans",
      "logger.warning",
      "logger.warning",
      "count_tokens",
      "len"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 203,
      "end_line": 248
    },
    "code_snippet": "def to_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n        show_all_spans: bool = False,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n    ):\n        if self.module:\n            if (\n                not self.show_all_spans\n                and self.span_ids is not None\n                and len(self.span_ids) =..."
  },
  {
    "name": "_find_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "codeblock"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 250,
      "end_line": 258
    },
    "code_snippet": "def _find_span(self, codeblock: CodeBlock) -> Optional[ContextSpan]:\n        if not codeblock.belongs_to_span:\n            return None\n\n        for span in self.spans:\n            if codeblock.belongs_to_span.span_id == span.span_id:\n                return span\n\n        return None"
  },
  {
    "name": "_within_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "line_no"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 260,
      "end_line": 268
    },
    "code_snippet": "def _within_span(self, line_no: int) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if (\n                span.start_line\n                and span.end_line\n                and span.start_line <= line_no <= span.end_line\n            ):\n                return span\n        return None"
  },
  {
    "name": "_to_prompt_with_line_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "show_span_id"
    ],
    "calls": [
      "self.content.split",
      "enumerate",
      "self._within_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 270,
      "end_line": 292
    },
    "code_snippet": "def _to_prompt_with_line_spans(self, show_span_id: bool = False) -> str:\n        content_lines = self.content.split(\"\\n\")\n\n        if not self.span_ids:\n            return self.content\n\n        prompt_content = \"\"\n        outcommented = True\n        for i, line in enumerate(content_lines):\n            line_no = i + 1\n\n            span = self._within_span(line_no)\n            if span:\n                if outcommented and show_span_id:\n                    prompt_content += f\"<span id={span.span_id}..."
  },
  {
    "name": "_to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "code_block",
      "current_span",
      "show_outcommented_code",
      "outcomment_code_comment",
      "show_span_id",
      "show_line_numbers",
      "exclude_comments",
      "show_all_spans",
      "only_signatures",
      "max_tokens",
      "current_tokens"
    ],
    "calls": [
      "enumerate",
      "CurrentPromptSpan",
      "self._find_span",
      "outcommented_block._to_prompt_string",
      "count_tokens",
      "child._to_prompt_string",
      "count_tokens",
      "self._to_prompt",
      "count_tokens",
      "logger.debug",
      "CurrentPromptSpan",
      "child.has_any_span",
      "outcommented_block._to_prompt_string",
      "count_tokens",
      "child.create_commented_out_block",
      "CurrentPromptSpan",
      "child.sum_tokens"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 294,
      "end_line": 428
    },
    "code_snippet": "def _to_prompt(\n        self,\n        code_block: CodeBlock,\n        current_span: Optional[CurrentPromptSpan] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        show_line_numbers: bool = False,\n        exclude_comments: bool = False,\n        show_all_spans: bool = False,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n        current_tokens: int = 0,\n    ):\n        if cur..."
  },
  {
    "name": "set_patch",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "patch"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 430,
      "end_line": 433
    },
    "code_snippet": "def set_patch(self, patch: str):\n        self.patch = patch\n        self._cached_content = None\n        self._cached_module = None"
  },
  {
    "name": "context_size",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.module.sum_tokens",
      "self.module.find_span_by_id"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 436,
      "end_line": 448
    },
    "code_snippet": "def context_size(self):\n        if self.module:\n            if self.span_ids is None:\n                return self.module.sum_tokens()\n            else:\n                tokens = 0\n                for span_id in self.span_ids:\n                    span = self.module.find_span_by_id(span_id)\n                    if span:\n                        tokens += span.tokens\n                return tokens\n        else:\n            return 0"
  },
  {
    "name": "has_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 450,
      "end_line": 451
    },
    "code_snippet": "def has_span(self, span_id: str):\n        return span_id in self.span_ids"
  },
  {
    "name": "add_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_ids",
      "tokens",
      "pinned",
      "add_extra"
    ],
    "calls": [
      "self.add_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 453,
      "end_line": 461
    },
    "code_snippet": "def add_spans(\n        self,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ):\n        for span_id in span_ids:\n            self.add_span(span_id, tokens=tokens, pinned=pinned, add_extra=add_extra)"
  },
  {
    "name": "add_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_id",
      "start_line",
      "end_line",
      "tokens",
      "pinned",
      "add_extra"
    ],
    "calls": [
      "next",
      "self.module.find_span_by_id",
      "self.spans.append",
      "logger.warning",
      "ContextSpan",
      "self._add_class_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 463,
      "end_line": 500
    },
    "code_snippet": "def add_span(\n        self,\n        span_id: str,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ) -> bool:\n        self.was_viewed = True\n        existing_span = next(\n            (span for span in self.spans if span.span_id == span_id), None\n        )\n\n        if existing_span:\n            existing_span.tokens = tokens\n            existing_span.pinned = pin..."
  },
  {
    "name": "_add_class_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span"
    ],
    "calls": [
      "span.initiating_block.find_type_in_parents",
      "self.has_span",
      "self.spans.append",
      "ContextSpan",
      "self.has_span",
      "self.spans.append",
      "ContextSpan"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 502,
      "end_line": 528
    },
    "code_snippet": "def _add_class_span(self, span: BlockSpan):\n        if span.initiating_block.type != CodeBlockType.CLASS:\n            class_block = span.initiating_block.find_type_in_parents(\n                CodeBlockType.CLASS\n            )\n        elif span.initiating_block.type == CodeBlockType.CLASS:\n            class_block = span.initiating_block\n        else:\n            return\n\n        if not class_block or self.has_span(class_block.belongs_to_span.span_id):\n            return\n\n        # Always add init ..."
  },
  {
    "name": "add_line_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "start_line",
      "end_line",
      "add_extra"
    ],
    "calls": [
      "logger.debug",
      "self.module.find_blocks_by_line_numbers",
      "logger.warning",
      "added_spans.append",
      "self.add_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 530,
      "end_line": 558
    },
    "code_snippet": "def add_line_span(\n        self, start_line: int, end_line: int | None = None, add_extra: bool = True\n    ) -> list[str]:\n        self.was_viewed = True\n\n        if not self.module:\n            logger.warning(f\"Could not find module for file {self.file_path}\")\n            return []\n\n        logger.debug(f\"Adding line span {start_line} - {end_line} to {self.file_path}\")\n        blocks = self.module.find_blocks_by_line_numbers(\n            start_line, end_line, include_parents=True\n        )\n\n    ..."
  },
  {
    "name": "lines_is_in_context",
    "docstring": "Check if the given line range's start and end points are covered by spans in the context.\nA single span can cover both points, or different spans can cover each point.\n\nArgs:\n    start_line (int): Start line number\n    end_line (int): End line number\n\nReturns:\n    bool: True if both start and end lines are covered by spans in context, False otherwise",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "start_line",
      "end_line"
    ],
    "calls": [
      "self.module.find_span_by_id"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 560,
      "end_line": 591
    },
    "code_snippet": "def lines_is_in_context(self, start_line: int, end_line: int) -> bool:\n        \"\"\"\n        Check if the given line range's start and end points are covered by spans in the context.\n        A single span can cover both points, or different spans can cover each point.\n\n        Args:\n            start_line (int): Start line number\n            end_line (int): End line number\n\n        Returns:\n            bool: True if both start and end lines are covered by spans in context, False otherwise\n        ..."
  },
  {
    "name": "remove_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 593,
      "end_line": 594
    },
    "code_snippet": "def remove_span(self, span_id: str):\n        self.spans = [span for span in self.spans if span.span_id != span_id]"
  },
  {
    "name": "remove_all_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 596,
      "end_line": 597
    },
    "code_snippet": "def remove_all_spans(self):\n        self.spans = [span for span in self.spans if span.pinned]"
  },
  {
    "name": "get_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.module.find_span_by_id",
      "block_spans.append"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 599,
      "end_line": 608
    },
    "code_snippet": "def get_spans(self) -> List[BlockSpan]:\n        block_spans = []\n        for span in self.spans:\n            if not self.module:\n                continue\n\n            block_span = self.module.find_span_by_id(span.span_id)\n            if block_span:\n                block_spans.append(block_span)\n        return block_spans"
  },
  {
    "name": "get_block_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "self.module.find_span_by_id",
      "logger.warning"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 610,
      "end_line": 622
    },
    "code_snippet": "def get_block_span(self, span_id: str) -> Optional[BlockSpan]:\n        if not self.module:\n            return None\n        for span in self.spans:\n            if span.span_id == span_id:\n                block_span = self.module.find_span_by_id(span_id)\n                if block_span:\n                    return block_span\n                else:\n                    logger.warning(\n                        f\"Could not find span with id {span_id} in file {self.file_path}\"\n                    )\n        ..."
  },
  {
    "name": "get_span",
    "docstring": "",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 624,
      "end_line": 628
    },
    "code_snippet": "def get_span(self, span_id: str) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if span.span_id == span_id:\n                return span\n        return None"
  },
  {
    "name": "get_patches",
    "docstring": "Get all patches associated with this ContextFile.",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 630,
      "end_line": 634
    },
    "code_snippet": "def get_patches(self) -> List[str]:\n        \"\"\"\n        Get all patches associated with this ContextFile.\n        \"\"\"\n        return self.patches"
  },
  {
    "name": "is_new",
    "docstring": "Returns whether this file is newly created in the context.\n\nReturns:\n    bool: True if the file is new, False otherwise",
    "is_method": true,
    "class_name": "ContextFile",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 637,
      "end_line": 644
    },
    "code_snippet": "def is_new(self) -> bool:\n        \"\"\"\n        Returns whether this file is newly created in the context.\n\n        Returns:\n            bool: True if the file is new, False otherwise\n        \"\"\"\n        return self._is_new"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "repo"
    ],
    "calls": [
      "__init__",
      "data.get",
      "super"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 659,
      "end_line": 677
    },
    "code_snippet": "def __init__(\n        self,\n        repo: Repository | None,\n        # runtime: RuntimeEnvironment | None = None,\n        **data,\n    ):\n        super().__init__(**data)\n\n        self._repo = repo\n        # self._runtime = runtime\n\n        if \"_files\" not in self.__dict__:\n            self.__dict__[\"_files\"] = {}\n\n        if \"_test_files\" not in self.__dict__:\n            self.__dict__[\"_test_files\"] = {}\n\n        if \"_max_tokens\" not in self.__dict__:\n            self.__dict__[\"_max_tokens\"] = ..."
  },
  {
    "name": "from_dir",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "cls",
      "repo_dir",
      "max_tokens"
    ],
    "calls": [
      "FileRepository",
      "cls"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 680,
      "end_line": 685
    },
    "code_snippet": "def from_dir(cls, repo_dir: str, max_tokens: int = 8000):\n        from moatless_qa.repository.file import FileRepository\n\n        repo = FileRepository(repo_path=repo_dir)\n        instance = cls(max_tokens=max_tokens, repo=repo)\n        return instance"
  },
  {
    "name": "from_json",
    "docstring": "Create a FileContext instance from JSON data.\n\n:param repo_dir: The repository directory path.\n:param json_data: A JSON string representing the FileContext data.\n:return: A new FileContext instance.",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "cls",
      "repo_dir",
      "json_data"
    ],
    "calls": [
      "strip",
      "json.loads",
      "cls.from_dict",
      "json_data.strip"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 688,
      "end_line": 698
    },
    "code_snippet": "def from_json(cls, repo_dir: str, json_data: str):\n        \"\"\"\n        Create a FileContext instance from JSON data.\n\n        :param repo_dir: The repository directory path.\n        :param json_data: A JSON string representing the FileContext data.\n        :return: A new FileContext instance.\n        \"\"\"\n        json_data = json_data.strip(\"```json\\n\").strip(\"\\n```\")\n        data = json.loads(json_data)\n        return cls.from_dict(data, repo_dir=repo_dir)"
  },
  {
    "name": "from_dict",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "cls",
      "data",
      "repo_dir",
      "repo"
    ],
    "calls": [
      "cls",
      "instance.load_files_from_dict",
      "FileRepository",
      "data.get",
      "data.get",
      "data.get"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 701,
      "end_line": 716
    },
    "code_snippet": "def from_dict(\n        cls,\n        data: Dict,\n        repo_dir: str | None = None,\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ):\n        if not repo and repo_dir:\n            repo = FileRepository(repo_path=repo_dir)\n        instance = cls(\n            max_tokens=data.get(\"max_tokens\", 8000), repo=repo\n        )\n        instance.load_files_from_dict(\n            data.get(\"files\", []), test_files=data.get(\"test_files\", [])\n        )\n        ..."
  },
  {
    "name": "load_files_from_dict",
    "docstring": "Loads files and test files from a dictionary representation.\n\nArgs:\n    files (list[dict]): List of file data dictionaries\n    test_files (list[dict] | None): List of test file data dictionaries",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "files"
    ],
    "calls": [
      "file_data.get",
      "ContextFile",
      "ContextSpan",
      "file_data.get",
      "file_data.get"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 718,
      "end_line": 740
    },
    "code_snippet": "def load_files_from_dict(\n        self, files: list[dict]\n    ):\n        \"\"\"\n        Loads files and test files from a dictionary representation.\n\n        Args:\n            files (list[dict]): List of file data dictionaries\n            test_files (list[dict] | None): List of test file data dictionaries\n        \"\"\"\n        # Load regular files\n        for file_data in files:\n            file_path = file_data[\"file_path\"]\n            show_all_spans = file_data.get(\"show_all_spans\", False)\n        ..."
  },
  {
    "name": "model_dump",
    "docstring": "Dumps the model to a dictionary, including files and test files.",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "file.model_dump",
      "self._files.values"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 742,
      "end_line": 754
    },
    "code_snippet": "def model_dump(self, **kwargs):\n        \"\"\"\n        Dumps the model to a dictionary, including files and test files.\n        \"\"\"\n        if \"exclude_none\" not in kwargs:\n            kwargs[\"exclude_none\"] = True\n\n        files = [file.model_dump(**kwargs) for file in self._files.values()]\n\n        return {\n            \"max_tokens\": self.__dict__[\"_max_tokens\"],\n            \"files\": files,\n        }"
  },
  {
    "name": "snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.model_dump"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 756,
      "end_line": 759
    },
    "code_snippet": "def snapshot(self):\n        dict = self.model_dump()\n        del dict[\"max_tokens\"]\n        return dict"
  },
  {
    "name": "restore_from_snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "snapshot"
    ],
    "calls": [
      "self._files.clear",
      "self._test_files.clear",
      "self.load_files_from_dict",
      "snapshot.get"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 761,
      "end_line": 764
    },
    "code_snippet": "def restore_from_snapshot(self, snapshot: dict):\n        self._files.clear()\n        self._test_files.clear()\n        self.load_files_from_dict(snapshot.get(\"files\", []))"
  },
  {
    "name": "to_files_with_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "FileWithSpans",
      "self._files.items",
      "list"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 766,
      "end_line": 770
    },
    "code_snippet": "def to_files_with_spans(self) -> List[FileWithSpans]:\n        return [\n            FileWithSpans(file_path=file_path, span_ids=list(file.span_ids))\n            for file_path, file in self._files.items()\n        ]"
  },
  {
    "name": "add_files_with_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "files_with_spans"
    ],
    "calls": [
      "self.add_spans_to_context",
      "set"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 772,
      "end_line": 776
    },
    "code_snippet": "def add_files_with_spans(self, files_with_spans: List[FileWithSpans]):\n        for file_with_spans in files_with_spans:\n            self.add_spans_to_context(\n                file_with_spans.file_path, set(file_with_spans.span_ids)\n            )"
  },
  {
    "name": "add_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "show_all_spans",
      "add_extra"
    ],
    "calls": [
      "ContextFile",
      "_add_import_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 778,
      "end_line": 791
    },
    "code_snippet": "def add_file(\n        self, file_path: str, show_all_spans: bool = False, add_extra: bool = True\n    ) -> ContextFile:\n        if file_path not in self._files:\n            self._files[file_path] = ContextFile(\n                file_path=file_path,\n                spans=[],\n                show_all_spans=show_all_spans,\n                repo=self._repo,\n            )\n            if add_extra:\n                self._files[file_path]._add_import_span()\n\n        return self._files[file_path]"
  },
  {
    "name": "add_file_with_lines",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "start_line",
      "end_line"
    ],
    "calls": [
      "add_line_span",
      "self.add_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 793,
      "end_line": 800
    },
    "code_snippet": "def add_file_with_lines(\n        self, file_path: str, start_line: int, end_line: Optional[int] = None\n    ):\n        end_line = end_line or start_line\n        if file_path not in self._files:\n            self.add_file(file_path)\n\n        self._files[file_path].add_line_span(start_line, end_line)"
  },
  {
    "name": "remove_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 802,
      "end_line": 804
    },
    "code_snippet": "def remove_file(self, file_path: str):\n        if file_path in self._files:\n            del self._files[file_path]"
  },
  {
    "name": "exists",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 806,
      "end_line": 807
    },
    "code_snippet": "def exists(self, file_path: str):\n        return file_path in self._files"
  },
  {
    "name": "has_runtime",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "bool"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 810,
      "end_line": 811
    },
    "code_snippet": "def has_runtime(self):\n        return bool(self._runtime)"
  },
  {
    "name": "files",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "list",
      "self._files.values"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 814,
      "end_line": 815
    },
    "code_snippet": "def files(self):\n        return list(self._files.values())"
  },
  {
    "name": "test_files",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "list",
      "self._test_files.values"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 818,
      "end_line": 819
    },
    "code_snippet": "def test_files(self):\n        return list(self._test_files.values())"
  },
  {
    "name": "add_spans_to_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_ids",
      "tokens",
      "pinned",
      "add_extra"
    ],
    "calls": [
      "self.has_file",
      "self.add_file",
      "self.get_context_file",
      "context_file.add_spans",
      "logger.warning"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 821,
      "end_line": 837
    },
    "code_snippet": "def add_spans_to_context(\n        self,\n        file_path: str,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ):\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            context_file.add_spans(span_ids, tokens, pinned=pinned, add_extra=add_extra)\n        else:\n     ..."
  },
  {
    "name": "add_span_to_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_id",
      "tokens",
      "pinned",
      "add_extra"
    ],
    "calls": [
      "self.has_file",
      "self.add_file",
      "self.get_context_file",
      "context_file.add_span",
      "logger.warning"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 839,
      "end_line": 858
    },
    "code_snippet": "def add_span_to_context(\n        self,\n        file_path: str,\n        span_id: str,\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ) -> bool:\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            return context_file.add_span(\n                span_id, tokens=tokens, pinned=pinned, add_extra=..."
  },
  {
    "name": "add_line_span_to_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "start_line",
      "end_line",
      "add_extra"
    ],
    "calls": [
      "self.has_file",
      "self.add_file",
      "self.get_context_file",
      "context_file.add_line_span",
      "logger.warning"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 860,
      "end_line": 876
    },
    "code_snippet": "def add_line_span_to_context(\n        self,\n        file_path: str,\n        start_line: int,\n        end_line: int | None = None,\n        add_extra: bool = True,\n    ) -> List[str]:\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path, add_extra=add_extra)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            return context_file.add_line_span(start_line, end_line, add_extra=add_extra)\n        else:\n ..."
  },
  {
    "name": "remove_span_from_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_id",
      "remove_file"
    ],
    "calls": [
      "self.get_context_file",
      "context_file.remove_span",
      "self.remove_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 878,
      "end_line": 886
    },
    "code_snippet": "def remove_span_from_context(\n        self, file_path: str, span_id: str, remove_file: bool = False\n    ):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.remove_span(span_id)\n\n            if not context_file.spans and remove_file:\n                self.remove_file(file_path)"
  },
  {
    "name": "remove_spans_from_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_ids",
      "remove_file"
    ],
    "calls": [
      "self.remove_span_from_context"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 888,
      "end_line": 892
    },
    "code_snippet": "def remove_spans_from_context(\n        self, file_path: str, span_ids: List[str], remove_file: bool = False\n    ):\n        for span_id in span_ids:\n            self.remove_span_from_context(file_path, span_id, remove_file)"
  },
  {
    "name": "get_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.get_context_file",
      "context_file.get_spans"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 894,
      "end_line": 898
    },
    "code_snippet": "def get_spans(self, file_path: str) -> List[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_spans()\n        return []"
  },
  {
    "name": "get_span",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_id"
    ],
    "calls": [
      "self.get_context_file",
      "context_file.get_block_span"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 900,
      "end_line": 904
    },
    "code_snippet": "def get_span(self, file_path: str, span_id: str) -> Optional[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_block_span(span_id)\n        return None"
  },
  {
    "name": "has_span",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "span_id"
    ],
    "calls": [
      "self.get_context_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 906,
      "end_line": 910
    },
    "code_snippet": "def has_span(self, file_path: str, span_id: str):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return span_id in context_file.span_ids\n        return False"
  },
  {
    "name": "apply",
    "docstring": "Apply a list of FileContext instances, collecting their ContextFiles.",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_context"
    ],
    "calls": [
      "spans.extend",
      "ContextFile",
      "file_context.generate_full_patch"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 912,
      "end_line": 926
    },
    "code_snippet": "def apply(self, file_context: \"FileContext\"):\n        \"\"\"\n        Apply a list of FileContext instances, collecting their ContextFiles.\n        \"\"\"\n        for context_file in file_context.files:\n            file_path = context_file.file_path\n            if file_path not in self.files:\n                self._files[file_path] = ContextFile(\n                    file_path=file_path,\n                    repo=self.repo,\n                    initial_patch=file_context.generate_full_patch(),\n            ..."
  },
  {
    "name": "has_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 928,
      "end_line": 931
    },
    "code_snippet": "def has_file(self, file_path: str):\n        return file_path in self._files and (\n            self._files[file_path].spans or self._files[file_path].show_all_spans\n        )"
  },
  {
    "name": "get_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.get_context_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 933,
      "end_line": 934
    },
    "code_snippet": "def get_file(self, file_path: str) -> Optional[ContextFile]:\n        return self.get_context_file(file_path)"
  },
  {
    "name": "file_exists",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self._files.get",
      "self._repo.file_exists"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 936,
      "end_line": 938
    },
    "code_snippet": "def file_exists(self, file_path: str):\n        context_file = self._files.get(file_path)\n        return context_file or self._repo.file_exists(file_path)"
  },
  {
    "name": "is_directory",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self._repo.is_directory"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 940,
      "end_line": 941
    },
    "code_snippet": "def is_directory(self, file_path: str):\n        return self._repo.is_directory(file_path)"
  },
  {
    "name": "get_context_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "add_extra"
    ],
    "calls": [
      "self._files.get",
      "hasattr",
      "self._repo.get_relative_path",
      "self._repo.is_directory",
      "self.add_file",
      "self._repo.file_exists",
      "logger.info",
      "logger.info"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 943,
      "end_line": 963
    },
    "code_snippet": "def get_context_file(\n        self, file_path: str, add_extra: bool = False\n    ) -> Optional[ContextFile]:\n        if self._repo and hasattr(self._repo, \"get_relative_path\"):\n            file_path = self._repo.get_relative_path(file_path)\n\n        context_file = self._files.get(file_path)\n\n        if not context_file:\n            if not self._repo.file_exists(file_path):\n                logger.info(f\"get_context_file({file_path}) File not found\")\n                return None\n\n            if self..."
  },
  {
    "name": "get_context_files",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "list",
      "self._files.keys",
      "self.get_context_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 965,
      "end_line": 968
    },
    "code_snippet": "def get_context_files(self) -> List[ContextFile]:\n        file_paths = list(self._files.keys())\n        for file_path in file_paths:\n            yield self.get_context_file(file_path)"
  },
  {
    "name": "context_size",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.create_prompt",
      "count_tokens"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 970,
      "end_line": 983
    },
    "code_snippet": "def context_size(self):\n        if self._repo:\n            content = self.create_prompt(\n                show_span_ids=False,\n                show_line_numbers=True,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"...\",\n                only_signatures=False,\n            )\n            return count_tokens(content)\n\n        # TODO: This doesnt give accure results. Will count tokens in the generated prompt instead\n        # sum(file.context_size() for file in se..."
  },
  {
    "name": "available_context_size",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.context_size"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 985,
      "end_line": 986
    },
    "code_snippet": "def available_context_size(self):\n        return self._max_tokens - self.context_size()"
  },
  {
    "name": "save_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "file_path",
      "updated_content"
    ],
    "calls": [
      "self._repo.save_file"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 988,
      "end_line": 989
    },
    "code_snippet": "def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        self._repo.save_file(file_path, updated_content)"
  },
  {
    "name": "reset",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 991,
      "end_line": 993
    },
    "code_snippet": "def reset(self):\n        self._files = {}\n        self._test_files = {}"
  },
  {
    "name": "is_empty",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 995,
      "end_line": 996
    },
    "code_snippet": "def is_empty(self):\n        return not self._files"
  },
  {
    "name": "strip_line_breaks_only",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "text"
    ],
    "calls": [
      "rstrip",
      "text.lstrip"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 998,
      "end_line": 999
    },
    "code_snippet": "def strip_line_breaks_only(self, text):\n        return text.lstrip(\"\\n\\r\").rstrip(\"\\n\\r\")"
  },
  {
    "name": "create_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "show_span_ids",
      "show_line_numbers",
      "exclude_comments",
      "show_outcommented_code",
      "outcomment_code_comment",
      "files",
      "only_signatures",
      "max_tokens"
    ],
    "calls": [
      "self.get_context_files",
      "join",
      "context_file.to_prompt",
      "count_tokens",
      "file_contexts.append",
      "logger.warning"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 1001,
      "end_line": 1039
    },
    "code_snippet": "def create_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n        files: set | None = None,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n    ):\n        file_contexts = []\n        current_tokens = 0\n\n        for context_file in self.get_context_files():\n            if not files or context_file.file_path in file..."
  },
  {
    "name": "create_summary",
    "docstring": "Creates a summary of the files and spans in the context.\n\nReturns:\n    str: A formatted summary string listing files and their spans",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.is_empty",
      "self.get_context_files",
      "join",
      "context_file.context_size",
      "summary.append",
      "summary.append",
      "context_file.patch.split",
      "sum",
      "sum",
      "summary.append",
      "summary.append",
      "spans.append",
      "spans.append",
      "join",
      "line.startswith",
      "line.startswith",
      "line.startswith",
      "line.startswith"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 1041,
      "end_line": 1088
    },
    "code_snippet": "def create_summary(self) -> str:\n        \"\"\"\n        Creates a summary of the files and spans in the context.\n\n        Returns:\n            str: A formatted summary string listing files and their spans\n        \"\"\"\n        if self.is_empty():\n            return \"No files in context\"\n\n        summary = []\n        for context_file in self.get_context_files():\n            # Get file stats\n            tokens = context_file.context_size()\n\n            # Get patch stats if available\n            patch_s..."
  },
  {
    "name": "add_file_context",
    "docstring": "Adds spans from another FileContext to the current one and returns newly added span IDs.\n\nArgs:\n    other_context: The FileContext to merge into this one\n\nReturns:\n    List[str]: List of newly added span IDs",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self",
      "other_context"
    ],
    "calls": [
      "self.has_file",
      "self.add_file",
      "self.get_context_file",
      "context_file.add_span",
      "new_span_ids.append"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 1090,
      "end_line": 1121
    },
    "code_snippet": "def add_file_context(self, other_context: \"FileContext\") -> List[str]:\n        \"\"\"\n        Adds spans from another FileContext to the current one and returns newly added span IDs.\n\n        Args:\n            other_context: The FileContext to merge into this one\n\n        Returns:\n            List[str]: List of newly added span IDs\n        \"\"\"\n        new_span_ids = []\n\n        for other_file in other_context.files:\n            file_path = other_file.file_path\n\n            if not self.has_file(file..."
  },
  {
    "name": "clone",
    "docstring": "",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.model_dump",
      "FileContext",
      "cloned_context.load_files_from_dict",
      "dump.get"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 1122,
      "end_line": 1130
    },
    "code_snippet": "def clone(self):\n        dump = self.model_dump(\n            exclude={\"files\": {\"__all__\": {\"was_edited\", \"was_viewed\"}}}\n        )\n        cloned_context = FileContext(repo=self._repo)\n        cloned_context.load_files_from_dict(\n            files=dump.get(\"files\", [])\n        )\n        return cloned_context"
  },
  {
    "name": "span_count",
    "docstring": "Returns the total number of span IDs across all files in the context.\n\nReturns:\n    int: Total number of span IDs",
    "is_method": true,
    "class_name": "FileContext",
    "parameters": [
      "self"
    ],
    "calls": [
      "self._files.values",
      "len",
      "span_ids.extend"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 1131,
      "end_line": 1141
    },
    "code_snippet": "def span_count(self) -> int:\n        \"\"\"\n        Returns the total number of span IDs across all files in the context.\n\n        Returns:\n            int: Total number of span IDs\n        \"\"\"\n        span_ids = []\n        for file in self._files.values():\n            span_ids.extend(file.span_ids)\n        return len(span_ids)"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "MoatlessSolve",
    "parameters": [
      "self",
      "repo_name",
      "repo_path"
    ],
    "calls": [
      "CompletionModel",
      "create_repository",
      "CodeIndex.from_index_name",
      "FileContext",
      "BestFirstSelector",
      "ValueFunction",
      "CodeQAAgent.create",
      "GroundTruthFeedbackGenerator",
      "FindClass",
      "FindFunction",
      "FindCodeSnippet",
      "FindCalledObject",
      "SemanticSearch",
      "ViewCode",
      "Finish"
    ],
    "code_location": {
      "file": "moatless_solve.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 23,
      "end_line": 57
    },
    "code_snippet": "def __init__(self, repo_name:str, repo_path: str):\n        # Global variables are used here as defined above the class:\n        # instance, repo_base_dir, index_store_dir, instance_path, persist_path\n    \n        completion_model = CompletionModel(model=\"deepseek/deepseek-chat\", temperature=0.7)\n        completion_model.response_format = LLMResponseFormat.TOOLS\n        repository = create_repository(instance, repo_base_dir=repo_base_dir)\n\n        code_index = CodeIndex.from_index_name(\n         ..."
  },
  {
    "name": "moatless_solve",
    "docstring": "",
    "is_method": true,
    "class_name": "MoatlessSolve",
    "parameters": [
      "self",
      "question"
    ],
    "calls": [
      "CodeQASearchTree.create",
      "search_tree.run_search"
    ],
    "code_location": {
      "file": "moatless_solve.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 59,
      "end_line": 69
    },
    "code_snippet": "def moatless_solve(self, question: str):\n        search_tree = CodeQASearchTree.create(\n            message=question, \n            **self.search_args,\n            max_iterations=100,\n            max_expansions=3,\n            max_depth=25,\n            persist_path=self.persist_path\n        )\n        res_node = search_tree.run_search()\n        return res_node.observation.message if res_node else None"
  },
  {
    "name": "_missing_",
    "docstring": "Handle case-insensitive enum lookup",
    "is_method": true,
    "class_name": "MessageHistoryType",
    "parameters": [
      "cls",
      "value"
    ],
    "calls": [
      "member.value.lower",
      "value.lower"
    ],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 17,
      "end_line": 22
    },
    "code_snippet": "def _missing_(cls, value: str):\n        \"\"\"Handle case-insensitive enum lookup\"\"\"\n        for member in cls:\n            if member.value.lower() == value.lower():\n                return member\n        return None"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "MessageHistoryType",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 24,
      "end_line": 25
    },
    "code_snippet": "def __str__(self):\n        return self.value"
  },
  {
    "name": "json",
    "docstring": "Custom JSON serialization",
    "is_method": true,
    "class_name": "MessageHistoryType",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 27,
      "end_line": 29
    },
    "code_snippet": "def json(self):\n        \"\"\"Custom JSON serialization\"\"\"\n        return self.value"
  },
  {
    "name": "add_span_id",
    "docstring": "",
    "is_method": true,
    "class_name": "FileWithSpans",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "self.span_ids.append"
    ],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 41,
      "end_line": 43
    },
    "code_snippet": "def add_span_id(self, span_id):\n        if span_id not in self.span_ids:\n            self.span_ids.append(span_id)"
  },
  {
    "name": "add_span_ids",
    "docstring": "",
    "is_method": true,
    "class_name": "FileWithSpans",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [
      "self.add_span_id"
    ],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 45,
      "end_line": 47
    },
    "code_snippet": "def add_span_ids(self, span_ids: list[str]):\n        for span_id in span_ids:\n            self.add_span_id(span_id)"
  },
  {
    "name": "__eq__",
    "docstring": "",
    "is_method": true,
    "class_name": "FileWithSpans",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 49,
      "end_line": 50
    },
    "code_snippet": "def __eq__(self, other: \"FileWithSpans\"):\n        return self.file_path == other.file_path and self.span_ids == other.span_ids"
  },
  {
    "name": "create",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "cls",
      "message",
      "root",
      "file_context",
      "repository",
      "expander",
      "selector",
      "agent",
      "value_function",
      "feedback_generator",
      "persist_path",
      "max_expansions",
      "max_iterations",
      "max_depth"
    ],
    "calls": [
      "Expander",
      "cls",
      "ValueError",
      "FileContext",
      "Node",
      "BestFirstSelector"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 71,
      "end_line": 115
    },
    "code_snippet": "def create(\n        cls,\n        message: Optional[str] = None,\n        root: Optional[Node] = None,\n        file_context: Optional[FileContext] = None,\n        repository: Repository | None = None,\n        expander: Expander | None = None,\n        selector: Optional[Selector] = None,\n        agent: Optional[ActionAgent] = None,\n        value_function: Optional[ValueFunction] = None,\n        feedback_generator: Optional[FeedbackGenerator] = None,\n        persist_path: Optional[str] = None,\n     ..."
  },
  {
    "name": "run_search",
    "docstring": "Run the MCTS algorithm for a specified number of iterations.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_all_trajectory",
      "self.is_finished",
      "self._select",
      "len",
      "print",
      "print",
      "self._expand",
      "self._simulate",
      "self._backpropagate",
      "new_node.is_terminal",
      "print",
      "self.get_finished_nodes",
      "len",
      "len",
      "len",
      "self.root.get_all_nodes",
      "self.get_finished_nodes",
      "self.root.get_all_nodes"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 118,
      "end_line": 150
    },
    "code_snippet": "def run_search(self) -> Node | None:\n        \"\"\"Run the MCTS algorithm for a specified number of iterations.\"\"\"\n        # if len(self.root.get_all_nodes()) > 1:\n        #     self.log(\n        #         logger.info,\n        #         f\"Restarting search tree with {len(self.root.get_all_nodes())} nodes\",\n        #     )\n\n        while not self.is_finished():\n            node = self._select(self.root)\n\n            if node:\n                new_node = self._expand(node)\n                self._simulat..."
  },
  {
    "name": "_select",
    "docstring": "Select a node for expansion using the UCT algorithm.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.get_expandable_descendants",
      "self.selector.select",
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 153,
      "end_line": 189
    },
    "code_snippet": "def _select(self, node: Node) -> Optional[Node]:\n        \"\"\"Select a node for expansion using the UCT algorithm.\"\"\"\n        expandable_nodes = node.get_expandable_descendants()\n\n        if not expandable_nodes:\n            print(\"No expandable nodes found.\")\n            return None\n\n        #         if expandable_nodes and self.finish_before_reexpanding:\n        #     # Sort by node_id to get the most recently created node\n        #     latest_node = max(expandable_nodes, key=lambda n: n.node_i..."
  },
  {
    "name": "_expand",
    "docstring": "Expand the node and return a child node.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node",
      "force_expansion"
    ],
    "calls": [
      "self.expander.expand",
      "print",
      "node.has_unexecuted_actions",
      "print",
      "self.feedback_generator.generate_feedback",
      "len"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 192,
      "end_line": 217
    },
    "code_snippet": "def _expand(self, node: Node, force_expansion: bool = False) -> Node:\n        \"\"\"Expand the node and return a child node.\"\"\"\n\n        # Check if any action step was not executed, if so return the node\n        if node.action_steps and node.has_unexecuted_actions():\n            print(\n                f\"Returning Node{node.node_id} with unexecuted actions\"\n            )\n            return node\n\n        child_node = self.expander.expand(node, self, force_expansion)\n\n        if not node.action_steps ..."
  },
  {
    "name": "_simulate",
    "docstring": "Simulate a playout by executing the action and evaluating the result.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node",
      "experience"
    ],
    "calls": [
      "print",
      "self.agent.run",
      "self.value_function.get_reward",
      "print",
      "print",
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 220,
      "end_line": 247
    },
    "code_snippet": "def _simulate(self, node: Node, experience=None):\n        \"\"\"Simulate a playout by executing the action and evaluating the result.\"\"\"\n\n        if node.observation:\n            print(f\"Node{node.node_id}: Action already executed. Skipping.\")\n        else:\n            self.agent.run(node, experience)\n\n        if self.value_function and not node.is_duplicate and node.observation:\n            try:\n                node.reward, completion_response = self.value_function.get_reward(\n                    ..."
  },
  {
    "name": "_backpropagate",
    "docstring": "Backpropagate the reward up the tree.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 250,
      "end_line": 266
    },
    "code_snippet": "def _backpropagate(self, node: Node):\n        \"\"\"Backpropagate the reward up the tree.\"\"\"\n    \n        if not node.reward:\n            print(\n                f\"Node{node.node_id} has no evaluation. Skipping backpropagation.\",\n            )\n            return\n    \n        reward = node.reward.value\n        while node is not None:\n            node.visits += 1\n            if not node.value:\n                node.value = reward\n            else:\n                node.value += reward\n            node =..."
  },
  {
    "name": "get_finished_nodes",
    "docstring": "Get all finished nodes in the search tree by uniqe parent node.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "set",
      "self.root.get_all_nodes",
      "node.is_finished",
      "parent_ids.add",
      "finished_nodes.append"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 269,
      "end_line": 279
    },
    "code_snippet": "def get_finished_nodes(self) -> List[Node]:\n        \"\"\"Get all finished nodes in the search tree by uniqe parent node.\"\"\"\n        parent_ids = set()\n        finished_nodes = []\n        for node in self.root.get_all_nodes():\n            # TODO: Pick finished node with highest/avg/lowest reward?\n            if node.is_finished() and node.parent.node_id not in parent_ids:\n                parent_ids.add(node.parent.node_id)\n                finished_nodes.append(node)\n\n        return finished_nodes"
  },
  {
    "name": "is_finished",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_finished_nodes",
      "set",
      "self.root.get_expandable_descendants",
      "len",
      "print",
      "unique_finished_parents.add",
      "print",
      "self.root.get_all_nodes"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 282,
      "end_line": 302
    },
    "code_snippet": "def is_finished(self):\n        \n        # Check max iterations\n        if len(self.root.get_all_nodes()) >= self.max_iterations:\n            print(\n                f\"Search finished: Reached max iterations {self.max_iterations}\"\n            )\n            return True\n\n        finished_nodes = self.get_finished_nodes()\n        unique_finished_parents = set()\n        for node in finished_nodes:\n            unique_finished_parents.add(node.parent.node_id)\n\n        # Check if there are no more expand..."
  },
  {
    "name": "get_leaf_nodes",
    "docstring": "Get all leaf nodes in the search tree.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.root.get_all_nodes",
      "node.is_leaf"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 305,
      "end_line": 307
    },
    "code_snippet": "def get_leaf_nodes(self) -> List[Node]:\n        \"\"\"Get all leaf nodes in the search tree.\"\"\"\n        return [node for node in self.root.get_all_nodes() if node.is_leaf()]"
  },
  {
    "name": "_generate_unique_id",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 310,
      "end_line": 312
    },
    "code_snippet": "def _generate_unique_id(self) -> int:\n        self.unique_id += 1\n        return self.unique_id"
  },
  {
    "name": "get_best_trajectory",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 315,
      "end_line": 316
    },
    "code_snippet": "def get_best_trajectory(self) -> Node | None:\n        pass"
  },
  {
    "name": "get_all_trajectory",
    "docstring": "Get all finished trajectory to return",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.get_finished_nodes",
      "print",
      "self.get_leaf_nodes",
      "print",
      "len",
      "len"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 319,
      "end_line": 336
    },
    "code_snippet": "def get_all_trajectory(self) -> Node | None:\n        \"\"\"\n        Get all finished trajectory to return\n        \"\"\"\n        nodes = self.get_finished_nodes()\n        if not nodes:\n            nodes = self.get_leaf_nodes()\n            print(\n                f\"get_best_trajectory() No finished nodes found. Will select from {len(nodes)} leaf nodes.\",\n            )\n\n        if len(nodes) == 1:\n            return nodes[0]\n\n        print(\n                \"No discriminator provided. Returning all the fi..."
  },
  {
    "name": "display_value",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 348,
      "end_line": 352
    },
    "code_snippet": "def display_value(self, node):\n        # 自底向上打印node的value值\n        while node:\n            print(f'The value of Node {node.node_id} is {node.value}')\n            node = node.parent"
  },
  {
    "name": "display_uct",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.selector.uct_score",
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 355,
      "end_line": 360
    },
    "code_snippet": "def display_uct(self, node):\n        # 自底向上打印node的uct值\n        while node:\n            value = self.selector.uct_score(node)\n            print(f'The uct score list of Node {node.node_id} is {value}')\n            node = node.parent"
  },
  {
    "name": "persist",
    "docstring": "Persist the entire SearchTree to a file.\n\nArgs:\n    file_path (str): The path to the file where the tree will be saved.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.model_dump",
      "os.makedirs",
      "os.path.dirname",
      "open",
      "json.dump",
      "print"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 363,
      "end_line": 380
    },
    "code_snippet": "def persist(self, **kwargs):\n        \"\"\"\n        Persist the entire SearchTree to a file.\n\n        Args:\n            file_path (str): The path to the file where the tree will be saved.\n        \"\"\"\n        tree_data = self.model_dump(**kwargs)\n        os.makedirs(os.path.dirname(self.persist_path), exist_ok=True)\n        \n        with open(self.persist_path, \"w\") as f:\n            try:\n                json.dump(tree_data, f, indent=2)\n            except Exception as e:\n                print(\n    ..."
  },
  {
    "name": "model_dump",
    "docstring": "Generate a dictionary representation of the SearchTree.\n\nReturns:\n    Dict[str, Any]: A dictionary representation of the search tree.",
    "is_method": true,
    "class_name": "CodeQASearchTree",
    "parameters": [
      "self"
    ],
    "calls": [
      "data.pop",
      "self.selector.model_dump",
      "self.expander.model_dump",
      "self.agent.model_dump",
      "self.root.model_dump",
      "getattr",
      "self.repository.model_dump",
      "self.value_function.model_dump"
    ],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 383,
      "end_line": 428
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Generate a dictionary representation of the SearchTree.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the search tree.\n        \"\"\"\n        data = {\n            field: getattr(self, field)\n            for field in self.model_fields\n            if field\n            not in [\n                \"root\",\n                \"selector\",\n                \"repository\",\n                \"agent\",\n                \"va..."
  },
  {
    "name": "to_prompt_format",
    "docstring": "",
    "is_method": true,
    "class_name": "Artifact",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 26,
      "end_line": 27
    },
    "code_snippet": "def to_prompt_format(self) -> PromptModel:\n        pass"
  },
  {
    "name": "load",
    "docstring": "",
    "is_method": true,
    "class_name": "ArtifactHandler",
    "parameters": [
      "self",
      "artifact_id"
    ],
    "calls": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 50,
      "end_line": 51
    },
    "code_snippet": "def load(self, artifact_id: str) -> T:\n        pass"
  },
  {
    "name": "save",
    "docstring": "",
    "is_method": true,
    "class_name": "ArtifactHandler",
    "parameters": [
      "self",
      "artifact"
    ],
    "calls": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 54,
      "end_line": 55
    },
    "code_snippet": "def save(self, artifact: T) -> None:\n        pass"
  },
  {
    "name": "update",
    "docstring": "",
    "is_method": true,
    "class_name": "ArtifactHandler",
    "parameters": [
      "self",
      "artifact"
    ],
    "calls": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 58,
      "end_line": 59
    },
    "code_snippet": "def update(self, artifact: T) -> None:\n        pass"
  },
  {
    "name": "delete",
    "docstring": "",
    "is_method": true,
    "class_name": "ArtifactHandler",
    "parameters": [
      "self",
      "artifact_id"
    ],
    "calls": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 62,
      "end_line": 63
    },
    "code_snippet": "def delete(self, artifact_id: str) -> None:\n        pass"
  },
  {
    "name": "to_prompt_format",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifact",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.mime_type.startswith",
      "self.content.decode",
      "TextPromptModel",
      "decode",
      "ImageURLPromptModel",
      "base64.b64encode"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 25,
      "end_line": 39
    },
    "code_snippet": "def to_prompt_format(self) -> PromptModel:\n        if self.mime_type is None:\n            self.mime_type = \"text/plain\"\n\n        if self.mime_type.startswith(\"text/\"):\n            # Return TextPromptModel for text content\n            text_str = self.content.decode(\"utf-8\", errors=\"replace\")\n            return TextPromptModel(type=\"text\", text=text_str)\n        else:\n            # Return ImageURLPromptModel for binary content\n            encoded = base64.b64encode(self.content).decode(\"utf-8\")\n  ..."
  },
  {
    "name": "_detect_mime_type",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifactHandler",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "mimetypes.guess_type"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 48,
      "end_line": 50
    },
    "code_snippet": "def _detect_mime_type(self, file_path: str) -> str:\n        mime_type, _ = mimetypes.guess_type(file_path)\n        return mime_type or \"application/octet-stream\""
  },
  {
    "name": "load",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifactHandler",
    "parameters": [
      "self",
      "artifact_id"
    ],
    "calls": [
      "FileArtifact",
      "str",
      "self._detect_mime_type",
      "str",
      "file_path.exists",
      "file_path.read_bytes"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 52,
      "end_line": 61
    },
    "code_snippet": "def load(self, artifact_id: str) -> FileArtifact:\n        file_path = self.directory_path / artifact_id\n        return FileArtifact(\n            id=artifact_id,\n            type=self.type,\n            name=file_path.name,\n            file_path=str(file_path),\n            mime_type=self._detect_mime_type(str(file_path)),\n            content=file_path.read_bytes() if file_path.exists() else None,\n        )"
  },
  {
    "name": "save",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifactHandler",
    "parameters": [
      "self",
      "artifact"
    ],
    "calls": [
      "file_path.parent.mkdir",
      "file_path.write_bytes"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 63,
      "end_line": 67
    },
    "code_snippet": "def save(self, artifact: FileArtifact) -> None:\n        file_path = self.directory_path / artifact.file_path\n        if artifact.content:\n            file_path.parent.mkdir(parents=True, exist_ok=True)\n            file_path.write_bytes(artifact.content)"
  },
  {
    "name": "update",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifactHandler",
    "parameters": [
      "self",
      "artifact"
    ],
    "calls": [
      "self.save"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 69,
      "end_line": 70
    },
    "code_snippet": "def update(self, artifact: FileArtifact) -> None:\n        self.save(artifact)"
  },
  {
    "name": "delete",
    "docstring": "",
    "is_method": true,
    "class_name": "FileArtifactHandler",
    "parameters": [
      "self",
      "artifact_id"
    ],
    "calls": [
      "file_path.exists",
      "file_path.unlink"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 72,
      "end_line": 75
    },
    "code_snippet": "def delete(self, artifact_id: str) -> None:\n        file_path = self.directory_path / artifact_id\n        if file_path.exists():\n            file_path.unlink()"
  },
  {
    "name": "load_moatless_datasets",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "split"
    ],
    "calls": [
      "_load_moatless_dataset",
      "_load_moatless_dataset",
      "_load_moatless_dataset"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 18,
      "end_line": 25
    },
    "code_snippet": "def load_moatless_datasets(split: str | None):\n    global _moatless_instances\n\n    if split:\n        _load_moatless_dataset(split)\n    else:\n        _load_moatless_dataset(\"lite\")\n        _load_moatless_dataset(\"verified\")"
  },
  {
    "name": "_load_moatless_dataset",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "split"
    ],
    "calls": [
      "os.path.join",
      "os.path.dirname",
      "open",
      "json.load",
      "_moatless_instances.update"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 28,
      "end_line": 36
    },
    "code_snippet": "def _load_moatless_dataset(split: str):\n    global _moatless_instances\n\n    file_path = os.path.join(\n        os.path.dirname(__file__), f\"swebench_{split}_all_evaluations.json\"\n    )\n    with open(file_path) as f:\n        dataset = json.load(f)\n        _moatless_instances.update({d[\"instance_id\"]: d for d in dataset})"
  },
  {
    "name": "get_moatless_instances",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "split"
    ],
    "calls": [
      "load_moatless_datasets"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 39,
      "end_line": 43
    },
    "code_snippet": "def get_moatless_instances(split: str | None = None):\n    global _moatless_instances\n    if not _moatless_instances:\n        load_moatless_datasets(split)\n    return _moatless_instances"
  },
  {
    "name": "get_moatless_instance",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance_id",
      "split"
    ],
    "calls": [
      "_moatless_instances.get",
      "load_moatless_datasets",
      "ValueError"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 46,
      "end_line": 55
    },
    "code_snippet": "def get_moatless_instance(instance_id: str, split: str | None = None):\n    global _moatless_instances\n    if not _moatless_instances:\n        load_moatless_datasets(split)\n    # instance = _moatless_instances.get(split).get(instance_id)\n    instance = _moatless_instances.get(instance_id)\n    if not instance:\n        raise ValueError(f\"Instance {instance_id} not found.\")\n\n    return instance"
  },
  {
    "name": "find_relevant_spans",
    "docstring": "Find relevant spans in test content. Used for finding the \"perfect\" context in benchmark instances.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "original_block",
      "updated_block"
    ],
    "calls": [
      "set",
      "updated_block.spans_by_id.values",
      "original_block.has_span",
      "strip",
      "strip",
      "original_block.find_related_span_ids",
      "relevant_spans.update",
      "original_block.find_by_path",
      "list",
      "updated_block.find_related_span_ids",
      "relevant_spans.add",
      "updated_block.find_first_by_span_id",
      "parent_block.full_path",
      "original_block.has_span",
      "updated_block.to_prompt",
      "original_block.to_prompt",
      "span_ids.append",
      "set",
      "set"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 58,
      "end_line": 92
    },
    "code_snippet": "def find_relevant_spans(original_block: Module, updated_block: Module):\n    \"\"\"Find relevant spans in test content. Used for finding the \"perfect\" context in benchmark instances.\"\"\"\n\n    relevant_spans = set()\n\n    for span in updated_block.spans_by_id.values():\n        if span.span_id in relevant_spans:\n            continue\n\n        if original_block.has_span(span.span_id):\n            updated_content = updated_block.to_prompt(\n                span_ids=set(span.span_id), show_outcommented_code=..."
  },
  {
    "name": "get_diff_lines",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "diff_input"
    ],
    "calls": [
      "re.compile",
      "re.compile",
      "re.compile",
      "diff_input.splitlines",
      "file_name_re.match",
      "line_change_re.match",
      "file_match.group",
      "file_name_no_git_re.match",
      "map",
      "max",
      "max",
      "changes.append",
      "file_match.group",
      "line_change_match.groups",
      "min"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 95,
      "end_line": 140
    },
    "code_snippet": "def get_diff_lines(diff_input):\n    if not diff_input:\n        return []\n    file_name_re = re.compile(r\"diff --git a/(.+) b/.+\")\n    file_name_no_git_re = re.compile(r\"--- a/(.+)\")\n\n    line_change_re = re.compile(r\"^@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@\")\n\n    changes = []\n\n    current_file = None\n    for line in diff_input.splitlines():\n        file_match = file_name_re.match(line)\n        if file_match:\n            current_file = file_match.group(1)\n            continue\n\n        if not current_fi..."
  },
  {
    "name": "compare_patches",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_patch",
      "actual_patch"
    ],
    "calls": [
      "get_diff_lines",
      "get_diff_lines",
      "set",
      "set",
      "expected_files.add",
      "len",
      "len",
      "len",
      "file_hits.add"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 143,
      "end_line": 171
    },
    "code_snippet": "def compare_patches(expected_patch, actual_patch):\n    expected_diffs = get_diff_lines(expected_patch)\n    actual_diffs = get_diff_lines(actual_patch)\n\n    expected_files = set()\n    file_hits = set()\n    line_hits = 0\n\n    for patch_diff in expected_diffs:\n        change_file, change_start, change_end, change_type = patch_diff\n\n        for actual_diff in actual_diffs:\n            (\n                actual_change_file,\n                actual_change_start,\n                actual_change_end,\n      ..."
  },
  {
    "name": "create_file_spans_from_patch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "patch"
    ],
    "calls": [
      "FileRepository",
      "items",
      "FileWithSpans",
      "files_with_spans.append",
      "get_file_spans_from_patch"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 174,
      "end_line": 184
    },
    "code_snippet": "def create_file_spans_from_patch(repo_dir: str, patch: str) -> list[FileWithSpans]:\n    repository = FileRepository(repo_dir)\n    files_with_spans = []\n    for file_path, span_ids in get_file_spans_from_patch(repository, patch).items():\n        file_with_spans = FileWithSpans(\n            file_path=file_path,\n            span_ids=span_ids,\n        )\n        files_with_spans.append(file_with_spans)\n\n    return files_with_spans"
  },
  {
    "name": "get_file_spans_from_patch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repository",
      "patch"
    ],
    "calls": [
      "get_diff_lines",
      "repository.get_file",
      "file.module.find_spans_by_line_numbers",
      "append"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 187,
      "end_line": 206
    },
    "code_snippet": "def get_file_spans_from_patch(\n    repository: FileRepository, patch: str\n) -> dict[str, list[str]]:\n    expected_diff_lines = get_diff_lines(patch)\n    expected_files_with_spans = {}\n\n    for diff_line in expected_diff_lines:\n        change_file, change_start, change_end, change_type = diff_line\n        file = repository.get_file(change_file)\n\n        if file is None or file.module is None:\n            continue\n\n        if file.file_path not in expected_files_with_spans:\n            expected_fi..."
  },
  {
    "name": "get_files_from_patch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "patch"
    ],
    "calls": [
      "get_diff_lines"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 209,
      "end_line": 211
    },
    "code_snippet": "def get_files_from_patch(patch: str) -> list[str]:\n    diff_lines = get_diff_lines(patch)\n    return [diff_line[0] for diff_line in diff_lines]"
  },
  {
    "name": "file_spans_to_dict",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "files_with_spans"
    ],
    "calls": [
      "append"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 214,
      "end_line": 226
    },
    "code_snippet": "def file_spans_to_dict(files_with_spans: list[FileWithSpans]) -> dict[str, list[str]]:\n    span_dict = {}\n    if not files_with_spans:\n        return span_dict\n\n    for file_with_spans in files_with_spans:\n        if file_with_spans.file_path not in span_dict:\n            span_dict[file_with_spans.file_path] = []\n\n        for span_id in file_with_spans.span_ids:\n            if span_id not in span_dict[file_with_spans.file_path]:\n                span_dict[file_with_spans.file_path].append(span_id..."
  },
  {
    "name": "get_missing_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_files_with_spans",
      "files"
    ],
    "calls": [
      "list",
      "expected_files_with_spans.keys",
      "misses.remove"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 229,
      "end_line": 237
    },
    "code_snippet": "def get_missing_files(\n    expected_files_with_spans: dict[str, list[str]],\n    files: list[str],\n) -> list[str]:\n    misses = list(expected_files_with_spans.keys())\n    for actual_file in files:\n        if actual_file in misses:\n            misses.remove(actual_file)\n    return misses"
  },
  {
    "name": "get_missing_spans",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_files_with_spans",
      "actual_files_with_spans"
    ],
    "calls": [
      "expected_files_with_spans.items"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 240,
      "end_line": 259
    },
    "code_snippet": "def get_missing_spans(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> dict[str, list[str]]:\n    misses = {}\n    for expected_file, expected_span_ids in expected_files_with_spans.items():\n        if expected_file not in actual_files_with_spans:\n            actual_span_ids = []\n        else:\n            actual_span_ids = actual_files_with_spans[expected_file]\n\n        missing_span_ids = [\n            span_id\n            for span_id in e..."
  },
  {
    "name": "count_identified_spans",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_files_with_spans",
      "actual_files_with_spans"
    ],
    "calls": [
      "actual_files_with_spans.items",
      "expected_files_with_spans.get"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 262,
      "end_line": 272
    },
    "code_snippet": "def count_identified_spans(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> int:\n    count = 0\n    for actual_file, actual_span_ids in actual_files_with_spans.items():\n        if expected_files_with_spans.get(actual_file, []):\n            for actual_span_id in actual_span_ids:\n                if actual_span_id in expected_files_with_spans[actual_file]:\n                    count += 1\n    return count"
  },
  {
    "name": "count_identified_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_files_with_spans",
      "actual_files_with_spans"
    ],
    "calls": [
      "actual_files_with_spans.items",
      "expected_files_with_spans.get"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 275,
      "end_line": 283
    },
    "code_snippet": "def count_identified_files(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> int:\n    count = 0\n    for actual_file, actual_span_ids in actual_files_with_spans.items():\n        if expected_files_with_spans.get(actual_file, []):\n            count += 1\n    return count"
  },
  {
    "name": "has_identified_spans",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_solutions",
      "actual_files_with_spans"
    ],
    "calls": [
      "get_missing_spans"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 286,
      "end_line": 296
    },
    "code_snippet": "def has_identified_spans(\n    expected_solutions: list[dict[str, list[str]]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> bool:\n    for expected_file_with_spans in expected_solutions:\n        missing_spans = get_missing_spans(\n            expected_file_with_spans, actual_files_with_spans\n        )\n        if not missing_spans or missing_spans == [\"docstring\"]:\n            return True\n    return False"
  },
  {
    "name": "has_identified_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "expected_solutions",
      "actual_files_with_spans"
    ],
    "calls": [
      "isinstance",
      "list",
      "actual_files_with_spans.keys",
      "get_missing_files"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 299,
      "end_line": 311
    },
    "code_snippet": "def has_identified_files(\n    expected_solutions: list[dict[str, list[str]]],\n    actual_files_with_spans: dict[str, list[str]] | list[str],\n) -> bool:\n    if isinstance(actual_files_with_spans, dict):\n        actual_files = list(actual_files_with_spans.keys())\n    else:\n        actual_files = actual_files_with_spans\n\n    for expected_file_with_spans in expected_solutions:\n        if not get_missing_files(expected_file_with_spans, actual_files):\n            return True\n    return False"
  },
  {
    "name": "calculate_estimated_context_window",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "results"
    ],
    "calls": [
      "get_diff_lines",
      "enumerate",
      "instance.get",
      "instance.get",
      "expected_changes.append",
      "logger.info",
      "all",
      "change.get",
      "abs",
      "abs",
      "abs",
      "abs"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 314,
      "end_line": 372
    },
    "code_snippet": "def calculate_estimated_context_window(instance, results):\n    patch = instance.get(\"patch\") or instance.get(\"golden_patch\")\n    patch_diffs = get_diff_lines(patch)\n    expected_changes = []\n\n    for patch_diff in patch_diffs:\n        change_file, change_start, change_end, change_type = patch_diff\n        expected_changes.append(\n            {\n                \"file_path\": change_file,\n                \"start_line\": change_start,\n                \"end_line\": change_end,\n                \"closest_mat..."
  },
  {
    "name": "read_search_trees",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "dir"
    ],
    "calls": [
      "os.walk",
      "os.path.join",
      "os.path.exists",
      "CodeQASearchTree.from_file",
      "search_trees.append",
      "logger.warning",
      "logger.exception",
      "os.stat"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 375,
      "end_line": 391
    },
    "code_snippet": "def read_search_trees(dir: str) -> list[CodeQASearchTree]:\n    search_trees = []\n    for root, _, files in os.walk(dir):\n        trajectory_path = os.path.join(root, \"trajectory.json\")\n        if not os.path.exists(trajectory_path):\n            continue\n\n        try:\n            if os.stat(trajectory_path).st_size == 0:\n                logger.warning(f\"Empty trajectory file: {trajectory_path}\")\n                continue\n\n            search_tree = CodeQASearchTree.from_file(trajectory_path)\n      ..."
  },
  {
    "name": "trace_metadata",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance_id",
      "session_id",
      "trace_name"
    ],
    "calls": [
      "time.strftime"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
      "start_line": 394,
      "end_line": 403
    },
    "code_snippet": "def trace_metadata(instance_id: str, session_id: str, trace_name: str):\n    date_time_str = time.strftime(\"%Y%m%d-%H%M%S\")\n    trace_id = f\"coder_{instance_id}_{date_time_str}\"\n    return {\n        \"session_id\": session_id,\n        \"name\": trace_name,\n        \"trace\": trace_name,\n        \"trace_id\": trace_id,\n        \"tags\": [instance_id],\n    }"
  },
  {
    "name": "load_instances",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "dataset_name",
      "split"
    ],
    "calls": [
      "load_dataset"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 23,
      "end_line": 29
    },
    "code_snippet": "def load_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\", split: str = \"test\"\n):\n    from datasets import load_dataset\n\n    data = load_dataset(dataset_name, split=split)\n    return {d[\"instance_id\"]: d for d in data}"
  },
  {
    "name": "load_instance",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance_id",
      "dataset_name",
      "split"
    ],
    "calls": [
      "load_instances"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 32,
      "end_line": 38
    },
    "code_snippet": "def load_instance(\n    instance_id: str,\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n):\n    data = load_instances(dataset_name, split=split)\n    return data[instance_id]"
  },
  {
    "name": "sorted_instances",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "dataset_name",
      "split",
      "sort_by"
    ],
    "calls": [
      "load_dataset",
      "list",
      "sorted"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 41,
      "end_line": 51
    },
    "code_snippet": "def sorted_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n    sort_by: str = \"created_at\",\n):\n    from datasets import load_dataset\n\n    data = load_dataset(dataset_name, split=split)\n    instances = list(data)\n    instances = sorted(instances, key=lambda x: x[sort_by])\n    return instances"
  },
  {
    "name": "get_repo_dir_name",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo"
    ],
    "calls": [
      "repo.replace"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 54,
      "end_line": 55
    },
    "code_snippet": "def get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"__\")"
  },
  {
    "name": "found_in_expected_spans",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "spans"
    ],
    "calls": [
      "items",
      "get_missing_spans",
      "logging.warning"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 58,
      "end_line": 66
    },
    "code_snippet": "def found_in_expected_spans(instance: dict, spans: dict):\n    for file_path, span_ids in instance[\"expected_spans\"].items():\n        if not span_ids:\n            logging.warning(\n                f\"{instance['instance_id']} Expected spans for {file_path} is empty\"\n            )\n\n    missing_spans = get_missing_spans(instance[\"expected_spans\"], spans)\n    return not missing_spans"
  },
  {
    "name": "found_in_alternative_spans",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "spans"
    ],
    "calls": [
      "items",
      "get_missing_spans",
      "logging.info"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 69,
      "end_line": 83
    },
    "code_snippet": "def found_in_alternative_spans(instance: dict, spans: dict):\n    if \"alternative_spans\" not in instance:\n        return False\n    for alternative_spans in instance[\"alternative_spans\"]:\n        for file_path, span_ids in alternative_spans[\"spans\"].items():\n            if not span_ids:\n                logging.info(\n                    f\"{instance['instance_id']} Alternative spans for {file_path} is empty\"\n                )\n\n        missing_spans = get_missing_spans(alternative_spans[\"spans\"], spa..."
  },
  {
    "name": "found_in_alternative_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "files"
    ],
    "calls": [
      "items",
      "get_missing_files",
      "logging.info"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 86,
      "end_line": 100
    },
    "code_snippet": "def found_in_alternative_files(instance: dict, files: list):\n    if \"alternative_spans\" not in instance:\n        return False\n    for alternative_spans in instance[\"alternative_spans\"]:\n        for file_path, span_ids in alternative_spans[\"spans\"].items():\n            if not span_ids:\n                logging.info(\n                    f\"{instance['instance_id']} Alternative spans for {file_path} is empty\"\n                )\n\n        missing_spans = get_missing_files(alternative_spans[\"spans\"], fil..."
  },
  {
    "name": "setup_swebench_repo",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance_data",
      "instance_id",
      "repo_base_dir"
    ],
    "calls": [
      "replace",
      "setup_github_repo",
      "load_instance",
      "os.getenv"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 103,
      "end_line": 123
    },
    "code_snippet": "def setup_swebench_repo(\n    instance_data: Optional[dict] = None,\n    instance_id: str = None,\n    repo_base_dir: Optional[str] = None,\n) -> str:\n    assert (\n        instance_data or instance_id\n    ), \"Either instance_data or instance_id must be provided\"\n    if not instance_data:\n        instance_data = load_instance(instance_id)\n\n    if not repo_base_dir:\n        repo_base_dir = os.getenv(\"REPO_DIR\", \"/tmp/repos\")\n\n    repo_dir_name = instance_data[\"repo\"].replace(\"/\", \"__\")\n    github_repo..."
  },
  {
    "name": "create_repository",
    "docstring": "创建代码仓库的工作区。\n支持三种方式：\n1. 通过instance或instance_id创建SWE-bench实例的工作区\n2. 通过repo_url直接克隆Git仓库\n3. 通过repo_path使用已存在的本地仓库\n\n参数:\n    instance: SWE-bench实例数据字典\n    instance_id: SWE-bench实例ID\n    repo_base_dir: 仓库基础目录\n    repo_url: Git仓库URL\n    repo_path: 本地仓库路径\n    commit: Git提交哈希\n\n返回:\n    Repository: 仓库对象",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "instance_id",
      "repo_base_dir",
      "repo_url",
      "repo_path",
      "commit"
    ],
    "calls": [
      "os.makedirs",
      "os.makedirs",
      "get_repo_dir_name",
      "os.makedirs",
      "print",
      "os.path.exists",
      "os.path.abspath",
      "print",
      "GitRepository.from_repo",
      "os.path.exists",
      "logger.info",
      "os.makedirs",
      "repo_name.endswith",
      "os.path.exists",
      "load_instance",
      "os.getenv",
      "os.path.dirname",
      "os.path.dirname",
      "open",
      "logging.debug",
      "fcntl.flock",
      "logging.debug",
      "fcntl.flock",
      "GitRepository",
      "os.getenv",
      "repo_url.split",
      "logger.info",
      "subprocess.run",
      "logger.info",
      "GitRepository",
      "subprocess.run",
      "logger.info",
      "print",
      "print",
      "GitRepository",
      "os.path.exists",
      "subprocess.run",
      "logger.info",
      "GitRepository",
      "GitRepository",
      "subprocess.run",
      "logger.info",
      "logger.error",
      "logger.warning",
      "shutil.rmtree",
      "logging.warning",
      "shutil.rmtree",
      "retry_clone",
      "logging.info",
      "logger.warning",
      "subprocess.run",
      "logger.info",
      "GitRepository",
      "logger.error",
      "logger.warning",
      "shutil.rmtree"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 126,
      "end_line": 301
    },
    "code_snippet": "def create_repository(\n    instance: Optional[dict] = None,\n    instance_id: Optional[str] = None,\n    repo_base_dir: Optional[str] = None,\n    repo_url: Optional[str] = None,\n    repo_path: Optional[str] = None,\n    commit: Optional[str] = None,\n):\n    \"\"\"\n    创建代码仓库的工作区。\n    支持三种方式：\n    1. 通过instance或instance_id创建SWE-bench实例的工作区\n    2. 通过repo_url直接克隆Git仓库\n    3. 通过repo_path使用已存在的本地仓库\n\n    参数:\n        instance: SWE-bench实例数据字典\n        instance_id: SWE-bench实例ID\n        repo_base_dir: 仓库基础目录\n   ..."
  },
  {
    "name": "create_index",
    "docstring": "为仓库创建代码索引。\n支持多种方式指定仓库：\n1. 提供已有的Repository对象\n2. 提供instance或instance_id（SWE-bench实例）\n3. 提供repo_url（Git仓库URL）\n4. 提供repo_path（本地仓库路径）\n\n参数:\n    instance: SWE-bench实例数据字典\n    repository: 已初始化的Repository对象\n    index_store_dir: 索引存储目录\n    instance_id: SWE-bench实例ID\n    repo_url: Git仓库URL\n    repo_path: 本地仓库路径\n    repo_base_dir: 仓库基础目录\n    commit: Git提交哈希\n    index_name: 索引名称（如果为None，将使用实例ID或从仓库路径/URL派生）\n    force_rebuild: 是否强制重建索引\n\n返回:\n    CodeIndex: 代码索引对象",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "instance",
      "repository",
      "index_store_dir",
      "instance_id",
      "repo_url",
      "repo_path",
      "repo_base_dir",
      "commit",
      "index_name",
      "force_rebuild"
    ],
    "calls": [
      "os.makedirs",
      "os.path.join",
      "logger.info",
      "CodeIndex",
      "print",
      "code_index.run_ingestion",
      "logger.info",
      "code_index.persist",
      "os.getenv",
      "create_repository",
      "os.path.exists",
      "logger.info",
      "os.getenv",
      "os.getenv",
      "os.path.join",
      "instance.get",
      "CodeIndex.from_persist_dir",
      "logger.info",
      "CodeIndex.from_url",
      "logger.warning",
      "logger.warning",
      "os.path.basename",
      "repo_name.endswith",
      "repo_url.split",
      "uuid.uuid4"
    ],
    "code_location": {
      "file": "utils.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
      "start_line": 304,
      "end_line": 413
    },
    "code_snippet": "def create_index(\n    instance: dict = None,\n    repository: Repository | None = None,\n    index_store_dir: Optional[str] = None,\n    instance_id: Optional[str] = None,\n    repo_url: Optional[str] = None,\n    repo_path: Optional[str] = None,\n    repo_base_dir: Optional[str] = None,\n    commit: Optional[str] = None,\n    index_name: Optional[str] = None,\n    force_rebuild: bool = False,\n):\n    \"\"\"\n    为仓库创建代码索引。\n    支持多种方式指定仓库：\n    1. 提供已有的Repository对象\n    2. 提供instance或instance_id（SWE-bench实例）\n  ..."
  },
  {
    "name": "__init__",
    "docstring": "Initialize params.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self",
      "faiss_index",
      "d",
      "data",
      "fs"
    ],
    "calls": [
      "cast",
      "__init__",
      "SimpleVectorStoreData",
      "fsspec.filesystem",
      "ImportError",
      "super"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 68,
      "end_line": 92
    },
    "code_snippet": "def __init__(\n        self,\n        faiss_index: Any,\n        d: int = 1536,\n        data: SimpleVectorStoreData | None = None,\n        fs: fsspec.AbstractFileSystem | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n\n        import_err_msg = \"\"\"\n            `faiss` package not found. For instructions on\n            how to install `faiss` please visit\n            https://github.com/facebookresearch/faiss/wiki/Installing-Faiss\n        \"\"\"\n        try:\n          ..."
  },
  {
    "name": "from_defaults",
    "docstring": "",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "cls",
      "d"
    ],
    "calls": [
      "faiss.IndexIDMap",
      "cls",
      "faiss.IndexFlatL2"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 95,
      "end_line": 97
    },
    "code_snippet": "def from_defaults(cls, d: int = 1536):\n        faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(1536))\n        return cls(faiss_index, d)"
  },
  {
    "name": "client",
    "docstring": "Return the faiss index.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 100,
      "end_line": 102
    },
    "code_snippet": "def client(self) -> Any:\n        \"\"\"Return the faiss index.\"\"\"\n        return self._faiss_index"
  },
  {
    "name": "add",
    "docstring": "Add nodes to index.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "logger.info",
      "np.array",
      "np.array",
      "self._faiss_index.add_with_ids",
      "max",
      "embeddings.append",
      "ids.append",
      "node_to_metadata_dict",
      "metadata.pop",
      "node.get_embedding",
      "int",
      "int",
      "len"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 104,
      "end_line": 142
    },
    "code_snippet": "def add(\n        self,\n        nodes: list[BaseNode],\n        **add_kwargs: Any,\n    ) -> list[str]:\n        \"\"\"Add nodes to index.\"\"\"\n\n        if not nodes:\n            return []\n\n        vector_id = (\n            max([int(k) for k in self._data.vector_id_to_text_id])\n            if self._data.vector_id_to_text_id\n            else 0\n        )\n\n        logger.info(f\"Adding {len(nodes)} nodes to index, start at id {vector_id}.\")\n\n        embeddings = []\n        ids = []\n        for node in nodes:..."
  },
  {
    "name": "delete",
    "docstring": "Delete nodes using with ref_doc_id.\n\nArgs:\n    ref_doc_id (str): The doc_id of the document to delete.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self",
      "ref_doc_id"
    ],
    "calls": [
      "set",
      "self._data.text_id_to_ref_doc_id.items",
      "self._data.vector_id_to_text_id.items",
      "self._text_ids_to_delete.add",
      "self._vector_ids_to_delete.append"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 144,
      "end_line": 160
    },
    "code_snippet": "def delete(self, ref_doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"\n        Delete nodes using with ref_doc_id.\n\n        Args:\n            ref_doc_id (str): The doc_id of the document to delete.\n\n        \"\"\"\n\n        self._text_ids_to_delete = set()\n        for text_id, ref_doc_id_ in self._data.text_id_to_ref_doc_id.items():\n            if ref_doc_id == ref_doc_id_:\n                self._text_ids_to_delete.add(text_id)\n\n        for vector_id, text_id in self._data.vector_id_to_text_id...."
  },
  {
    "name": "query",
    "docstring": "Query index for top k most similar nodes.\n\nArgs:\n    query_embedding (List[float]): query embedding\n    similarity_top_k (int): top k most similar nodes",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self",
      "query"
    ],
    "calls": [
      "_build_metadata_filter_fn",
      "cast",
      "self._faiss_index.search",
      "list",
      "zip",
      "VectorStoreQueryResult",
      "np.array",
      "len",
      "VectorStoreQueryResult",
      "self._data.vector_id_to_text_id.get",
      "logger.info",
      "query_filter_fn",
      "filtered_node_ids.append",
      "filtered_dists.append",
      "dist.item",
      "len"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 162,
      "end_line": 218
    },
    "code_snippet": "def query(\n        self,\n        query: VectorStoreQuery,\n        **kwargs: Any,\n    ) -> VectorStoreQueryResult:\n        \"\"\"Query index for top k most similar nodes.\n\n        Args:\n            query_embedding (List[float]): query embedding\n            similarity_top_k (int): top k most similar nodes\n\n        \"\"\"\n        query_filter_fn = _build_metadata_filter_fn(\n            lambda node_id: self._data.metadata_dict[node_id], query.filters\n        )\n\n        query_embedding = cast(list[float], ..."
  },
  {
    "name": "persist",
    "docstring": "Persist the SimpleVectorStore to a directory.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self",
      "persist_dir",
      "fs"
    ],
    "calls": [
      "logger.info",
      "faiss.write_index",
      "NotImplementedError",
      "os.path.exists",
      "os.makedirs",
      "np.array",
      "self._faiss_index.remove_ids",
      "logger.info",
      "self._data.vector_id_to_text_id.pop",
      "fs.open",
      "json.dump",
      "isinstance",
      "self._data.text_id_to_ref_doc_id.pop",
      "self._data.to_dict",
      "len",
      "self._data.metadata_dict.pop"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 220,
      "end_line": 259
    },
    "code_snippet": "def persist(\n        self,\n        persist_dir: str = DEFAULT_PERSIST_DIR,\n        fs: fsspec.AbstractFileSystem | None = None,\n    ) -> None:\n        \"\"\"Persist the SimpleVectorStore to a directory.\"\"\"\n        fs = fs or self._fs\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: write to a temporary file and then copy to the final destination\n        if fs and not isinstance(fs, LocalFileSystem):\n            raise NotImplementedError(\"FAISS..."
  },
  {
    "name": "from_persist_dir",
    "docstring": "Create a SimpleKVStore from a persist directory.",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "cls",
      "persist_dir",
      "fs"
    ],
    "calls": [
      "faiss.read_index",
      "logger.debug",
      "logger.info",
      "cls",
      "fsspec.filesystem",
      "fs.exists",
      "ValueError",
      "NotImplementedError",
      "fs.open",
      "json.load",
      "SimpleVectorStoreData.from_dict",
      "isinstance"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 262,
      "end_line": 285
    },
    "code_snippet": "def from_persist_dir(\n        cls, persist_dir: str, fs: fsspec.AbstractFileSystem | None = None\n    ) -> \"SimpleFaissVectorStore\":\n        \"\"\"Create a SimpleKVStore from a persist directory.\"\"\"\n\n        fs = fs or fsspec.filesystem(\"file\")\n        if not fs.exists(persist_dir):\n            raise ValueError(f\"No existing index store found at {persist_dir}.\")\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: copy to a temp file and load into ..."
  },
  {
    "name": "from_index",
    "docstring": "",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "cls",
      "faiss_index"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 288,
      "end_line": 289
    },
    "code_snippet": "def from_index(cls, faiss_index: Any):\n        return cls(faiss_index)"
  },
  {
    "name": "to_dict",
    "docstring": "",
    "is_method": true,
    "class_name": "SimpleFaissVectorStore",
    "parameters": [
      "self"
    ],
    "calls": [
      "self._data.to_dict"
    ],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 291,
      "end_line": 292
    },
    "code_snippet": "def to_dict(self) -> dict:\n        return self._data.to_dict()"
  },
  {
    "name": "span_ids",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeHit",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 41,
      "end_line": 42
    },
    "code_snippet": "def span_ids(self):\n        return [span.span_id for span in self.spans]"
  },
  {
    "name": "add_span",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeHit",
    "parameters": [
      "self",
      "span_id",
      "rank",
      "tokens"
    ],
    "calls": [
      "self.spans.append",
      "SpanHit"
    ],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 44,
      "end_line": 46
    },
    "code_snippet": "def add_span(self, span_id: str, rank: int = 0, tokens: int = 0):\n        if span_id not in [span.span_id for span in self.spans]:\n            self.spans.append(SpanHit(span_id=span_id, rank=rank, tokens=tokens))"
  },
  {
    "name": "contains_span",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeHit",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 48,
      "end_line": 49
    },
    "code_snippet": "def contains_span(self, span_id: str) -> bool:\n        return span_id in [span.span_id for span in self.spans]"
  },
  {
    "name": "add_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeHit",
    "parameters": [
      "self",
      "span_ids",
      "rank"
    ],
    "calls": [
      "self.add_span"
    ],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 51,
      "end_line": 53
    },
    "code_snippet": "def add_spans(self, span_ids: list[str], rank: int = 0):\n        for span_id in span_ids:\n            self.add_span(span_id, rank)"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeHit",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 55,
      "end_line": 56
    },
    "code_snippet": "def __str__(self):\n        return f\"{self.file_path}: {', '.join([span.span_id for span in self.spans])}\""
  },
  {
    "name": "sum_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchCodeResponse",
    "parameters": [
      "self"
    ],
    "calls": [
      "sum",
      "sum"
    ],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 69,
      "end_line": 70
    },
    "code_snippet": "def sum_tokens(self):\n        return sum([sum([span.tokens for span in hit.spans]) for hit in self.hits])"
  },
  {
    "name": "default_vector_store",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "settings"
    ],
    "calls": [
      "faiss.IndexIDMap",
      "SimpleFaissVectorStore",
      "faiss.IndexFlatL2",
      "ImportError"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 34,
      "end_line": 44
    },
    "code_snippet": "def default_vector_store(settings: IndexSettings):\n    try:\n        import faiss\n    except ImportError as e:\n        raise ImportError(\n            \"faiss needs to be installed to set up a default index for CodeIndex. Run 'pip install faiss-cpu'\"\n        ) from e\n\n    # faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(settings.dimensions))\n    faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(1024))\n    return SimpleFaissVectorStore(faiss_index)"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "file_repo",
      "index_name",
      "vector_store",
      "docstore",
      "embed_model",
      "blocks_by_class_name",
      "blocks_by_function_name",
      "settings",
      "max_results",
      "max_hits_without_exact_match",
      "max_exact_results"
    ],
    "calls": [
      "logger.info",
      "IndexSettings",
      "get_embed_model",
      "default_vector_store",
      "SimpleDocumentStore",
      "len",
      "len",
      "len"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 48,
      "end_line": 86
    },
    "code_snippet": "def __init__(\n        self,\n        file_repo: Repository,\n        index_name: Optional[str] = None,\n        vector_store: \"BasePydanticVectorStore | None\" = None,\n        docstore: \"DocumentStore | None\" = None,\n        embed_model: \"BaseEmbedding | None\" = None,\n        blocks_by_class_name: Optional[dict] = None,\n        blocks_by_function_name: Optional[dict] = None,\n        settings: IndexSettings | None = None,\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,..."
  },
  {
    "name": "from_persist_dir",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "cls",
      "persist_dir",
      "file_repo"
    ],
    "calls": [
      "SimpleFaissVectorStore.from_persist_dir",
      "SimpleDocumentStore.from_persist_dir",
      "IndexSettings.from_persist_dir",
      "os.path.exists",
      "os.path.exists",
      "cls",
      "os.path.join",
      "os.path.join",
      "open",
      "json.load",
      "open",
      "json.load",
      "os.path.join",
      "os.path.join"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 89,
      "end_line": 117
    },
    "code_snippet": "def from_persist_dir(cls, persist_dir: str, file_repo: Repository, **kwargs):\n        from moatless_qa.index.simple_faiss import SimpleFaissVectorStore\n        from llama_index.core.storage.docstore import SimpleDocumentStore\n        vector_store = SimpleFaissVectorStore.from_persist_dir(persist_dir)\n        docstore = SimpleDocumentStore.from_persist_dir(persist_dir)\n\n        settings = IndexSettings.from_persist_dir(persist_dir)\n\n        if os.path.exists(os.path.join(persist_dir, \"blocks_by_c..."
  },
  {
    "name": "from_url",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "cls",
      "url",
      "persist_dir",
      "file_repo"
    ],
    "calls": [
      "logger.info",
      "cls.from_persist_dir",
      "requests.get",
      "response.raise_for_status",
      "os.access",
      "os.path.join",
      "logger.warning",
      "os.makedirs",
      "tempfile.TemporaryDirectory",
      "os.path.join",
      "shutil.unpack_archive",
      "logger.exception",
      "logger.exception",
      "os.path.dirname",
      "os.path.basename",
      "open",
      "response.iter_content",
      "url.split",
      "data.write"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 120,
      "end_line": 148
    },
    "code_snippet": "def from_url(cls, url: str, persist_dir: str, file_repo: FileRepository):\n        try:\n            # 检查目标目录是否可写\n            if not os.access(os.path.dirname(persist_dir), os.W_OK):\n                alt_dir = os.path.join(\"/tmp\", os.path.basename(persist_dir))\n                logger.warning(f\"目标目录 {persist_dir} 不可写，尝试使用替代目录 {alt_dir}\")\n                persist_dir = alt_dir\n                os.makedirs(persist_dir, exist_ok=True)\n            \n            response = requests.get(url, stream=True)\n   ..."
  },
  {
    "name": "from_index_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "cls",
      "index_name",
      "file_repo",
      "index_store_dir"
    ],
    "calls": [
      "os.path.join",
      "os.path.exists",
      "os.getenv",
      "os.path.join",
      "logger.info",
      "cls.from_url",
      "os.getenv",
      "logger.info",
      "cls.from_persist_dir",
      "logger.info",
      "os.getenv"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 151,
      "end_line": 174
    },
    "code_snippet": "def from_index_name(\n        cls,\n        index_name: str,\n        file_repo: Repository,\n        index_store_dir: Optional[str] = None,\n    ):\n        if not index_store_dir:\n            index_store_dir = os.getenv(\"INDEX_STORE_DIR\")\n\n        persist_dir = os.path.join(index_store_dir, index_name)\n        if os.path.exists(persist_dir):\n            logger.info(f\"Loading existing index {index_name} from {persist_dir}.\")\n            return cls.from_persist_dir(persist_dir, file_repo=file_repo)\n  ..."
  },
  {
    "name": "from_repository",
    "docstring": "直接从Git仓库URL或本地仓库路径创建CodeIndex实例。\n\n参数:\n    repo_url: Git仓库URL\n    repo_path: 本地仓库路径\n    commit: Git提交哈希\n    index_name: 索引名称（如果为None，将从仓库路径/URL派生）\n    index_store_dir: 索引存储目录\n    repo_base_dir: 仓库基础目录\n    force_rebuild: 是否强制重建索引\n\n返回:\n    CodeIndex: 代码索引对象",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "cls",
      "repo_url",
      "repo_path",
      "commit",
      "index_name",
      "index_store_dir",
      "file_repo",
      "force_rebuild"
    ],
    "calls": [
      "create_index",
      "ValueError",
      "os.getenv",
      "os.path.basename",
      "repo_name.endswith",
      "repo_url.split"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 177,
      "end_line": 237
    },
    "code_snippet": "def from_repository(\n        cls,\n        repo_url: Optional[str] = None,\n        repo_path: Optional[str] = None,\n        commit: Optional[str] = None,\n        index_name: Optional[str] = None,\n        index_store_dir: Optional[str] = None,\n        file_repo: Optional[Repository] = None,\n        force_rebuild: bool = False,\n    ):\n        \"\"\"\n        直接从Git仓库URL或本地仓库路径创建CodeIndex实例。\n        \n        参数:\n            repo_url: Git仓库URL\n            repo_path: 本地仓库路径\n            commit: Git提交哈希\n   ..."
  },
  {
    "name": "dict",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 239,
      "end_line": 240
    },
    "code_snippet": "def dict(self):\n        return {\"index_name\": self._index_name}"
  },
  {
    "name": "semantic_search",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "query",
      "code_snippet",
      "file_pattern",
      "category",
      "max_results",
      "max_tokens",
      "max_hits_without_exact_match",
      "max_exact_results",
      "max_spans_per_file",
      "exact_match_if_possible"
    ],
    "calls": [
      "self._vector_search",
      "enumerate",
      "sum",
      "SearchCodeResponse",
      "self._file_repo.get_file",
      "logger.info",
      "logger.info",
      "self._file_repo.matching_files",
      "self._file_repo.matching_files",
      "logger.warning",
      "file.module.find_span_by_id",
      "len",
      "list",
      "SearchCodeResponse",
      "SearchCodeResponse",
      "SearchCodeResponse",
      "logger.warning",
      "spans.append",
      "logger.debug",
      "file.module.find_spans_by_line_numbers",
      "span.initiating_block.has_content",
      "contains_span",
      "logger.debug",
      "add_span",
      "files_with_spans.values",
      "files_with_spans.values",
      "self._file_repo.file_exists",
      "spans.append",
      "span.initiating_block.has_content",
      "SearchCodeHit",
      "len",
      "len",
      "files_with_spans.values"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 242,
      "end_line": 414
    },
    "code_snippet": "def semantic_search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        file_pattern: Optional[str] = None,\n        category: str | None = None,\n        max_results: int = 100,\n        max_tokens: int = 8000,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n        max_spans_per_file: Optional[int] = None,\n        exact_match_if_possible: bool = False,\n    ) -> SearchCodeResponse:\n        if query is None:\n  ..."
  },
  {
    "name": "find_class",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "class_name",
      "file_pattern"
    ],
    "calls": [
      "self.find_by_name"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 416,
      "end_line": 419
    },
    "code_snippet": "def find_class(self, class_name: str, file_pattern: Optional[str] = None):\n        return self.find_by_name(\n            class_name=class_name, file_pattern=file_pattern, strict=True\n        )"
  },
  {
    "name": "find_function",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "function_name",
      "class_name",
      "file_pattern"
    ],
    "calls": [
      "self.find_by_name"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 421,
      "end_line": 432
    },
    "code_snippet": "def find_function(\n        self,\n        function_name: str,\n        class_name: Optional[str] = None,\n        file_pattern: Optional[str] = None,\n    ):\n        return self.find_by_name(\n            function_name=function_name,\n            class_name=class_name,\n            file_pattern=file_pattern,\n            strict=True,\n        )"
  },
  {
    "name": "find_by_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "class_name",
      "function_name",
      "file_pattern",
      "include_functions_in_class",
      "strict",
      "category"
    ],
    "calls": [
      "logger.info",
      "enumerate",
      "SearchCodeResponse",
      "ValueError",
      "self._blocks_by_class_name.get",
      "self._file_repo.matching_files",
      "self._file_repo.matching_files",
      "self._file_repo.get_file",
      "file.module.find_by_path",
      "logger.debug",
      "logger.debug",
      "_rerank_files",
      "search_hits.append",
      "self._blocks_by_function_name.get",
      "ValueError",
      "SearchCodeResponse",
      "SearchCodeResponse",
      "len",
      "len",
      "logger.debug",
      "logger.warning",
      "blocks.append",
      "files_with_spans.values",
      "len",
      "len",
      "logger.debug",
      "SearchCodeResponse",
      "SearchCodeResponse",
      "len",
      "filtered_paths.append",
      "logger.warning",
      "found_block.find_by_identifier",
      "SearchCodeHit",
      "add_span",
      "len",
      "filtered_paths.append",
      "self._file_repo.file_exists",
      "blocks.append",
      "blocks.append",
      "len"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 434,
      "end_line": 614
    },
    "code_snippet": "def find_by_name(\n        self,\n        class_name: str = None,\n        function_name: str = None,\n        file_pattern: Optional[str] = None,\n        include_functions_in_class: bool = True,\n        strict: bool = False,\n        category: str | None = None,\n    ) -> SearchCodeResponse:\n        if not class_name and not function_name:\n            raise ValueError(\n                \"At least one of class_name or function_name must be provided.\"\n            )\n\n        paths = []\n\n        # If class..."
  },
  {
    "name": "find_test_files",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "file_path",
      "span_id",
      "query",
      "max_results",
      "max_tokens",
      "max_method_tokens",
      "max_spans"
    ],
    "calls": [
      "self._vector_search",
      "self._find_by_test_pattern",
      "files.append",
      "next",
      "self._file_repo.get_file",
      "any",
      "FileWithSpans",
      "self.find_test_files",
      "FileWithSpans",
      "files.append",
      "logger.warning",
      "file.module.find_span_by_id",
      "file_with_spans.span_ids.append",
      "len",
      "len",
      "len",
      "span_id.lower",
      "span_id.lower",
      "len",
      "len"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 616,
      "end_line": 691
    },
    "code_snippet": "def find_test_files(\n        self,\n        file_path: str,\n        span_id: str | None = None,\n        query: str | None = None,\n        max_results: int = 5,\n        max_tokens: int | None = None,\n        max_method_tokens: int = 500,\n        max_spans: int | None = None,\n    ) -> list[FileWithSpans]:\n        if span_id:\n            query = f\"{file_path} {span_id}\"\n        elif query:\n            query = f\"{file_path} {query}\"\n        else:\n            query = file_path\n\n        search_results ..."
  },
  {
    "name": "_find_by_test_pattern",
    "docstring": "Find the test file related to the provided file path.\n\nTest files should match the pattern \"test_[filename].py\" or \"[filename]_test.py\".\nIf there are multiple matches, the one with the most similar directory path is picked.",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "os.path.basename",
      "os.path.dirname",
      "self._file_repo.find_by_pattern",
      "float",
      "len",
      "os.path.dirname",
      "os.path.commonprefix",
      "len",
      "len"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 693,
      "end_line": 722
    },
    "code_snippet": "def _find_by_test_pattern(self, file_path: str) -> str | None:\n        \"\"\"\n        Find the test file related to the provided file path.\n\n        Test files should match the pattern \"test_[filename].py\" or \"[filename]_test.py\".\n        If there are multiple matches, the one with the most similar directory path is picked.\n        \"\"\"\n        filename = os.path.basename(file_path)\n        dirname = os.path.dirname(file_path)\n        test_patterns = [f\"test_{filename}\", f\"{filename}_test.py\"]\n\n    ..."
  },
  {
    "name": "_create_search_hit",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "file",
      "rank"
    ],
    "calls": [
      "SearchCodeHit",
      "file_hit.add_span"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 724,
      "end_line": 728
    },
    "code_snippet": "def _create_search_hit(self, file: FileWithSpans, rank: int = 0):\n        file_hit = SearchCodeHit(file_path=file.file_path)\n        for span_id in file.span_ids:\n            file_hit.add_span(span_id, rank)\n        return file_hit"
  },
  {
    "name": "_vector_search",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "query",
      "exact_query_match",
      "category",
      "file_pattern",
      "exact_content_match",
      "top_k"
    ],
    "calls": [
      "logger.debug",
      "self._embed_model.get_query_embedding",
      "VectorStoreQuery",
      "self._vector_store.query",
      "zip",
      "logger.debug",
      "ValueError",
      "self._file_repo.matching_files",
      "self._file_repo.find_files",
      "set",
      "self._docstore.get_document",
      "is_test",
      "CodeSnippet",
      "search_results.append",
      "len",
      "logger.info",
      "node_doc.get_content",
      "is_string_in",
      "node_doc.get_content",
      "node_doc.metadata.get",
      "node_doc.metadata.get",
      "node_doc.metadata.get",
      "len",
      "len",
      "node_doc.get_content"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 730,
      "end_line": 861
    },
    "code_snippet": "def _vector_search(\n        self,\n        query: str = \"\",\n        exact_query_match: bool = False,\n        category: str | None = None,\n        file_pattern: Optional[str] = None,\n        exact_content_match: Optional[str] = None,\n        top_k: int = 500,\n    ):\n        # Import llama_index components only when needed\n        from llama_index.core.vector_stores.types import VectorStoreQuery\n\n        if file_pattern:\n            query += f\" file:{file_pattern}\"\n\n        if exact_content_match:\n..."
  },
  {
    "name": "run_ingestion",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "repo_path",
      "input_files",
      "num_workers"
    ],
    "calls": [
      "IngestionPipeline",
      "reader.load_data",
      "print",
      "logger.info",
      "EpicSplitter",
      "splitter.get_nodes_from_documents",
      "sum",
      "logger.info",
      "embed_pipeline.run",
      "sum",
      "logger.info",
      "file_path.replace",
      "file_path.startswith",
      "SimpleDirectoryReader",
      "len",
      "len",
      "is_test",
      "os.path.basename",
      "os.path.join",
      "logger.exception",
      "append",
      "append",
      "count_tokens",
      "list",
      "count_tokens",
      "mimetypes.guess_type",
      "len",
      "node.get_content",
      "len",
      "node.get_content",
      "len",
      "file.startswith",
      "codeblock.full_path",
      "codeblock.full_path"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 863,
      "end_line": 988
    },
    "code_snippet": "def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        # Import llama_index components only when needed\n        from llama_index.core import SimpleDirectoryReader\n        from llama_index.core.ingestion import DocstoreStrategy, IngestionPipeline\n\n        repo_path = repo_path or self._file_repo.path\n\n        # Only extract file name and type to not trigger unnecessary embedd..."
  },
  {
    "name": "persist",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeIndex",
    "parameters": [
      "self",
      "persist_dir"
    ],
    "calls": [
      "self._vector_store.persist",
      "self._docstore.persist",
      "self._settings.persist",
      "os.path.join",
      "open",
      "f.write",
      "open",
      "f.write",
      "os.path.join",
      "json.dumps",
      "os.path.join",
      "json.dumps"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 990,
      "end_line": 1002
    },
    "code_snippet": "def persist(self, persist_dir: str):\n        self._vector_store.persist(persist_dir)\n        self._docstore.persist(\n            # os.path.join(persist_dir, self._docstore.types.DEFAULT_PERSIST_FNAME)\n            os.path.join(persist_dir, \"docstore.json\")\n        )\n        self._settings.persist(persist_dir)\n\n        with open(os.path.join(persist_dir, \"blocks_by_class_name.json\"), \"w\") as f:\n            f.write(json.dumps(self._blocks_by_class_name, indent=2))\n\n        with open(os.path.join(pe..."
  },
  {
    "name": "_rerank_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "file_paths",
      "file_pattern"
    ],
    "calls": [
      "split",
      "join",
      "scored_files.sort",
      "logger.info",
      "len",
      "file_path.replace",
      "fuzz.partial_ratio",
      "scored_files.append",
      "replace",
      "part.strip",
      "len",
      "file_pattern.replace"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 1005,
      "end_line": 1027
    },
    "code_snippet": "def _rerank_files(file_paths: list[str], file_pattern: str):\n    if len(file_paths) < 2:\n        return file_paths\n\n    tokenized_query = file_pattern.replace(\".py\", \"\").replace(\"*\", \"\").split(\"/\")\n    tokenized_query = [part for part in tokenized_query if part.strip()]\n    query = \"/\".join(tokenized_query)\n\n    scored_files = []\n    for file_path in file_paths:\n        cleaned_file_path = file_path.replace(\".py\", \"\")\n        score = fuzz.partial_ratio(cleaned_file_path, query)\n        scored_fi..."
  },
  {
    "name": "is_string_in",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "s1",
      "s2"
    ],
    "calls": [
      "replace",
      "replace",
      "replace",
      "replace",
      "s1.replace",
      "s2.replace"
    ],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 1030,
      "end_line": 1034
    },
    "code_snippet": "def is_string_in(s1, s2):\n    s1_clean = s1.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    s2_clean = s2.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    found_in = s1_clean in s2_clean\n    return found_in"
  },
  {
    "name": "get_embed_model",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "model_name"
    ],
    "calls": [
      "VoyageEmbeddingWithRetry",
      "ValueError",
      "ImportError",
      "os.environ.get"
    ],
    "code_location": {
      "file": "embed_model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 40,
      "end_line": 58
    },
    "code_snippet": "def get_embed_model(model_name: str) -> \"BaseEmbedding\":\n\n    try:\n        from llama_index.embeddings.voyageai import VoyageEmbedding\n    except ImportError as e:\n        raise ImportError(\n            \"llama-index-embeddings-voyageai is not installed. Please install it using `pip install llama-index-embeddings-voyageai`\"\n        ) from e\n\n    if \"VOYAGE_API_KEY\" not in os.environ:\n        raise ValueError(\n            \"VOYAGE_API_KEY environment variable is not set. Please set it to your Voyag..."
  },
  {
    "name": "to_serializable_dict",
    "docstring": "",
    "is_method": true,
    "class_name": "IndexSettings",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.dict"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 39,
      "end_line": 42
    },
    "code_snippet": "def to_serializable_dict(self):\n        data = self.dict()\n        data[\"comment_strategy\"] = data[\"comment_strategy\"].value\n        return data"
  },
  {
    "name": "persist",
    "docstring": "",
    "is_method": true,
    "class_name": "IndexSettings",
    "parameters": [
      "self",
      "persist_dir"
    ],
    "calls": [
      "open",
      "json.dump",
      "os.path.join",
      "self.to_serializable_dict"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 44,
      "end_line": 46
    },
    "code_snippet": "def persist(self, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\"), \"w\") as f:\n            json.dump(self.to_serializable_dict(), f, indent=4)"
  },
  {
    "name": "from_persist_dir",
    "docstring": "",
    "is_method": true,
    "class_name": "IndexSettings",
    "parameters": [
      "cls",
      "persist_dir"
    ],
    "calls": [
      "cls",
      "open",
      "json.load",
      "os.path.join"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 49,
      "end_line": 52
    },
    "code_snippet": "def from_persist_dir(cls, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\")) as f:\n            data = json.load(f)\n        return cls(**data)"
  },
  {
    "name": "count_chunk_tokens",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "chunk"
    ],
    "calls": [
      "sum"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 21,
      "end_line": 22
    },
    "code_snippet": "def count_chunk_tokens(chunk: CodeBlockChunk) -> int:\n    return sum([block.tokens for block in chunk])"
  },
  {
    "name": "count_parent_tokens",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "codeblock"
    ],
    "calls": [],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 25,
      "end_line": 29
    },
    "code_snippet": "def count_parent_tokens(codeblock: CodeBlock) -> int:\n    tokens = codeblock.tokens\n    if codeblock.parent:\n        tokens += codeblock.parent.tokens\n    return tokens"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "language",
      "chunk_size",
      "min_chunk_size",
      "max_chunk_size",
      "hard_token_limit",
      "max_chunks",
      "include_metadata",
      "include_prev_next_rel",
      "text_splitter",
      "index_callback",
      "repo_path",
      "comment_strategy",
      "min_lines_to_parse_block",
      "include_non_code_files",
      "tokenizer",
      "non_code_file_extensions",
      "callback_manager"
    ],
    "calls": [
      "create_parser",
      "__init__",
      "CallbackManager",
      "super",
      "TokenTextSplitter"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 88,
      "end_line": 139
    },
    "code_snippet": "def __init__(\n        self,\n        language: str = \"python\",\n        chunk_size: int = 750,\n        min_chunk_size: int = 100,\n        max_chunk_size: int = 1500,\n        hard_token_limit: int = 6000,\n        max_chunks: int = 100,\n        include_metadata: bool = True,\n        include_prev_next_rel: bool = True,\n        text_splitter: TextSplitter | None = None,\n        index_callback: Optional[Callable[[CodeBlock], None]] = None,\n        repo_path: Optional[str] = None,\n        comment_strate..."
  },
  {
    "name": "class_name",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 142,
      "end_line": 143
    },
    "code_snippet": "def class_name(cls):\n        return \"GhostcoderNodeParser\""
  },
  {
    "name": "_parse_nodes",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "nodes",
      "show_progress"
    ],
    "calls": [
      "get_tqdm_iterable",
      "node.metadata.get",
      "time.time_ns",
      "self._chunk_contents",
      "time.time_ns",
      "time.time_ns",
      "self._parser.parse",
      "time.time_ns",
      "logger.warning",
      "len",
      "logger.info",
      "self._create_path_tree",
      "self._to_context_string",
      "self._create_node",
      "time.time_ns",
      "logger.warning",
      "time.time_ns",
      "logger.warning",
      "logger.warning",
      "all_nodes.append",
      "len"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 145,
      "end_line": 199
    },
    "code_snippet": "def _parse_nodes(\n        self,\n        nodes: Sequence[BaseNode],\n        show_progress: bool = False,\n        **kwargs: Any,\n    ) -> list[BaseNode]:\n        nodes_with_progress = get_tqdm_iterable(nodes, show_progress, \"Parsing nodes\")\n\n        all_nodes: list[BaseNode] = []\n\n        for node in nodes_with_progress:\n            file_path = node.metadata.get(\"file_path\")\n            content = node.text\n            try:\n                starttime = time.time_ns()\n\n                # TODO: Derive ..."
  },
  {
    "name": "_chunk_contents",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "codeblock",
      "file_path"
    ],
    "calls": [
      "codeblock.sum_tokens",
      "self._chunk_block",
      "logger.debug",
      "codeblock.get_all_child_blocks",
      "logger.info",
      "child.content.lower"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 201,
      "end_line": 227
    },
    "code_snippet": "def _chunk_contents(\n        self, codeblock: CodeBlock | None = None, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        tokens = codeblock.sum_tokens()\n        if tokens == 0:\n            logger.debug(f\"Skipping file {file_path} because it has no tokens.\")\n            return []\n\n        if tokens > self.hard_token_limit:\n            for child in codeblock.children:\n                if (\n                    child.type == CodeBlockType.COMMENT\n                    and \"generate..."
  },
  {
    "name": "_chunk_block",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "codeblock",
      "file_path"
    ],
    "calls": [
      "count_parent_tokens",
      "self._merge_chunks",
      "child.get_all_child_blocks",
      "current_chunk.extend",
      "extend",
      "chunks.append",
      "current_chunk.extend",
      "current_chunk.append",
      "self._chunk_block",
      "child.sum_tokens",
      "current_chunk.extend",
      "current_chunk.append",
      "count_chunk_tokens",
      "chunks.append",
      "count_chunk_tokens",
      "current_chunk.extend",
      "chunks.append",
      "self._ignore_comment",
      "child.sum_tokens",
      "child.sum_tokens",
      "current_chunk.extend",
      "chunks.append",
      "chunks.extend",
      "chunks.append",
      "chunks.extend",
      "comment_chunk.append",
      "count_chunk_tokens"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 229,
      "end_line": 315
    },
    "code_snippet": "def _chunk_block(\n        self, codeblock: CodeBlock, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        chunks: list[CodeBlockChunk] = []\n        current_chunk = []\n        comment_chunk = []\n\n        parent_tokens = count_parent_tokens(codeblock)\n\n        ignoring_comment = False\n\n        for child in codeblock.children:\n            if child.type == CodeBlockType.COMMENT:\n                if self.comment_strategy == CommentStrategy.EXCLUDE:\n                    continue\n     ..."
  },
  {
    "name": "_merge_chunks",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "chunks"
    ],
    "calls": [
      "enumerate",
      "merged_chunks.append",
      "len",
      "count_chunk_tokens",
      "len",
      "len",
      "merged_chunks.append",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "len",
      "merged_chunks.append",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "merged_chunks.append",
      "merged_chunks.append",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "count_chunk_tokens",
      "count_chunk_tokens"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 317,
      "end_line": 381
    },
    "code_snippet": "def _merge_chunks(self, chunks: list[CodeBlockChunk]) -> list[CodeBlockChunk]:\n        while True:\n            merged_chunks = []\n            should_continue = False\n\n            for i, chunk in enumerate(chunks):\n                if (\n                    count_chunk_tokens(chunk) < self.min_chunk_size\n                    or len(chunks) > self.max_chunks\n                ):\n                    if i == 0 and len(chunks) > 1:\n                        if (\n                            count_chunk_token..."
  },
  {
    "name": "_create_path_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "blocks"
    ],
    "calls": [
      "PathTree",
      "path_tree.add_to_tree",
      "block.full_path"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 383,
      "end_line": 387
    },
    "code_snippet": "def _create_path_tree(self, blocks: list[CodeBlock]) -> PathTree:\n        path_tree = PathTree()\n        for block in blocks:\n            path_tree.add_to_tree(block.full_path())\n        return path_tree"
  },
  {
    "name": "_ignore_comment",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "codeblock"
    ],
    "calls": [
      "re.search"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 389,
      "end_line": 393
    },
    "code_snippet": "def _ignore_comment(self, codeblock: CodeBlock) -> bool:\n        return (\n            re.search(r\"(?i)copyright|license|author\", codeblock.content)\n            or not codeblock.content\n        )"
  },
  {
    "name": "_to_context_string",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "codeblock",
      "path_tree"
    ],
    "calls": [
      "enumerate",
      "enumerate",
      "path_tree.child_tree",
      "to_string",
      "self._to_context_string",
      "to_string",
      "self._to_context_string",
      "child.create_commented_out_block",
      "child.create_commented_out_block"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 395,
      "end_line": 453
    },
    "code_snippet": "def _to_context_string(self, codeblock: CodeBlock, path_tree: PathTree) -> str:\n        contents = \"\"\n\n        if codeblock.pre_lines:\n            contents += \"\\n\" * (codeblock.pre_lines - 1)\n            for i, line in enumerate(codeblock.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + codeblock.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        els..."
  },
  {
    "name": "_contains_block_paths",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "codeblock",
      "block_paths"
    ],
    "calls": [
      "codeblock.full_path",
      "len",
      "codeblock.full_path"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 455,
      "end_line": 460
    },
    "code_snippet": "def _contains_block_paths(self, codeblock: CodeBlock, block_paths: list[list[str]]):\n        return [\n            block_path\n            for block_path in block_paths\n            if block_path[: len(codeblock.full_path())] == codeblock.full_path()\n        ]"
  },
  {
    "name": "_create_node",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "content",
      "node",
      "chunk"
    ],
    "calls": [
      "metadata.update",
      "content.strip",
      "count_chunk_tokens",
      "node.excluded_embed_metadata_keys.copy",
      "excluded_embed_metadata_keys.extend",
      "CodeNode",
      "set",
      "list",
      "logger.debug",
      "sorted",
      "path_string",
      "path_string"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 462,
      "end_line": 513
    },
    "code_snippet": "def _create_node(\n        self, content: str, node: BaseNode, chunk: CodeBlockChunk | None = None\n    ) -> TextNode | None:\n        metadata = {}\n        metadata.update(node.metadata)\n\n        node_id = node.id_\n\n        if chunk:\n            metadata[\"start_line\"] = chunk[0].start_line\n            metadata[\"end_line\"] = chunk[-1].end_line\n\n            # TODO: Change this when EpicSplitter is adjusted to use the span concept natively\n            span_ids = set(\n                [\n               ..."
  },
  {
    "name": "_count_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "EpicSplitter",
    "parameters": [
      "self",
      "text"
    ],
    "calls": [
      "get_tokenizer",
      "len",
      "tokenizer"
    ],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 515,
      "end_line": 517
    },
    "code_snippet": "def _count_tokens(self, text: str):\n        tokenizer = get_tokenizer()\n        return len(tokenizer(text))"
  },
  {
    "name": "hash",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeNode",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.metadata.copy",
      "metadata.pop",
      "metadata.pop",
      "metadata.pop",
      "self._clean_text",
      "str",
      "str",
      "hexdigest",
      "sha256",
      "doc_identity.encode"
    ],
    "code_location": {
      "file": "code_node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 9,
      "end_line": 16
    },
    "code_snippet": "def hash(self):\n        metadata = self.metadata.copy()\n        metadata.pop(\"start_line\", None)\n        metadata.pop(\"end_line\", None)\n        metadata.pop(\"tokens\", None)\n        cleaned_text = self._clean_text(self.text)\n        doc_identity = cleaned_text + str(metadata)\n        return str(sha256(doc_identity.encode(\"utf-8\", \"surrogatepass\")).hexdigest())"
  },
  {
    "name": "_clean_text",
    "docstring": "Remove all whitespace and convert to lowercase to reduce the number of changes in hashes.",
    "is_method": true,
    "class_name": "CodeNode",
    "parameters": [
      "self",
      "text"
    ],
    "calls": [
      "lower",
      "join",
      "text.split"
    ],
    "code_location": {
      "file": "code_node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 18,
      "end_line": 22
    },
    "code_snippet": "def _clean_text(self, text):\n        \"\"\"\n        Remove all whitespace and convert to lowercase to reduce the number of changes in hashes.\n        \"\"\"\n        return \"\".join(text.split()).lower()"
  },
  {
    "name": "_get_embedding",
    "docstring": "",
    "is_method": true,
    "class_name": "VoyageEmbeddingWithRetry",
    "parameters": [
      "self",
      "texts",
      "input_type"
    ],
    "calls": [
      "retry",
      "wait_random_exponential",
      "stop_after_attempt",
      "self._client.embed",
      "str",
      "logger.info",
      "self._get_embedding",
      "self._get_embedding",
      "len",
      "len",
      "len",
      "len",
      "len"
    ],
    "code_location": {
      "file": "retry_voyage_embedding.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 15,
      "end_line": 40
    },
    "code_snippet": "def _get_embedding(self, texts: List[str], input_type: str) -> List[List[float]]:\n        try:\n            return self._client.embed(\n                texts,\n                model=self.model_name,\n                input_type=input_type,\n                truncation=self.truncation,\n            ).embeddings\n        except InvalidRequestError as e:\n            if \"Please lower the number of tokens in the batch\" in str(e):\n                if len(texts) < 10:\n                    raise  # If batch size i..."
  },
  {
    "name": "validate_snippet",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCodeSnippetArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "self.code_snippet.strip",
      "ValueError"
    ],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 38,
      "end_line": 41
    },
    "code_snippet": "def validate_snippet(self) -> \"FindCodeSnippetArgs\":\n        if not self.code_snippet.strip():\n            raise ValueError(\"code_snippet cannot be empty\")\n        return self"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCodeSnippetArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 43,
      "end_line": 47
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Searching for code snippet: {self.code_snippet}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCodeSnippetArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 49,
      "end_line": 53
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"code_snippet={self.code_snippet}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "_search_for_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCodeSnippet",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "logger.info",
      "self._repository.find_exact_matches",
      "FileContext",
      "len",
      "search_result_context.add_line_span_to_context",
      "len",
      "args.code_snippet.splitlines",
      "fnmatch"
    ],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 64,
      "end_line": 91
    },
    "code_snippet": "def _search_for_context(\n        self, args: FindCodeSnippetArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.code_snippet} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.code_snippet, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_path, ..."
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCodeSnippet",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FewShotExample.create",
      "FindCodeSnippetArgs",
      "FindCodeSnippetArgs",
      "FindCodeSnippetArgs"
    ],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 94,
      "end_line": 119
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"I need to understand how the User class is structured in our authentication system. Let me find its definition.\",\n                action=FindCodeSnippetArgs(\n                    thoughts=\"To find the User class definition, I'll search for the exact class declaration line 'class User(BaseModel):'\",\n                    code_snippet=\"class User(BaseModel):\",\n      ..."
  },
  {
    "name": "validate_names",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClassArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "self.class_name.strip",
      "ValueError",
      "logger.info",
      "self.class_name.split"
    ],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 29,
      "end_line": 39
    },
    "code_snippet": "def validate_names(self) -> \"FindClassArgs\":\n        if not self.class_name.strip():\n            raise ValueError(\"class_name cannot be empty\")\n        # Extract just the class name if a fully qualified name is provided\n        if \".\" in self.class_name:\n            original_name = self.class_name\n            self.class_name = self.class_name.split(\".\")[-1]\n            logger.info(\n                f\"Using class name '{self.class_name}' from fully qualified name '{original_name}'\"\n            )\n ..."
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClassArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 44,
      "end_line": 48
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"class_name={self.class_name}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 54,
      "end_line": 58
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Searching for class: {self.args.class_name}\"\n        if self.args.file_pattern:\n            prompt += f\" in files matching the pattern: {self.args.file_pattern}\"\n        return prompt"
  },
  {
    "name": "_search",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "logger.info",
      "self._code_index.find_class"
    ],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 60,
      "end_line": 66
    },
    "code_snippet": "def _search(self, args: FindClassArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.class_name} (file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_class(\n            args.class_name, file_pattern=args.file_pattern\n        )"
  },
  {
    "name": "_select_span_instructions",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "self",
      "search_result"
    ],
    "calls": [],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 68,
      "end_line": 72
    },
    "code_snippet": "def _select_span_instructions(self, search_result: SearchCodeResponse) -> str:\n        return (\n            f\"Here's the class structure.\"\n            f\"Use the function ViewCode and specify the SpanIDs of the relevant functions to view them.\\n\"\n        )"
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "SearchCodeResponse",
      "self._code_index.find_class"
    ],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 74,
      "end_line": 79
    },
    "code_snippet": "def _search_for_alternative_suggestion(\n        self, args: FindClassArgs\n    ) -> SearchCodeResponse:\n        if args.file_pattern:\n            return self._code_index.find_class(args.class_name, file_pattern=None)\n        return SearchCodeResponse()"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "get_evaluation_criteria",
      "criteria.extend",
      "super"
    ],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 82,
      "end_line": 89
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Identifier Correctness: Verify that the class name is accurate.\",\n            ]\n        )\n        return criteria"
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "FindClass",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FindClassArgs",
      "FindClassArgs"
    ],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 92,
      "end_line": 109
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"I need to see the implementation of the DatabaseManager class to understand how it handles transactions\",\n                action=FindClassArgs(\n                    thoughts=\"To examine how the DatabaseManager class handles transactions, we need to locate its implementation in the codebase.\",\n                    class_name=\"DatabaseManager\",\n                ),\n  ..."
  },
  {
    "name": "validate_file_pattern",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseArgs",
    "parameters": [
      "cls",
      "v"
    ],
    "calls": [
      "field_validator",
      "ValueError"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 55,
      "end_line": 59
    },
    "code_snippet": "def validate_file_pattern(cls, v):\n        if v:\n            if \",\" in v:\n                raise ValueError(\"File pattern cannot contain commas\")\n        return v"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "repository",
      "code_index",
      "completion_model"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 115,
      "end_line": 124
    },
    "code_snippet": "def __init__(\n        self,\n        repository: Repository = None,\n        code_index: CodeIndex | None = None,\n        completion_model: CompletionModel = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n        self._code_index = code_index"
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "self._search_for_context",
      "search_result_context.is_empty",
      "search_result_context.context_size",
      "search_result_context.model_dump",
      "search_result_context.span_count",
      "file_context.add_file_context",
      "view_context.is_empty",
      "logger.info",
      "Observation",
      "ValueError",
      "Observation",
      "logger.warning",
      "Observation",
      "view_context.create_prompt",
      "search_result_context.span_count",
      "search_result_context.context_size",
      "logger.info",
      "self._identify_code",
      "view_context.has_file",
      "set_patch",
      "search_result_context.span_count",
      "view_context.span_count",
      "search_result_context.create_summary",
      "search_result_context.context_size",
      "search_result_context.context_size",
      "search_result_context.span_count",
      "view_context.get_file",
      "view_context.create_summary",
      "view_context.create_summary",
      "search_result_context.span_count"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 126,
      "end_line": 216
    },
    "code_snippet": "def execute(\n        self,\n        args: SearchBaseArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the search action.\"\n            )\n\n        properties = {\"search_hits\": [], \"search_tokens\": 0}\n\n        search_result_context, alternative_suggestion = self._search_for_context(args)\n\n        if search_result_context.is_empty():\n            propertie..."
  },
  {
    "name": "_search_for_context",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "self._search",
      "FileContext",
      "self._search_for_alternative_suggestion",
      "logger.info",
      "len",
      "search_result_context.add_span_to_context"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 218,
      "end_line": 237
    },
    "code_snippet": "def _search_for_context(self, args: SearchBaseArgs) -> Tuple[FileContext, bool]:\n        alternative_suggestion = False\n        search_result = self._search(args)\n        if not search_result.hits:\n            search_result = self._search_for_alternative_suggestion(args)\n            alternative_suggestion = True\n            logger.info(\n                f\"{self.name}: No relevant search results found. Will use alternative suggestion with {search_result.hits} hits.\"\n            )\n\n        span_cou..."
  },
  {
    "name": "_select_span_instructions",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "search_result"
    ],
    "calls": [],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 239,
      "end_line": 243
    },
    "code_snippet": "def _select_span_instructions(self, search_result: SearchCodeResponse) -> str:\n        if not self.add_to_context:\n            return f\"Here's the search result with the first line of codes in each code block. Use ViewCode to view specific code sections. \"\n\n        return f\"The search result is too large. You must identify the relevant code sections in the search results to use them. \""
  },
  {
    "name": "_select_span_response_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "search_result"
    ],
    "calls": [
      "FileContext",
      "search_result_context.create_prompt",
      "self._select_span_instructions",
      "search_result_context.add_span_to_context"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 245,
      "end_line": 264
    },
    "code_snippet": "def _select_span_response_prompt(self, search_result: SearchCodeResponse) -> str:\n        search_result_context = FileContext(repo=self._repository)\n        for hit in search_result.hits:\n            for span in hit.spans:\n                search_result_context.add_span_to_context(\n                    hit.file_path, span.span_id, add_extra=False\n                )\n\n        search_result_str = search_result_context.create_prompt(\n            show_span_ids=False,\n            show_line_numbers=True,\n..."
  },
  {
    "name": "_search",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "NotImplementedError"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 266,
      "end_line": 267
    },
    "code_snippet": "def _search(self, args: SearchBaseArgs) -> SearchCodeResponse:\n        raise NotImplementedError(\"Subclasses must implement this method.\")"
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "SearchCodeResponse"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 269,
      "end_line": 272
    },
    "code_snippet": "def _search_for_alternative_suggestion(\n        self, args: SearchBaseArgs\n    ) -> SearchCodeResponse:\n        return SearchCodeResponse()"
  },
  {
    "name": "_identify_code",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "self",
      "args",
      "search_result_ctx"
    ],
    "calls": [
      "search_result_ctx.create_prompt",
      "ChatCompletionUserMessage",
      "range",
      "CompletionRejectError",
      "self.completion_model.create_completion",
      "logger.info",
      "FileContext",
      "view_context.context_size",
      "args.to_prompt",
      "logger.warning",
      "logger.info",
      "messages.append",
      "messages.append",
      "logger.info",
      "ChatCompletionAssistantMessage",
      "ChatCompletionUserMessage",
      "len",
      "view_context.add_line_span_to_context",
      "identified_code.model_dump_json"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 274,
      "end_line": 352
    },
    "code_snippet": "def _identify_code(\n        self, args: SearchBaseArgs, search_result_ctx: FileContext\n    ) -> Tuple[IdentifiedSpans, Completion]:\n        search_result_str = search_result_ctx.create_prompt(\n            show_span_ids=True,\n            show_line_numbers=True,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"...\",\n            max_tokens=self.max_identify_prompt_tokens,\n        )\n\n        content = \"Search request:\"\n        content ..."
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "get_evaluation_criteria",
      "evaluation_criteria.extend",
      "super"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 355,
      "end_line": 366
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        evaluation_criteria = super().get_evaluation_criteria(trajectory_length)\n        evaluation_criteria.extend(\n            [\n                \"Query Relevance: Evaluate if the search query or parameters are well-defined and likely to find relevant code.\",\n                \"Search Scope Appropriateness: Check if the file patterns and class/function names narrow down the search effectively.\",\n                \"Relevance of Search..."
  },
  {
    "name": "get_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "cls.generate_reward_scale_entries",
      "cls.generate_reward_scale_entries"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 369,
      "end_line": 429
    },
    "code_snippet": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        if trajectory_length <= 3:\n            return cls.generate_reward_scale_entries(\n                [\n                    (\n                        90,\n                        100,\n                        \"The search action is excellent, with well-defined parameters yielding only highly relevant results.\",\n                    ),\n                    (\n                        75,\n                        89,\n              ..."
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "SearchBaseAction",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "obj.pop",
      "cls",
      "super"
    ],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 432,
      "end_line": 438
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"SearchBaseAction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            repository = obj.pop(\"repository\")\n            code_index = obj.pop(\"code_index\")\n            return cls(code_index=code_index, repository=repository, **obj)\n        return super().model_validate(obj)"
  },
  {
    "name": "answer",
    "docstring": "",
    "is_method": true,
    "class_name": "FinishArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 33,
      "end_line": 34
    },
    "code_snippet": "def answer(self):\n        return self.answer"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FinishArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 36,
      "end_line": 37
    },
    "code_snippet": "def to_prompt(self):\n        return f\"Provide Answer: {self.finish_reason}\""
  },
  {
    "name": "equals",
    "docstring": "",
    "is_method": true,
    "class_name": "FinishArgs",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "isinstance"
    ],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 39,
      "end_line": 41
    },
    "code_snippet": "def equals(self, other: \"ActionArguments\") -> bool:\n        # Keep comparison simple for now, might need adjustment based on usage\n        return isinstance(other, FinishArgs) and self.finish_reason == other.finish_reason"
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "Finish",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "Observation"
    ],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 47,
      "end_line": 53
    },
    "code_snippet": "def execute(\n        self,\n        args: FinishArgs,\n        file_context: FileContext | None = None, # Keep for potential future context use\n    ):\n        # Return the answer from FinishArgs\n        return Observation(message=args.answer, terminal=True)"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "Finish",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 56,
      "end_line": 64
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length: int) -> List[str]:\n        # Adapted criteria for Code QA Answering\n        return [\n            \"**Answer Accuracy:** Evaluate the correctness of the provided code snippet or explanation. Does it accurately answer the user's query?\",\n            \"**Answer Completeness:** Assess if the answer provides all necessary information or code components required by the user's query. Are there missing imports, configurations, or steps?\",\n            \"**..."
  },
  {
    "name": "get_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "Finish",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "cls.generate_reward_scale_entries"
    ],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 67,
      "end_line": 107
    },
    "code_snippet": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        # Adapted reward scale for Code QA Answering\n        return cls.generate_reward_scale_entries(\n            [\n                (\n                    90,\n                    100,\n                    \"The answer is perfectly accurate, complete, directly relevant, clear, and follows best practices. It fully satisfies the user's query.\",\n                ),\n                (\n                    75,\n                    89,\n ..."
  },
  {
    "name": "get_value_function_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "Finish",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 110,
      "end_line": 112
    },
    "code_snippet": "def get_value_function_prompt(cls) -> str:\n        # Adapted value function prompt for Code QA Answering\n        return \"\"\"Your role is to evaluate the proposed final answer generated by an AI agent in response to a user's code-related query. The goal is to ensure the answer is accurate, complete, relevant, and clear.\"\"\""
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "Finish",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FewShotExample.create",
      "FinishArgs",
      "FinishArgs",
      "FinishArgs"
    ],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 115,
      "end_line": 139
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        # Adapted few-shot examples for Code QA Answering\n        return [\n            FewShotExample.create(\n                user_input=\"How do I read a file line by line in Python?\",\n                action=FinishArgs(\n                    answer=\"with open('file.txt', 'r') as file:\\n    for line in file:\\n        print(line.strip())\",\n                    thoughts=\"The provided Python code snippet correctly demonstrates reading a file line ..."
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "RejectArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "reject.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 18,
      "end_line": 19
    },
    "code_snippet": "def to_prompt(self):\n        return f\"Reject with reason: {self.rejection_reason}\""
  },
  {
    "name": "equals",
    "docstring": "",
    "is_method": true,
    "class_name": "RejectArgs",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "isinstance"
    ],
    "code_location": {
      "file": "reject.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 21,
      "end_line": 22
    },
    "code_snippet": "def equals(self, other: \"ActionArguments\") -> bool:\n        return isinstance(other, RejectArgs)"
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "Reject",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "Observation"
    ],
    "code_location": {
      "file": "reject.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 28,
      "end_line": 33
    },
    "code_snippet": "def execute(\n        self,\n        args: RejectArgs,\n        file_context: FileContext | None = None,\n    ):\n        return Observation(message=args.rejection_reason, terminal=True)"
  },
  {
    "name": "get_name",
    "docstring": "Returns the action name for the class based on Config title.",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls"
    ],
    "calls": [
      "str",
      "getattr"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 24,
      "end_line": 26
    },
    "code_snippet": "def get_name(cls) -> str:\n        \"\"\"Returns the action name for the class based on Config title.\"\"\"\n        return str(getattr(cls.Config, \"title\", cls.__name__))"
  },
  {
    "name": "format_for_llm",
    "docstring": "Format the action name for LLM consumption",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "self"
    ],
    "calls": [
      "str"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 28,
      "end_line": 30
    },
    "code_snippet": "def format_for_llm(self) -> str:\n        \"\"\"Format the action name for LLM consumption\"\"\"\n        return str(self.name)"
  },
  {
    "name": "format_name_for_llm",
    "docstring": "Format the class name for LLM consumption",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls"
    ],
    "calls": [
      "str",
      "cls.get_name"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 33,
      "end_line": 35
    },
    "code_snippet": "def format_name_for_llm(cls) -> str:\n        \"\"\"Format the class name for LLM consumption\"\"\"\n        return str(cls.get_name())"
  },
  {
    "name": "to_tool_call",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.model_dump",
      "ToolCall"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 37,
      "end_line": 40
    },
    "code_snippet": "def to_tool_call(self) -> ToolCall:\n        tool_input = self.model_dump()\n\n        return ToolCall(name=self.name, input=tool_input)"
  },
  {
    "name": "from_tool_call",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls",
      "tool_args",
      "tool_name"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 43,
      "end_line": 44
    },
    "code_snippet": "def from_tool_call(cls, tool_args: dict[str, Any], tool_name: str | None = None):\n        return cls(**tool_args)"
  },
  {
    "name": "equals",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "self.model_dump",
      "other.model_dump"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 46,
      "end_line": 49
    },
    "code_snippet": "def equals(self, other: \"ActionArguments\") -> bool:\n        return self.model_dump(exclude={\"thoughts\"}) == other.model_dump(\n            exclude={\"thoughts\"}\n        )"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "self"
    ],
    "calls": [
      "join",
      "items",
      "self.model_dump"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 51,
      "end_line": 56
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Action: {self.name}\\n\"\n        prompt += \"\\n\".join(\n            [f\"  {k}: {v}\" for k, v in self.model_dump(exclude={\"thoughts\"}).items()]\n        )\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 58,
      "end_line": 59
    },
    "code_snippet": "def short_summary(self) -> str:\n        return f\"{self.name}()\""
  },
  {
    "name": "fix_thoughts",
    "docstring": "Allow thoughts to be null.",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls",
      "data"
    ],
    "calls": [
      "model_validator",
      "isinstance",
      "data.get"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 63,
      "end_line": 73
    },
    "code_snippet": "def fix_thoughts(cls, data: Any) -> Any:\n        \"\"\"Allow thoughts to be null.\"\"\"\n        if isinstance(data, dict):\n            if \"scratch_pad\" in data:\n                data[\"thoughts\"] = data[\"scratch_pad\"]\n                del data[\"scratch_pad\"]\n\n            if not data.get(\"thoughts\"):\n                data[\"thoughts\"] = \"\"\n\n        return data"
  },
  {
    "name": "fix_null_fields",
    "docstring": "Allow thoughts to be null.",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls",
      "data"
    ],
    "calls": [
      "model_validator",
      "isinstance",
      "data.items"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 77,
      "end_line": 84
    },
    "code_snippet": "def fix_null_fields(cls, data: Any) -> Any:\n        \"\"\"Allow thoughts to be null.\"\"\"\n        if isinstance(data, dict):\n            for key, value in data.items():\n                if value == \"null\":\n                    data[key] = None\n\n        return data"
  },
  {
    "name": "get_action_args",
    "docstring": "Dynamically import and return the appropriate ActionArguments class for the given action.",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls",
      "action_name"
    ],
    "calls": [
      "_action_args.get",
      "ValueError",
      "cls._load_action_args"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 87,
      "end_line": 98
    },
    "code_snippet": "def get_action_args(cls, action_name: str) -> Type[\"ActionArguments\"]:\n        \"\"\"\n        Dynamically import and return the appropriate ActionArguments class for the given action.\n        \"\"\"\n        if not _action_args:\n            cls._load_action_args()\n\n        action_args = _action_args.get(action_name)\n        if action_args:\n            return action_args\n\n        raise ValueError(f\"Unknown action: {action_name}\")"
  },
  {
    "name": "_load_action_args",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls"
    ],
    "calls": [
      "importlib.import_module",
      "pkgutil.iter_modules",
      "importlib.import_module",
      "module.__dict__.items",
      "isinstance",
      "issubclass"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 101,
      "end_line": 113
    },
    "code_snippet": "def _load_action_args(cls):\n        actions_package = importlib.import_module(\"moatless_qa.actions\")\n\n        for _, module_name, _ in pkgutil.iter_modules(actions_package.__path__):\n            full_module_name = f\"moatless_qa.actions.{module_name}\"\n            module = importlib.import_module(full_module_name)\n            for name, obj in module.__dict__.items():\n                if (\n                    isinstance(obj, type)\n                    and issubclass(obj, ActionArguments)\n            ..."
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionArguments",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "action_args_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "action_args_class.model_validate",
      "super"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 116,
      "end_line": 131
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"ActionArguments\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            action_args_class_path = obj.pop(\"action_args_class\", None)\n            if (\n                action_args_class_path\n                == \"moatless_qa.actions.request_context.RequestMoreContextArgs\"\n            ):\n                action_args_class_path = \"moatless_qa.actions.view_code.ViewCodeArgs\"\n\n            if action_args_class_path:\n                module_name, cla..."
  },
  {
    "name": "create",
    "docstring": "",
    "is_method": true,
    "class_name": "Observation",
    "parameters": [
      "cls",
      "message",
      "terminal"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 164,
      "end_line": 165
    },
    "code_snippet": "def create(cls, message: str, terminal: bool = False):\n        return cls(message=message, terminal=terminal)"
  },
  {
    "name": "create",
    "docstring": "",
    "is_method": true,
    "class_name": "FewShotExample",
    "parameters": [
      "cls",
      "user_input",
      "action"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 175,
      "end_line": 176
    },
    "code_snippet": "def create(cls, user_input: str, action: ActionArguments) -> \"FewShotExample\":\n        return cls(user_input=user_input, action=action)"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionError",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 187,
      "end_line": 188
    },
    "code_snippet": "def to_prompt(self):\n        return f\"Error: {self.error}\""
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "RetryException",
    "parameters": [
      "self",
      "message",
      "action_args"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 194,
      "end_line": 197
    },
    "code_snippet": "def __init__(self, message: str, action_args: ActionArguments):\n        super().__init__(message)\n        self.message = message\n        self.action_args = action_args"
  },
  {
    "name": "log_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeSpan",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 38,
      "end_line": 47
    },
    "code_snippet": "def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "name": "log_name",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "len",
      "enumerate",
      "logs.append",
      "join"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 62,
      "end_line": 69
    },
    "code_snippet": "def log_name(self):\n        if len(self.files) == 1:\n            return f\"FurtherViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"FurtherViewCode(\" + \", \".join(logs) + \")\""
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 71,
      "end_line": 79
    },
    "code_snippet": "def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids:\n                prompt += f\"  Spans: {', '.join(file.span_ids)}\\n\"\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "join",
      "param_strs.append"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 81,
      "end_line": 86
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_strs = []\n        for file in self.files:\n            param_strs.append(f\"path={file.file_path}\")\n        param_str = \", \".join(param_strs)\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "repository",
      "completion_model"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 94,
      "end_line": 101
    },
    "code_snippet": "def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository"
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "grouped_files.items",
      "FileContext",
      "grouped_files.items",
      "any",
      "view_context.is_empty",
      "Observation",
      "ValueError",
      "logger.info",
      "file_context.get_file",
      "self._repository.is_directory",
      "file_context.get_file",
      "file_context.add_file_context",
      "view_context.create_prompt",
      "span_ids.extend",
      "Observation",
      "Observation",
      "set",
      "set",
      "view_context.add_line_span_to_context",
      "view_context.add_file",
      "view_context.get_file",
      "view_context.context_size",
      "self._identify_code",
      "list",
      "logger.warning",
      "self.create_retry_message",
      "Observation",
      "file.module.find_span_by_id",
      "view_file.set_patch",
      "len",
      "values",
      "view_context.create_summary",
      "file.module.find_blocks_with_identifier",
      "span_id.split",
      "missing_span_ids.add",
      "view_context.add_span_to_context",
      "found_span_ids.add",
      "view_context.add_spans_to_context",
      "view_context.add_span_to_context",
      "class_block.get_all_span_ids"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 108,
      "end_line": 261
    },
    "code_snippet": "def execute(\n        self,\n        args: FurtherViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file_path not in grou..."
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 263,
      "end_line": 264
    },
    "code_snippet": "def _search_for_alternative_suggestion(self, args: FurtherViewCodeArgs):\n        return None"
  },
  {
    "name": "_select_span_instructions",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "search_result"
    ],
    "calls": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 266,
      "end_line": 267
    },
    "code_snippet": "def _select_span_instructions(self, search_result) -> str:\n        return \"The requested code is too large. You must identify the most relevant code sections to view.\""
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FurtherViewCodeArgs",
      "FurtherViewCodeArgs",
      "CodeSpan",
      "CodeSpan"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 270,
      "end_line": 295
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"The authenticate method is called, but there is no implementation code for it in the current code.\",\n                action=FurtherViewCodeArgs(\n                    thoughts=\"To understand the authentication implementation, we need to examine the authenticate method within the AuthenticationService class.\",\n                    files=[\n                        Cod..."
  },
  {
    "name": "create_retry_message",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "file",
      "message"
    ],
    "calls": [
      "self.create_hint",
      "FileContext",
      "search_result_context.add_file",
      "search_result_context.create_prompt"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 297,
      "end_line": 319
    },
    "code_snippet": "def create_retry_message(self, file: ContextFile, message: str):\n        retry_message = f\"\\n\\nProblems when trying to find spans in {file.file_path}. \"\n        retry_message += message\n\n        hint = self.create_hint(file)\n        if hint:\n            retry_message += f\"\\n\\n{hint}\"\n\n        if file.module and file.span_ids:\n            search_result_context = FileContext(repo=self._repository)\n            search_result_context.add_file(file.file_path, show_all_spans=True)\n\n            search_r..."
  },
  {
    "name": "create_hint",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "file"
    ],
    "calls": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 321,
      "end_line": 325
    },
    "code_snippet": "def create_hint(self, file: ContextFile):\n        if \"test\" in file.file_path:\n            return \"If you want to write a new test method, start by adding one of the existing ones that might relevant for reference.\"\n\n        return None"
  },
  {
    "name": "span_id_list",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 327,
      "end_line": 331
    },
    "code_snippet": "def span_id_list(self, span_ids: set[str]) -> str:\n        list_str = \"\"\n        for span_id in span_ids:\n            list_str += f\" * {span_id}\\n\"\n        return list_str"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 334,
      "end_line": 341
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = [\n            \"Relevance of Requested Context: Ensure that the requested context is directly related to the problem and necessary for making progress.\",\n            \"Avoiding Hallucinations: Verify that the agent is requesting context for code that actually exists in the codebase.\",\n            \"Efficiency: Assess whether the agent is requesting an appropriate amount of context without overloading unnecessary in..."
  },
  {
    "name": "get_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "FurtherViewCode",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 344,
      "end_line": 371
    },
    "code_snippet": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The requested context is highly relevant, precise, and necessary for solving the problem; the agent avoids hallucinations.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The requested context is relevan..."
  },
  {
    "name": "log_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeSpan",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 38,
      "end_line": 47
    },
    "code_snippet": "def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "name": "log_name",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "len",
      "enumerate",
      "logs.append",
      "join"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 62,
      "end_line": 69
    },
    "code_snippet": "def log_name(self):\n        if len(self.files) == 1:\n            return f\"ViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"ViewCode(\" + \", \".join(logs) + \")\""
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 71,
      "end_line": 79
    },
    "code_snippet": "def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids:\n                prompt += f\"  Spans: {', '.join(file.span_ids)}\\n\"\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCodeArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "join",
      "param_strs.append"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 81,
      "end_line": 86
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_strs = []\n        for file in self.files:\n            param_strs.append(f\"path={file.file_path}\")\n        param_str = \", \".join(param_strs)\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "repository",
      "completion_model"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 94,
      "end_line": 101
    },
    "code_snippet": "def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository"
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "grouped_files.items",
      "FileContext",
      "grouped_files.items",
      "any",
      "view_context.is_empty",
      "Observation",
      "ValueError",
      "logger.info",
      "file_context.get_file",
      "self._repository.is_directory",
      "file_context.get_file",
      "file_context.add_file_context",
      "view_context.create_prompt",
      "span_ids.extend",
      "Observation",
      "Observation",
      "set",
      "set",
      "view_context.add_line_span_to_context",
      "view_context.add_file",
      "view_context.get_file",
      "view_context.context_size",
      "self._identify_code",
      "list",
      "logger.warning",
      "self.create_retry_message",
      "Observation",
      "file.module.find_span_by_id",
      "view_file.set_patch",
      "len",
      "values",
      "view_context.create_summary",
      "file.module.find_blocks_with_identifier",
      "span_id.split",
      "missing_span_ids.add",
      "view_context.add_span_to_context",
      "found_span_ids.add",
      "view_context.add_spans_to_context",
      "view_context.add_span_to_context",
      "class_block.get_all_span_ids"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 108,
      "end_line": 261
    },
    "code_snippet": "def execute(\n        self,\n        args: ViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file_path not in grouped_fil..."
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 263,
      "end_line": 264
    },
    "code_snippet": "def _search_for_alternative_suggestion(self, args: ViewCodeArgs):\n        return None"
  },
  {
    "name": "_select_span_instructions",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "search_result"
    ],
    "calls": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 266,
      "end_line": 267
    },
    "code_snippet": "def _select_span_instructions(self, search_result) -> str:\n        return \"The requested code is too large. You must identify the most relevant code sections to view.\""
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "ViewCodeArgs",
      "ViewCodeArgs",
      "CodeSpan",
      "CodeSpan"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 270,
      "end_line": 295
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Show me the implementation of the authenticate method in the AuthenticationService class\",\n                action=ViewCodeArgs(\n                    thoughts=\"To understand the authentication implementation, we need to examine the authenticate method within the AuthenticationService class.\",\n                    files=[\n                        CodeSpan(\n          ..."
  },
  {
    "name": "create_retry_message",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "file",
      "message"
    ],
    "calls": [
      "self.create_hint",
      "FileContext",
      "search_result_context.add_file",
      "search_result_context.create_prompt"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 297,
      "end_line": 319
    },
    "code_snippet": "def create_retry_message(self, file: ContextFile, message: str):\n        retry_message = f\"\\n\\nProblems when trying to find spans in {file.file_path}. \"\n        retry_message += message\n\n        hint = self.create_hint(file)\n        if hint:\n            retry_message += f\"\\n\\n{hint}\"\n\n        if file.module and file.span_ids:\n            search_result_context = FileContext(repo=self._repository)\n            search_result_context.add_file(file.file_path, show_all_spans=True)\n\n            search_r..."
  },
  {
    "name": "create_hint",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "file"
    ],
    "calls": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 321,
      "end_line": 325
    },
    "code_snippet": "def create_hint(self, file: ContextFile):\n        if \"test\" in file.file_path:\n            return \"If you want to write a new test method, start by adding one of the existing ones that might relevant for reference.\"\n\n        return None"
  },
  {
    "name": "span_id_list",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 327,
      "end_line": 331
    },
    "code_snippet": "def span_id_list(self, span_ids: set[str]) -> str:\n        list_str = \"\"\n        for span_id in span_ids:\n            list_str += f\" * {span_id}\\n\"\n        return list_str"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 334,
      "end_line": 341
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = [\n            \"Relevance of Requested Context: Ensure that the requested context is directly related to the problem and necessary for making progress.\",\n            \"Avoiding Hallucinations: Verify that the agent is requesting context for code that actually exists in the codebase.\",\n            \"Efficiency: Assess whether the agent is requesting an appropriate amount of context without overloading unnecessary in..."
  },
  {
    "name": "get_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "ViewCode",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 344,
      "end_line": 371
    },
    "code_snippet": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The requested context is highly relevant, precise, and necessary for solving the problem; the agent avoids hallucinations.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The requested context is relevan..."
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 29,
      "end_line": 30
    },
    "code_snippet": "def __init__(self, **data):\n        super().__init__(**data)"
  },
  {
    "name": "execute",
    "docstring": "Execute the action.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "self._execute",
      "Observation.create"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 32,
      "end_line": 42
    },
    "code_snippet": "def execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        \"\"\"\n        Execute the action.\n        \"\"\"\n\n        message = self._execute(args, file_context=file_context)\n        return Observation.create(message)"
  },
  {
    "name": "_execute",
    "docstring": "Execute the action and return the updated FileContext.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "NotImplementedError"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 44,
      "end_line": 52
    },
    "code_snippet": "def _execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> str | None:\n        \"\"\"\n        Execute the action and return the updated FileContext.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")"
  },
  {
    "name": "name",
    "docstring": "Returns the name of the action class as a st ring.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 55,
      "end_line": 57
    },
    "code_snippet": "def name(self) -> str:\n        \"\"\"Returns the name of the action class as a st ring.\"\"\"\n        return self.__class__.__name__"
  },
  {
    "name": "get_name",
    "docstring": "Returns the name of the action class as a string.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 60,
      "end_line": 62
    },
    "code_snippet": "def get_name(cls) -> str:\n        \"\"\"Returns the name of the action class as a string.\"\"\"\n        return cls.__name__"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 65,
      "end_line": 77
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length: int | None = None) -> List[str]:\n        if trajectory_length < 3:\n            return [\n                \"Exploratory Actions: Recognize that initial searches and information-gathering steps are essential and should not be heavily penalized if they don't yield immediate results.\",\n                \"Appropriateness of Action: Evaluate if the action is logical given the agent's current knowledge and the early stage of problem-solving.\",\n           ..."
  },
  {
    "name": "get_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry",
      "RewardScaleEntry"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 80,
      "end_line": 112
    },
    "code_snippet": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The action significantly advances the solution.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The action contributes positively towards solving the problem.\",\n            ),\n            RewardScaleEntr..."
  },
  {
    "name": "generate_reward_scale_entries",
    "docstring": "Generate a list of RewardScaleEntry objects based on the provided descriptions.\n\nArgs:\n    descriptions: A list of tuples, each containing (min_value, max_value, description)\n\nReturns:\n    A list of RewardScaleEntry objects",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "descriptions"
    ],
    "calls": [
      "RewardScaleEntry"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 115,
      "end_line": 130
    },
    "code_snippet": "def generate_reward_scale_entries(\n        descriptions: List[Tuple[int, int, str]],\n    ) -> List[RewardScaleEntry]:\n        \"\"\"\n        Generate a list of RewardScaleEntry objects based on the provided descriptions.\n\n        Args:\n            descriptions: A list of tuples, each containing (min_value, max_value, description)\n\n        Returns:\n            A list of RewardScaleEntry objects\n        \"\"\"\n        return [\n            RewardScaleEntry(min_value=min_val, max_value=max_val, descriptio..."
  },
  {
    "name": "get_reward_range",
    "docstring": "Get the minimum and maximum reward values for this action.\n\nArgs:\n    trajectory_length: The length of the current trajectory\n\nReturns:\n    A tuple containing the minimum and maximum reward values",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "cls.get_reward_scale",
      "min",
      "max"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 133,
      "end_line": 146
    },
    "code_snippet": "def get_reward_range(cls, trajectory_length: int) -> Tuple[int, int]:\n        \"\"\"\n        Get the minimum and maximum reward values for this action.\n\n        Args:\n            trajectory_length: The length of the current trajectory\n\n        Returns:\n            A tuple containing the minimum and maximum reward values\n        \"\"\"\n        reward_scale = cls.get_reward_scale(trajectory_length)\n        min_reward = min(entry.min_value for entry in reward_scale)\n        max_reward = max(entry.max_val..."
  },
  {
    "name": "get_value_function_prompt",
    "docstring": "Get the base prompt for the value function.\nThis method can be overridden in subclasses to provide action-specific prompts.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 149,
      "end_line": 161
    },
    "code_snippet": "def get_value_function_prompt(cls) -> str:\n        \"\"\"\n        Get the base prompt for the value function.\n        This method can be overridden in subclasses to provide action-specific prompts.\n        \"\"\"\n        return \"\"\"Your role is to evaluate the **last executed action** of the search tree that our AI agents are traversing, to help us determine the best trajectory to solve a programming issue. The agent is responsible for identifying and modifying the correct file(s) in response to the pr..."
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "Returns a list of few-shot examples specific to this action.\nOverride this method in subclasses to provide custom examples.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 164,
      "end_line": 169
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        \"\"\"\n        Returns a list of few-shot examples specific to this action.\n        Override this method in subclasses to provide custom examples.\n        \"\"\"\n        return []"
  },
  {
    "name": "get_action_by_args_class",
    "docstring": "Get the Action subclass corresponding to the given ActionArguments subclass.\n\nArgs:\n    args_class: The ActionArguments subclass to look up.\n\nReturns:\n    The Action subclass if found, None otherwise.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "args_class"
    ],
    "calls": [
      "search_subclasses",
      "current_class.__subclasses__",
      "hasattr",
      "search_subclasses"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 172,
      "end_line": 197
    },
    "code_snippet": "def get_action_by_args_class(\n        cls, args_class: Type[ActionArguments]\n    ) -> Optional[Type[\"Action\"]]:\n        \"\"\"\n        Get the Action subclass corresponding to the given ActionArguments subclass.\n\n        Args:\n            args_class: The ActionArguments subclass to look up.\n\n        Returns:\n            The Action subclass if found, None otherwise.\n        \"\"\"\n\n        def search_subclasses(current_class):\n            if (\n                hasattr(current_class, \"args_schema\")\n     ..."
  },
  {
    "name": "get_action_by_name",
    "docstring": "Dynamically import and return the appropriate Action class for the given action name.",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "action_name"
    ],
    "calls": [
      "_actions.get",
      "ValueError",
      "cls._load_actions"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 200,
      "end_line": 211
    },
    "code_snippet": "def get_action_by_name(cls, action_name: str) -> Type[\"Action\"]:\n        \"\"\"\n        Dynamically import and return the appropriate Action class for the given action name.\n        \"\"\"\n        if not _actions:\n            cls._load_actions()\n\n        action = _actions.get(action_name)\n        if action:\n            return action\n\n        raise ValueError(f\"Unknown action: {action_name}\")"
  },
  {
    "name": "_load_actions",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls"
    ],
    "calls": [
      "importlib.import_module",
      "pkgutil.iter_modules",
      "importlib.import_module",
      "module.__dict__.items",
      "isinstance",
      "issubclass"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 214,
      "end_line": 222
    },
    "code_snippet": "def _load_actions(cls):\n        actions_package = importlib.import_module(\"moatless_qa.actions\")\n\n        for _, module_name, _ in pkgutil.iter_modules(actions_package.__path__):\n            full_module_name = f\"moatless_qa.actions.{module_name}\"\n            module = importlib.import_module(full_module_name)\n            for name, obj in module.__dict__.items():\n                if isinstance(obj, type) and issubclass(obj, Action) and obj != Action:\n                    _actions[name] = obj"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "cls",
      "obj",
      "repository",
      "code_index"
    ],
    "calls": [
      "isinstance",
      "cls",
      "obj.copy",
      "obj.pop",
      "action_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "action_class",
      "hasattr",
      "hasattr"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 225,
      "end_line": 250
    },
    "code_snippet": "def model_validate(\n        cls,\n        obj: Any,\n        repository: Repository = None,\n        # runtime: Any = None,\n        code_index: CodeIndex = None,\n    ) -> \"Action\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            action_class_path = obj.pop(\"action_class\", None)\n\n            if action_class_path:\n                module_name, class_name = action_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                action_cl..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "Action",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 252,
      "end_line": 255
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"action_class\"] = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        return dump"
  },
  {
    "name": "validate_snippet",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCalledObjectArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "self.called_object.strip",
      "ValueError"
    ],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 41,
      "end_line": 44
    },
    "code_snippet": "def validate_snippet(self) -> \"FindCalledObjectArgs\":\n        if not self.called_object.strip():\n            raise ValueError(\"called object cannot be empty\")\n        return self"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCalledObjectArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 46,
      "end_line": 50
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Searching for called object: {self.called_object}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCalledObjectArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 52,
      "end_line": 56
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"called_object={self.called_object}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "_search_for_context",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCalledObject",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "logger.info",
      "self._repository.find_exact_matches",
      "FileContext",
      "len",
      "search_result_context.add_line_span_to_context",
      "len",
      "args.called_object.splitlines",
      "fnmatch"
    ],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 67,
      "end_line": 94
    },
    "code_snippet": "def _search_for_context(\n        self, args: FindCalledObjectArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.called_object} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.called_object, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_pat..."
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "FindCalledObject",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FewShotExample.create",
      "FindCalledObjectArgs",
      "FindCalledObjectArgs",
      "FindCalledObjectArgs"
    ],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 97,
      "end_line": 130
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input='''The user's location is empty, but the location is update by the profile and I need to find the object associated with the user's location that is called in the code but not implemented in the code.''',\n                action=FindCalledObjectArgs(\n                    thoughts=\"The user's location is defined via user.update_location(profile.location), profile is..."
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ListFilesArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 24,
      "end_line": 25
    },
    "code_snippet": "def to_prompt(self):\n        return f\"List contents of directory: {self.directory or '(root)'}\""
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "ListFilesArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 27,
      "end_line": 29
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"directory={self.directory}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "execute",
    "docstring": "",
    "is_method": true,
    "class_name": "ListFiles",
    "parameters": [
      "self",
      "args",
      "file_context"
    ],
    "calls": [
      "RuntimeError",
      "file_context._repo.list_directory",
      "Observation",
      "Observation",
      "str"
    ],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 35,
      "end_line": 73
    },
    "code_snippet": "def execute(\n        self,\n        args: ListFilesArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if not file_context._repo:\n            raise RuntimeError(\"Repository not available for listing files.\")\n\n        try:\n            result = file_context._repo.list_directory(args.directory)\n\n            message = f\"Contents of directory '{args.directory or '(root)'}'\\n\\n\"\n\n            if result[\"directories\"]:\n                message += \"Directories:\\n\"\n         ..."
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "ListFiles",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 76,
      "end_line": 81
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        return [\n            \"Directory Path Validity: Ensure the requested directory path exists and is valid.\",\n            \"Usefulness: Assess if listing the directory contents is helpful for the current task.\",\n            \"Efficiency: Evaluate if the action is being used at an appropriate time in the workflow.\",\n        ]"
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "ListFiles",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "ListFilesArgs",
      "ListFilesArgs"
    ],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 84,
      "end_line": 100
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Show me what files are in the tests directory\",\n                action=ListFilesArgs(\n                    thoughts=\"I'll list the contents of the tests directory to see what test files are available.\",\n                    directory=\"tests\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"What files are in the root..."
  },
  {
    "name": "_identify_code",
    "docstring": "Identify relevant code sections in a large context.\n\nArgs:\n    args: The arguments containing the request information\n    view_context: The context containing the code to identify from\n    max_tokens: The maximum number of tokens allowed in the result\n\nReturns:\n    A tuple of (identified_context, completion)",
    "is_method": true,
    "class_name": "IdentifyMixin",
    "parameters": [
      "self",
      "args",
      "view_context",
      "max_tokens"
    ],
    "calls": [
      "view_context.create_prompt",
      "ChatCompletionUserMessage",
      "range",
      "CompletionRejectError",
      "self.completion_model.create_completion",
      "logger.info",
      "FileContext",
      "identified_context.context_size",
      "args.to_prompt",
      "logger.warning",
      "logger.info",
      "messages.append",
      "messages.append",
      "logger.info",
      "ChatCompletionAssistantMessage",
      "ChatCompletionUserMessage",
      "len",
      "identified_context.add_line_span_to_context",
      "identified_code.model_dump_json"
    ],
    "code_location": {
      "file": "identify_mixin.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 35,
      "end_line": 123
    },
    "code_snippet": "def _identify_code(\n        self, args, view_context: FileContext, max_tokens: int\n    ) -> Tuple[FileContext, Completion]:\n        \"\"\"Identify relevant code sections in a large context.\n\n        Args:\n            args: The arguments containing the request information\n            view_context: The context containing the code to identify from\n            max_tokens: The maximum number of tokens allowed in the result\n\n        Returns:\n            A tuple of (identified_context, completion)\n       ..."
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearchArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 37,
      "end_line": 41
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Searching for code using the query: {self.query}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "name": "validate_query",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearchArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "self.query.strip",
      "ValueError"
    ],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 44,
      "end_line": 47
    },
    "code_snippet": "def validate_query(self) -> \"SemanticSearchArgs\":\n        if not self.query.strip():\n            raise ValueError(\"query cannot be empty\")\n        return self"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearchArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 49,
      "end_line": 53
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"query={self.query[:20]}, category={self.category}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "_search",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearch",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "self._code_index.semantic_search"
    ],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 59,
      "end_line": 65
    },
    "code_snippet": "def _search(self, args: SemanticSearchArgs) -> SearchCodeResponse:\n        return self._code_index.semantic_search(\n            args.query,\n            file_pattern=args.file_pattern,\n            max_results=self.max_hits,\n            category=args.category,\n        )"
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearch",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "SearchCodeResponse",
      "self._code_index.semantic_search"
    ],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 67,
      "end_line": 77
    },
    "code_snippet": "def _search_for_alternative_suggestion(\n        self, args: SemanticSearchArgs\n    ) -> SearchCodeResponse:\n        if args.file_pattern:\n            return self._code_index.semantic_search(\n                args.query,\n                max_results=self.max_hits,\n                category=args.category,\n            )\n\n        return SearchCodeResponse()"
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearch",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "get_evaluation_criteria",
      "criteria.extend",
      "super"
    ],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 80,
      "end_line": 88
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length: int | None = None) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Query Relevance: Evaluate if the search query is well-defined and likely to find relevant code.\",\n                \"Category Appropriateness: Assess if the category (implementation or test) aligns with the search intent.\",\n            ]\n        )\n        return criteria"
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "SemanticSearch",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "SemanticSearchArgs",
      "SemanticSearchArgs"
    ],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 91,
      "end_line": 110
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Find all implementations of database connection pooling in our codebase\",\n                action=SemanticSearchArgs(\n                    thoughts=\"To find implementations of database connection pooling, we should search for code related to managing database connections efficiently. This might include classes or functions that handle connection creation, reuse, a..."
  },
  {
    "name": "validate_names",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunctionArgs",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "self.function_name.strip",
      "ValueError",
      "ValueError",
      "self.class_name.strip"
    ],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 31,
      "end_line": 36
    },
    "code_snippet": "def validate_names(self) -> \"FindFunctionArgs\":\n        if not self.function_name.strip():\n            raise ValueError(\"function_name cannot be empty\")\n        if self.class_name is not None and not self.class_name.strip():\n            raise ValueError(\"class_name must be None or non-empty\")\n        return self"
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunctionArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 41,
      "end_line": 47
    },
    "code_snippet": "def to_prompt(self):\n        prompt = f\"Searching for function: {self.function_name}\"\n        if self.class_name:\n            prompt += f\" in class: {self.class_name}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "name": "short_summary",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunctionArgs",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 49,
      "end_line": 55
    },
    "code_snippet": "def short_summary(self) -> str:\n        param_str = f\"function_name={self.function_name}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        if self.class_name:\n            param_str += f\", class_name={self.class_name}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "name": "_search",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunction",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "logger.info",
      "self._code_index.find_function"
    ],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 61,
      "end_line": 69
    },
    "code_snippet": "def _search(self, args: FindFunctionArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.function_name} (class_name: {args.class_name}, file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_function(\n            args.function_name,\n            class_name=args.class_name,\n            file_pattern=args.file_pattern,\n        )"
  },
  {
    "name": "_search_for_alternative_suggestion",
    "docstring": "Return methods in the same class or other methods in same file with the method name the method in class is not found.",
    "is_method": true,
    "class_name": "FindFunction",
    "parameters": [
      "self",
      "args"
    ],
    "calls": [
      "SearchCodeResponse",
      "self._repository.get_file",
      "self._code_index.find_class",
      "file.module.find_by_identifier",
      "file.module.find_blocks_with_identifier",
      "SearchCodeResponse",
      "class_block.find_blocks_with_type",
      "span_ids.append",
      "span_ids.append",
      "SearchCodeHit",
      "SpanHit"
    ],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 71,
      "end_line": 109
    },
    "code_snippet": "def _search_for_alternative_suggestion(\n        self, args: FindFunctionArgs\n    ) -> SearchCodeResponse:\n        \"\"\"Return methods in the same class or other methods in same file with the method name the method in class is not found.\"\"\"\n\n        if args.class_name and args.file_pattern:\n            file = self._repository.get_file(args.file_pattern)\n\n            span_ids = []\n            if file and file.module:\n                class_block = file.module.find_by_identifier(args.class_name)\n     ..."
  },
  {
    "name": "get_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunction",
    "parameters": [
      "cls",
      "trajectory_length"
    ],
    "calls": [
      "get_evaluation_criteria",
      "criteria.extend",
      "super"
    ],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 112,
      "end_line": 120
    },
    "code_snippet": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Function Identifier Accuracy: Ensure that the function name is correctly specified.\",\n                \"Class Name Appropriateness: Verify that the class names, if any, are appropriate.\",\n            ]\n        )\n        return criteria"
  },
  {
    "name": "get_few_shot_examples",
    "docstring": "",
    "is_method": true,
    "class_name": "FindFunction",
    "parameters": [
      "cls"
    ],
    "calls": [
      "FewShotExample.create",
      "FewShotExample.create",
      "FindFunctionArgs",
      "FindFunctionArgs"
    ],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 123,
      "end_line": 141
    },
    "code_snippet": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Find the calculate_interest function in our financial module to review its logic\",\n                action=FindFunctionArgs(\n                    thoughts=\"To review the logic of the calculate_interest function, we need to locate its implementation in the financial module.\",\n                    function_name=\"calculate_interest\",\n                    file_pattern=\"..."
  },
  {
    "name": "create",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeQAAgent",
    "parameters": [
      "cls",
      "repository",
      "completion_model",
      "preset_actions",
      "code_index",
      "edit_completion_model",
      "message_history_type",
      "thoughts_in_action"
    ],
    "calls": [
      "completion_model.clone",
      "completion_model.clone",
      "generate_workflow_prompt",
      "MessageHistoryGenerator",
      "logger.info",
      "cls",
      "logger.info",
      "create_all_actions",
      "generate_guideline_prompt",
      "json.dumps"
    ],
    "code_location": {
      "file": "code_qa_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 39,
      "end_line": 123
    },
    "code_snippet": "def create(\n        cls,\n        repository: Repository,\n        completion_model: CompletionModel,\n        preset_actions: List[Action] | None = None,\n        code_index: CodeIndex | None = None,\n        edit_completion_model: CompletionModel | None = None,\n        message_history_type: MessageHistoryType | None = None,\n        thoughts_in_action: bool = False,\n        **kwargs,\n    ):\n        # Clone the completion model to ensure we have our own instance\n        completion_model = completion_..."
  },
  {
    "name": "create_base_actions",
    "docstring": "Create the common base actions used across all action creators.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repository",
      "code_index",
      "completion_model"
    ],
    "calls": [
      "SemanticSearch",
      "FindClass",
      "FindFunction",
      "FindCodeSnippet",
      "ViewCode"
    ],
    "code_location": {
      "file": "code_qa_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 126,
      "end_line": 154
    },
    "code_snippet": "def create_base_actions(\n    repository: Repository,\n    code_index: CodeIndex | None = None,\n    completion_model: CompletionModel | None = None,\n) -> List[Action]:\n    \"\"\"Create the common base actions used across all action creators.\"\"\"\n    return [\n        SemanticSearch(\n            code_index=code_index,\n            repository=repository,\n            completion_model=completion_model,\n        ),\n        FindClass(\n            code_index=code_index,\n            repository=repository,\n      ..."
  },
  {
    "name": "create_all_actions",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repository",
      "code_index",
      "completion_model"
    ],
    "calls": [
      "create_base_actions",
      "actions.append",
      "Finish"
    ],
    "code_location": {
      "file": "code_qa_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 157,
      "end_line": 164
    },
    "code_snippet": "def create_all_actions(\n    repository: Repository,\n    code_index: CodeIndex | None = None,\n    completion_model: CompletionModel | None = None,\n) -> List[Action]:\n    actions = create_base_actions(repository, code_index, completion_model)\n    actions.append(Finish())\n    return actions"
  },
  {
    "name": "__eq__",
    "docstring": "",
    "is_method": true,
    "class_name": "AgentSettings",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "isinstance"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 28,
      "end_line": 36
    },
    "code_snippet": "def __eq__(self, other):\n        if not isinstance(other, AgentSettings):\n            return False\n        return (\n            self.completion_model == other.completion_model\n            and self.system_prompt == other.system_prompt\n            and self.actions == other.actions\n            and self.message_history_type == other.message_history_type\n        )"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "AgentSettings",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 38,
      "end_line": 41
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"message_history_type\"] = self.message_history_type.value\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "AgentSettings",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "MessageHistoryType",
      "super"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 44,
      "end_line": 51
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"AgentSettings\":\n        if isinstance(obj, dict):\n            if \"message_history_type\" in obj:\n                obj[\"message_history_type\"] = MessageHistoryType(\n                    obj[\"message_history_type\"]\n                )\n\n        return super().model_validate(obj)"
  },
  {
    "name": "generate_workflow_prompt",
    "docstring": "Generate the workflow prompt based on available actions.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "actions"
    ],
    "calls": [
      "search_actions.append",
      "other_actions.append"
    ],
    "code_location": {
      "file": "code_qa_prompts.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 109,
      "end_line": 173
    },
    "code_snippet": "def generate_workflow_prompt(actions) -> str:\n    \"\"\"Generate the workflow prompt based on available actions.\"\"\"\n    search_actions = []\n    other_actions = []\n\n    # Define search action descriptions\n    search_descriptions = {\n        \"FindClass\": \"Search for class definitions by class name\",\n        \"FindFunction\": \"Search for function definitions by function name\",\n        \"FindCodeSnippet\": \"Search for specific code patterns or text\",\n        \"SemanticSearch\": \"Search code by semantic meani..."
  },
  {
    "name": "generate_guideline_prompt",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [],
    "calls": [],
    "code_location": {
      "file": "code_qa_prompts.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 178,
      "end_line": 204
    },
    "code_snippet": "def generate_guideline_prompt() -> str:\n    prompt = \"\"\"\n# Important Guidelines\n\n * **Focus on the Specific Question**\n  - Answer the question exactly as asked, based on the code in the repository.\n  - Provide complete and accurate information.\n  - Do not make assumptions about code you haven't seen.\n\n * **Code Context and Information**\n   - Base your answer only on code you can see through searches and ViewCode actions.\n   - If you need to examine more code to provide a complete answer, use Vie..."
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self",
      "completion",
      "system_prompt",
      "actions",
      "message_generator"
    ],
    "calls": [
      "__init__",
      "self.set_actions",
      "MessageHistoryGenerator",
      "super"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 44,
      "end_line": 61
    },
    "code_snippet": "def __init__(\n        self,\n        completion: CompletionModel,\n        system_prompt: str | None = None,\n        actions: List[Action] | None = None,\n        message_generator: MessageHistoryGenerator | None = None,\n        **data,\n    ):\n        actions = actions or []\n        message_generator = message_generator or MessageHistoryGenerator()\n        super().__init__(\n            actions=actions,\n            system_prompt=system_prompt,\n            message_generator=message_generator,\n       ..."
  },
  {
    "name": "from_agent_settings",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "cls",
      "agent_settings",
      "actions"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 64,
      "end_line": 78
    },
    "code_snippet": "def from_agent_settings(\n        cls, agent_settings: AgentSettings, actions: List[Action] | None = None\n    ):\n        if agent_settings.actions:\n            actions = [\n                action\n                for action in actions\n                if action.__class__.__name__ in agent_settings.actions\n            ]\n\n        return cls(\n            completion=agent_settings.completion_model,\n            system_prompt=agent_settings.system_prompt,\n            actions=actions,\n        )"
  },
  {
    "name": "set_actions",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self",
      "actions"
    ],
    "calls": [],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 80,
      "end_line": 82
    },
    "code_snippet": "def set_actions(self, actions: List[Action]):\n        self.actions = actions\n        self._action_map = {action.args_schema: action for action in actions}"
  },
  {
    "name": "verify_actions",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "isinstance",
      "ValidationError",
      "hasattr",
      "ValidationError",
      "type"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 85,
      "end_line": 95
    },
    "code_snippet": "def verify_actions(self) -> \"ActionAgent\":\n        for action in self.actions:\n            if not isinstance(action, Action):\n                raise ValidationError(\n                    f\"Invalid action type: {type(action)}. Expected Action subclass.\"\n                )\n            if not hasattr(action, \"args_schema\"):\n                raise ValidationError(\n                    f\"Action {action.__class__.__name__} is missing args_schema attribute\"\n                )\n        return self"
  },
  {
    "name": "run",
    "docstring": "Run the agent on a node to generate and execute an action.",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self",
      "node",
      "experience"
    ],
    "calls": [
      "self.generate_system_prompt",
      "self.message_generator.generate",
      "logger.info",
      "node.find_duplicate",
      "logger.info",
      "print",
      "logger.info",
      "node.reset",
      "messages.append",
      "self._completion.create_completion",
      "print",
      "logger.info",
      "self._execute",
      "traceback.format_exc",
      "len",
      "ActionStep",
      "hasattr",
      "hasattr",
      "Completion.from_llm_completion",
      "logger.warning",
      "len",
      "len"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 97,
      "end_line": 163
    },
    "code_snippet": "def run(self, node: Node, experience):\n        \"\"\"Run the agent on a node to generate and execute an action.\"\"\"\n\n        if node.action:\n            logger.info(f\"Node{node.node_id}: Resetting node\")\n            node.reset()\n\n        node.possible_actions = [action.name for action in self.actions]\n        system_prompt = self.generate_system_prompt()\n        action_args = [action.args_schema for action in self.actions]\n\n        messages = self.message_generator.generate(node)\n        # add exper..."
  },
  {
    "name": "_execute",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self",
      "node",
      "action_step"
    ],
    "calls": [
      "self._action_map.get",
      "type",
      "logger.error",
      "RuntimeError",
      "action.execute",
      "logger.info",
      "print",
      "print",
      "logger.warning",
      "Observation",
      "self._action_map.keys",
      "type"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 165,
      "end_line": 202
    },
    "code_snippet": "def _execute(self, node: Node, action_step: ActionStep):\n        action = self._action_map.get(type(action_step.action))\n        if not action:\n            logger.error(\n                f\"Node{node.node_id}: Action {node.action.name} not found in action map. \"\n                f\"Available actions: {self._action_map.keys()}\"\n            )\n            raise RuntimeError(f\"Action {type(node.action)} not found in action map.\")\n\n        try:\n            action_step.observation = action.execute(\n      ..."
  },
  {
    "name": "generate_system_prompt",
    "docstring": "Generate a system prompt for the agent.",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.generate_few_shots"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 204,
      "end_line": 214
    },
    "code_snippet": "def generate_system_prompt(self) -> str:\n        \"\"\"Generate a system prompt for the agent.\"\"\"\n\n        system_prompt = self.system_prompt\n        if self.use_few_shots:\n            system_prompt += \"\\n\\n\" + self.generate_few_shots()\n        \n        system_prompt+=f\"\\n{RESPONSE_FORMAT}\"\n        \n\n        return system_prompt"
  },
  {
    "name": "generate_few_shots",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self"
    ],
    "calls": [
      "action.get_few_shot_examples",
      "enumerate",
      "few_shot_examples.extend",
      "example.action.model_dump",
      "action_data.pop",
      "str",
      "json.dumps",
      "example.action.model_dump",
      "json.dumps",
      "json.dumps",
      "tools_json.update",
      "tools_json.update",
      "example.action.model_dump",
      "example.action.model_dump"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 216,
      "end_line": 262
    },
    "code_snippet": "def generate_few_shots(self) -> str:\n        few_shot_examples = []\n        for action in self.actions:\n            examples = action.get_few_shot_examples()\n            if examples:\n                few_shot_examples.extend(examples)\n\n        prompt = \"\"\n        if few_shot_examples:\n            prompt += \"\\n\\n# Examples\\nHere are some examples of how to use the available actions:\\n\\n\"\n            for i, example in enumerate(few_shot_examples):\n                if self.completion.response_format ..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "self._completion.model_dump",
      "append",
      "super",
      "action.model_dump"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 264,
      "end_line": 271
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion\"] = self._completion.model_dump(**kwargs)\n        dump[\"actions\"] = []\n        dump[\"agent_class\"] = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        for action in self.actions:\n            dump[\"actions\"].append(action.model_dump(**kwargs))\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "cls",
      "obj",
      "repository",
      "runtime",
      "code_index"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "obj.pop",
      "obj.get",
      "MessageHistoryGenerator.model_validate",
      "CompletionModel.model_validate",
      "logger.info",
      "agent_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "agent_class",
      "cls",
      "super",
      "Action.model_validate",
      "obj.get"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 274,
      "end_line": 321
    },
    "code_snippet": "def model_validate(\n        cls,\n        obj: Any,\n        repository: Repository = None,\n        runtime: Any = None,\n        code_index: CodeIndex = None,\n    ) -> \"ActionAgent\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion\", None)\n            agent_class_path = obj.pop(\"agent_class\", None)\n\n            message_generator_data = obj.get(\"message_generator\", {})\n            if message_generator_data:\n                obj[\"message..."
  },
  {
    "name": "from_dict",
    "docstring": "Create an ActionAgent from a dictionary, properly handling dependencies.",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "cls",
      "data",
      "repository",
      "code_index",
      "runtime"
    ],
    "calls": [
      "data.copy",
      "cls.model_validate",
      "isinstance",
      "CompletionModel.model_validate",
      "isinstance",
      "isinstance",
      "MessageHistoryGenerator.model_validate",
      "rsplit",
      "importlib.import_module",
      "getattr",
      "agent_class",
      "Action.model_validate"
    ],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 324,
      "end_line": 363
    },
    "code_snippet": "def from_dict(\n        cls,\n        data: Dict[str, Any],\n        repository: Repository | None = None,\n        code_index: CodeIndex | None = None,\n        runtime: Any | None = None,\n    ) -> \"ActionAgent\":\n        \"\"\"Create an ActionAgent from a dictionary, properly handling dependencies.\"\"\"\n        data = data.copy()\n\n        # Handle completion model\n        if \"completion\" in data and isinstance(data[\"completion\"], dict):\n            data[\"completion\"] = CompletionModel.model_validate(data..."
  },
  {
    "name": "completion",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 366,
      "end_line": 367
    },
    "code_snippet": "def completion(self) -> CompletionModel:\n        return self._completion"
  },
  {
    "name": "completion",
    "docstring": "",
    "is_method": true,
    "class_name": "ActionAgent",
    "parameters": [
      "self",
      "value"
    ],
    "calls": [],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 370,
      "end_line": 371
    },
    "code_snippet": "def completion(self, value: CompletionModel):\n        self._completion = value"
  },
  {
    "name": "build_ascii_tree",
    "docstring": "Build an ASCII representation of the search tree starting from the given node.\n\nArgs:\n    node: The current node to process\n    prefix: The prefix to use for the current line (for indentation)\n    is_last: Whether this node is the last child of its parent\n\nReturns:\n    A string containing the ASCII tree representation",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "self",
      "node",
      "prefix",
      "is_last"
    ],
    "calls": [
      "list",
      "enumerate",
      "sum",
      "sum",
      "node.observation.feedback.split",
      "self.build_ascii_tree",
      "node.get_depth",
      "line.strip",
      "node.get_descendants",
      "node.get_descendants",
      "line.strip",
      "len"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 18,
      "end_line": 68
    },
    "code_snippet": "def build_ascii_tree(self, node: Node, prefix: str = \"\", is_last: bool = True) -> str:\n    \"\"\"\n    Build an ASCII representation of the search tree starting from the given node.\n\n    Args:\n        node: The current node to process\n        prefix: The prefix to use for the current line (for indentation)\n        is_last: Whether this node is the last child of its parent\n\n    Returns:\n        A string containing the ASCII tree representation\n    \"\"\"\n    # Start with the current line's prefix\n    cu..."
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "UCTScore",
    "parameters": [
      "self"
    ],
    "calls": [
      "join"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 88,
      "end_line": 105
    },
    "code_snippet": "def __str__(self):\n        components = [\n            f\"Final Score: {self.final_score:.2f}\",\n            f\"Exploitation: {self.exploitation:.2f}\",\n            f\"Exploration: {self.exploration:.2f}\",\n            f\"Depth Bonus: {self.depth_bonus:.2f}\",\n            f\"Depth Penalty: {self.depth_penalty:.2f}\",\n            f\"High Value Leaf Bonus: {self.high_value_leaf_bonus:.2f}\",\n            f\"High Value Bad Children Bonus: {self.high_value_bad_children_bonus:.2f}\",\n            f\"High Value Child P..."
  },
  {
    "name": "select",
    "docstring": "Base select method with common validation logic",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "expandable_nodes"
    ],
    "calls": [
      "self._select_node",
      "len",
      "ValueError",
      "len",
      "get_root",
      "root.is_expandable",
      "self._get_reward"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 187,
      "end_line": 210
    },
    "code_snippet": "def select(self, expandable_nodes: List[Node]) -> Node:\n        \"\"\"Base select method with common validation logic\"\"\"\n        if len(expandable_nodes) == 0:\n            raise ValueError(\"No expandable nodes provided\")\n\n        if len(expandable_nodes) == 1:\n            return expandable_nodes[0]\n\n        # Filter nodes based on minimum reward threshold\n        valid_nodes = [\n            node\n            for node in expandable_nodes\n            if self._get_reward(node) >= self.minimum_reward_th..."
  },
  {
    "name": "_get_reward",
    "docstring": "",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.calculate_mean_reward"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 212,
      "end_line": 216
    },
    "code_snippet": "def _get_reward(self, node: Node):\n        if self.use_average_reward:\n            return node.calculate_mean_reward()\n        else:\n            return node.reward.value if node.reward else 0"
  },
  {
    "name": "_select_node",
    "docstring": "Internal selection method to be implemented by subclasses",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "NotImplementedError"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 218,
      "end_line": 220
    },
    "code_snippet": "def _select_node(self, nodes: List[Node]) -> Node:\n        \"\"\"Internal selection method to be implemented by subclasses\"\"\"\n        raise NotImplementedError(\"Subclasses must implement _select_node method\")"
  },
  {
    "name": "uct_score",
    "docstring": "Compute the UCT score with additional bonuses and penalties based on node characteristics.\n\nThis method combines various components to create a comprehensive score for node selection,\nbalancing exploration and exploitation while considering node-specific factors.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.calculate_exploitation",
      "self.calculate_exploration",
      "self.calculate_depth_bonus",
      "self.calculate_depth_penalty",
      "self.calculate_high_value_leaf_bonus",
      "self.calculate_high_value_bad_children_bonus",
      "self.calculate_high_value_child_penalty",
      "self.calculate_high_value_parent_bonus",
      "self.calculate_finished_trajectory_penalty",
      "self.calculate_expect_correction_bonus",
      "self.calculate_diversity_bonus",
      "self.calculate_duplicate_child_penalty",
      "self.calculate_duplicate_action_penalty",
      "UCTScore",
      "UCTScore",
      "float"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 222,
      "end_line": 279
    },
    "code_snippet": "def uct_score(self, node: Node) -> UCTScore:\n        \"\"\"\n        Compute the UCT score with additional bonuses and penalties based on node characteristics.\n\n        This method combines various components to create a comprehensive score for node selection,\n        balancing exploration and exploitation while considering node-specific factors.\n        \"\"\"\n        if node.visits == 0:\n            return UCTScore(final_score=float(\"inf\"))\n\n        exploitation = self.calculate_exploitation(node)\n  ..."
  },
  {
    "name": "calculate_exploitation",
    "docstring": "Calculate the exploitation component of the UCT score.\n\nPurpose: Favors nodes with higher rewards, encouraging the algorithm to exploit\nknown good paths in the search tree.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.calculate_mean_reward"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 281,
      "end_line": 293
    },
    "code_snippet": "def calculate_exploitation(self, node: Node) -> float:\n        \"\"\"\n        Calculate the exploitation component of the UCT score.\n\n        Purpose: Favors nodes with higher rewards, encouraging the algorithm to exploit\n        known good paths in the search tree.\n        \"\"\"\n        if self.use_average_reward:\n            reward = node.calculate_mean_reward()\n        else:\n            reward = node.reward.value if node.reward else 0\n\n        return self.exploitation_weight * reward"
  },
  {
    "name": "calculate_exploration",
    "docstring": "Calculate the exploration component of the UCT score.\n\nPurpose: Encourages the exploration of less-visited nodes, ensuring a balance\nbetween exploitation and exploration in the search process.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "math.sqrt",
      "math.log"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 295,
      "end_line": 303
    },
    "code_snippet": "def calculate_exploration(self, node: Node) -> float:\n        \"\"\"\n        Calculate the exploration component of the UCT score.\n\n        Purpose: Encourages the exploration of less-visited nodes, ensuring a balance\n        between exploitation and exploration in the search process.\n        \"\"\"\n        total_visits = node.parent.visits if node.parent else 1\n        return self.exploration_weight * math.sqrt(math.log(total_visits) / node.visits)"
  },
  {
    "name": "calculate_depth_bonus",
    "docstring": "Calculate the depth-based exploration bonus.\n\nPurpose: Provides an incentive to explore deeper into the search tree,\nparticularly for nodes near the root, to encourage thorough exploration.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.get_depth",
      "np.exp"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 305,
      "end_line": 315
    },
    "code_snippet": "def calculate_depth_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the depth-based exploration bonus.\n\n        Purpose: Provides an incentive to explore deeper into the search tree,\n        particularly for nodes near the root, to encourage thorough exploration.\n        \"\"\"\n        depth = node.get_depth()\n        if depth == 0:\n            return self.depth_bonus_factor * np.exp(-self.depth_weight * (depth - 1))\n        return 0"
  },
  {
    "name": "calculate_depth_penalty",
    "docstring": "Calculate the depth penalty for very deep nodes.\n\nPurpose: Discourages excessive depth in the search tree, preventing the\nalgorithm from getting stuck in overly long paths.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.get_depth",
      "math.sqrt"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 317,
      "end_line": 325
    },
    "code_snippet": "def calculate_depth_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the depth penalty for very deep nodes.\n\n        Purpose: Discourages excessive depth in the search tree, preventing the\n        algorithm from getting stuck in overly long paths.\n        \"\"\"\n        depth = node.get_depth()\n        return self.depth_weight * math.sqrt(depth)"
  },
  {
    "name": "calculate_high_value_leaf_bonus",
    "docstring": "Calculate the bonus for not expanded nodes with high reward.\n\nPurpose: Encourages the exploration of promising leaf nodes, potentially\nleading to valuable new paths in the search tree.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 327,
      "end_line": 336
    },
    "code_snippet": "def calculate_high_value_leaf_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for not expanded nodes with high reward.\n\n        Purpose: Encourages the exploration of promising leaf nodes, potentially\n        leading to valuable new paths in the search tree.\n        \"\"\"\n        if not node.children and node.reward.value >= self.high_value_threshold:\n            return self.high_value_leaf_bonus_constant\n        return 0"
  },
  {
    "name": "calculate_high_value_bad_children_bonus",
    "docstring": "Calculate the bonus for nodes with high reward that expanded to low-reward nodes.\n\nPurpose: Acts as an \"auto-correct\" mechanism for promising nodes that led to poor\noutcomes, likely due to invalid actions (e.g., syntax errors from incorrect code changes).\nThis bonus gives these nodes a second chance, allowing the algorithm to potentially\nrecover from or find alternatives to invalid actions.\n\nThe bonus is applied when:\n1. The node has a high reward\n2. It has exactly one child (indicating a single action was taken)\n3. The child action is of a type we want to check (e.g., RequestCodeChange)\n4. The child node has a low reward\n\nIn such cases, we encourage revisiting this node to try different actions,\npotentially leading to better outcomes.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.calculate_exploitation",
      "any",
      "len",
      "sum",
      "len"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 338,
      "end_line": 370
    },
    "code_snippet": "def calculate_high_value_bad_children_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with high reward that expanded to low-reward nodes.\n\n        Purpose: Acts as an \"auto-correct\" mechanism for promising nodes that led to poor\n        outcomes, likely due to invalid actions (e.g., syntax errors from incorrect code changes).\n        This bonus gives these nodes a second chance, allowing the algorithm to potentially\n        recover from or find alternatives to..."
  },
  {
    "name": "calculate_high_value_child_penalty",
    "docstring": "Calculate the penalty for nodes with a child with very high reward.\n\nPurpose: Discourages over-exploitation of a single high-value path, promoting\nexploration of alternative routes in the search tree.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "max"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 372,
      "end_line": 386
    },
    "code_snippet": "def calculate_high_value_child_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the penalty for nodes with a child with very high reward.\n\n        Purpose: Discourages over-exploitation of a single high-value path, promoting\n        exploration of alternative routes in the search tree.\n        \"\"\"\n        if node.children:\n            child_values = [\n                child.reward.value for child in node.children if child.reward\n            ]\n            max_child_value = max(chi..."
  },
  {
    "name": "calculate_high_value_parent_bonus",
    "docstring": "Calculate the bonus for nodes with low reward that haven't been expanded yet but have high reward parents or not rewarded parents.\n\nPurpose: Encourages exploration of nodes that might be undervalued due to their\ncurrent low reward, especially if they have promising ancestors.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.calculate_exploitation"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 388,
      "end_line": 403
    },
    "code_snippet": "def calculate_high_value_parent_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with low reward that haven't been expanded yet but have high reward parents or not rewarded parents.\n\n        Purpose: Encourages exploration of nodes that might be undervalued due to their\n        current low reward, especially if they have promising ancestors.\n        \"\"\"\n        exploitation = self.calculate_exploitation(node)\n        if not node.children:\n            if node.pa..."
  },
  {
    "name": "calculate_finished_trajectory_penalty",
    "docstring": "Calculate the penalty for nodes where there are changes and a child node was already finished with high reward.\n\nPurpose: Discourages revisiting paths that have already led to successful outcomes,\npromoting exploration of new areas in the search space.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.is_on_finished_trajectory"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 405,
      "end_line": 418
    },
    "code_snippet": "def calculate_finished_trajectory_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the penalty for nodes where there are changes and a child node was already finished with high reward.\n\n        Purpose: Discourages revisiting paths that have already led to successful outcomes,\n        promoting exploration of new areas in the search space.\n        \"\"\"\n        if (\n            self.finished_trajectory_penalty\n            and node.file_context\n            and self.is_on_finished_t..."
  },
  {
    "name": "is_on_finished_trajectory",
    "docstring": "Check if the current node is on a trajectory that includes a 'Finish' node.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node",
      "min_reward_thresh"
    ],
    "calls": [
      "self.is_on_finished_trajectory",
      "child.is_finished"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 420,
      "end_line": 440
    },
    "code_snippet": "def is_on_finished_trajectory(\n        self, node: Node, min_reward_thresh: int = 100\n    ) -> bool:\n        \"\"\"\n        Check if the current node is on a trajectory that includes a 'Finish' node.\n        \"\"\"\n\n        for child in node.children:\n            if (\n                child.is_finished()\n                and child.reward\n                and child.reward.value >= min_reward_thresh\n            ):\n                return True\n\n            if self.is_on_finished_trajectory(\n                c..."
  },
  {
    "name": "calculate_expect_correction_bonus",
    "docstring": "Calculate the bonus for nodes with a parent node that expect correction.\n\nPurpose: Prioritizes nodes that are marked as expecting correction (e.g., after\na failed test run or an invalid search request). This bonus decreases rapidly\nas the parent node accumulates more children, encouraging exploration of less-visited\ncorrection paths.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "len"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 442,
      "end_line": 464
    },
    "code_snippet": "def calculate_expect_correction_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with a parent node that expect correction.\n\n        Purpose: Prioritizes nodes that are marked as expecting correction (e.g., after\n        a failed test run or an invalid search request). This bonus decreases rapidly\n        as the parent node accumulates more children, encouraging exploration of less-visited\n        correction paths.\n        \"\"\"\n        if (\n            node.obse..."
  },
  {
    "name": "calculate_diversity_bonus",
    "docstring": "Calculate the diversity bonus based on the similarity of the node's solution to already expanded nodes.\n\nPurpose: Boosts the score for nodes whose solutions have low similarity to other explored nodes,\nencouraging the exploration of novel solutions.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.file_context.is_empty",
      "self.get_similarity",
      "similarities.append",
      "sum",
      "len",
      "get_expanded_descendants",
      "node.get_root"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 466,
      "end_line": 501
    },
    "code_snippet": "def calculate_diversity_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the diversity bonus based on the similarity of the node's solution to already expanded nodes.\n\n        Purpose: Boosts the score for nodes whose solutions have low similarity to other explored nodes,\n        encouraging the exploration of novel solutions.\n        \"\"\"\n        if not self.diversity_weight:\n            return 0\n\n        # Ignore nodes without any code added to file context yet\n        if node.fi..."
  },
  {
    "name": "calculate_duplicate_child_penalty",
    "docstring": "Calculate penalty for nodes that have duplicate children.\nThe penalty increases with each duplicate child.\n\nPurpose: Discourages exploration of nodes that tend to generate duplicate states,\nas these are likely to be less productive paths in the search space.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "sum"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 503,
      "end_line": 515
    },
    "code_snippet": "def calculate_duplicate_child_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate penalty for nodes that have duplicate children.\n        The penalty increases with each duplicate child.\n\n        Purpose: Discourages exploration of nodes that tend to generate duplicate states,\n        as these are likely to be less productive paths in the search space.\n        \"\"\"\n        duplicate_count = sum(1 for child in node.children if child.is_duplicate)\n        if duplicate_count > 0:\n     ..."
  },
  {
    "name": "calculate_duplicate_action_penalty",
    "docstring": "Calculate penalty for nodes that have children with duplicate action names.\nThe penalty increases with each duplicate action.\n\nPurpose: Discourages selecting nodes whose children perform the same type of action\nmultiple times, promoting more diverse action sequences.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "action_counts.values",
      "action_counts.get"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 517,
      "end_line": 544
    },
    "code_snippet": "def calculate_duplicate_action_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate penalty for nodes that have children with duplicate action names.\n        The penalty increases with each duplicate action.\n\n        Purpose: Discourages selecting nodes whose children perform the same type of action\n        multiple times, promoting more diverse action sequences.\n        \"\"\"\n        if not node.children:\n            return 0.0\n\n        # Count occurrences of each action name among c..."
  },
  {
    "name": "get_similarity",
    "docstring": "Retrieve the similarity between two nodes from the cache or compute it if not cached.",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self",
      "node_a",
      "node_b"
    ],
    "calls": [
      "calculate_similarity",
      "min",
      "max"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 546,
      "end_line": 562
    },
    "code_snippet": "def get_similarity(self, node_a: Node, node_b: Node) -> float:\n        \"\"\"\n        Retrieve the similarity between two nodes from the cache or compute it if not cached.\n        \"\"\"\n        if node_a.file_context is None or node_b.file_context is None:\n            return 0.0\n\n        node_ids = (\n            min(node_a.node_id, node_b.node_id),\n            max(node_a.node_id, node_b.node_id),\n        )\n        if node_ids in self._similarity_cache:\n            return self._similarity_cache[node_i..."
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.get",
      "BestFirstSelector",
      "super",
      "SoftmaxSelector",
      "LLMSelector",
      "ValueError"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 565,
      "end_line": 576
    },
    "code_snippet": "def model_validate(cls: Type[\"Selector\"], obj: Any) -> \"Selector\":\n        if isinstance(obj, dict):\n            selector_type = obj.get(\"type\")\n            if selector_type == \"BestFirstSelector\":\n                return BestFirstSelector(**obj)\n            elif selector_type == \"SoftmaxSelector\":\n                return SoftmaxSelector(**obj)\n            elif selector_type == \"LLMSelector\":\n                return LLMSelector(**obj)\n            else:\n                raise ValueError(f\"Unknown sel..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "Selector",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 578,
      "end_line": 581
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"type\"] = self.__class__.__name__\n        return dump"
  },
  {
    "name": "_select_node",
    "docstring": "",
    "is_method": true,
    "class_name": "BestFirstSelector",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "sorted",
      "logger.info",
      "enumerate",
      "logger.info",
      "logger.info",
      "self.uct_score",
      "min",
      "len"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 587,
      "end_line": 610
    },
    "code_snippet": "def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        sorted_nodes = sorted(\n            nodes_with_scores, key=lambda x: x[1].final_score, reverse=True\n        )\n\n        # Log top nodes with detailed score breakdowns\n        top_nodes = sorted_nodes[: min(len(sorted_nodes), 10)]\n        logger.info(\"Comparing top nodes:\")\n        for i, (node, score) in enumerate(top_n..."
  },
  {
    "name": "_select_node",
    "docstring": "",
    "is_method": true,
    "class_name": "SoftmaxSelector",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "np.exp",
      "logger.info",
      "nodes.index",
      "logger.info",
      "softmax_scores.sum",
      "sorted",
      "logger.info",
      "random.choices",
      "self.uct_score",
      "np.max",
      "zip"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 616,
      "end_line": 650
    },
    "code_snippet": "def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        uct_scores = [score.final_score for _, score in nodes_with_scores]\n\n        # Calculate softmax probabilities\n        softmax_scores = np.exp(uct_scores - np.max(uct_scores))\n        probabilities = softmax_scores / softmax_scores.sum()\n\n        # Log summary for top nodes\n        top_nodes = sorted(\n            zip(n..."
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "LLMSelector",
    "parameters": [
      "self",
      "completion",
      "max_iterations"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 693,
      "end_line": 703
    },
    "code_snippet": "def __init__(\n        self, completion: CompletionModel = None, max_iterations: int = None, **kwargs\n    ):\n        # Initialize with all fields, including those from base class\n        all_kwargs = {\n            \"type\": \"LLMSelector\",\n            \"completion\": completion,\n            \"max_iterations\": max_iterations,\n            **kwargs,\n        }\n        super().__init__(**all_kwargs)"
  },
  {
    "name": "get_action_definitions",
    "docstring": "Build a formatted string containing descriptions of all available actions.",
    "is_method": true,
    "class_name": "LLMSelector",
    "parameters": [
      "self"
    ],
    "calls": [
      "logger.error",
      "action_class.args_schema.model_json_schema",
      "items",
      "logger.error",
      "schema.get"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 705,
      "end_line": 753
    },
    "code_snippet": "def get_action_definitions(self) -> str:\n        \"\"\"\n        Build a formatted string containing descriptions of all available actions.\n        \"\"\"\n        try:\n            from moatless_qa.actions import (\n                SemanticSearch,\n                FindClass,\n                FindFunction,\n                FindCodeSnippet,\n                Finish,\n                # Remove RequestMoreContext since it doesn't exist\n                # RequestMoreContext,\n            )\n\n            definitions = \"..."
  },
  {
    "name": "build_ascii_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "LLMSelector",
    "parameters": [
      "self",
      "node",
      "previous_attempts",
      "n_iterations",
      "require_feedback"
    ],
    "calls": [
      "generate_ascii_tree",
      "generate_ascii_tree",
      "Message",
      "self.completion.create_text_completion",
      "print",
      "Completion",
      "print",
      "self.get_action_definitions",
      "parse_value",
      "parse_explanation",
      "NodeSelection",
      "logger.error",
      "re.findall",
      "strip",
      "logger.error",
      "hasattr",
      "node.completions.keys",
      "int",
      "ValueError",
      "response_text.split",
      "str"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 755,
      "end_line": 863
    },
    "code_snippet": "def build_ascii_tree(\n        self,\n        node: Node,\n        previous_attempts: str = \"\",\n        n_iterations: int = 0,\n        require_feedback: bool = True,\n    ) -> NodeSelection:\n        # Generate ASCII tree representation\n        ascii_tree = generate_ascii_tree(\n            node,\n            include_explanation=True,\n            use_color=False,\n            include_diffs=True,\n            include_action_details=False,\n            include_file_context=False,\n        )\n\n        # also p..."
  },
  {
    "name": "select",
    "docstring": "",
    "is_method": true,
    "class_name": "LLMSelector",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "len",
      "range",
      "logger.warning",
      "len",
      "self.build_ascii_tree",
      "logger.warning"
    ],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 865,
      "end_line": 904
    },
    "code_snippet": "def select(self, nodes: List[Node]) -> Node:\n        if len(nodes) == 1:\n            return nodes[0]\n\n        max_retries = 3\n        n_iterations = len(nodes)\n        available_node_ids = [node.node_id for node in nodes]\n        previous_attempts = \"\"\n\n        for attempt in range(max_retries):\n            # Get the selection from LLM, now passing n_iterations\n            selection = self.build_ascii_tree(nodes[0], previous_attempts, n_iterations)\n\n            # Find and return the selected nod..."
  },
  {
    "name": "format_examples",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "examples"
    ],
    "calls": [
      "enumerate",
      "join",
      "formatted.append"
    ],
    "code_location": {
      "file": "prompt.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 1,
      "end_line": 8
    },
    "code_snippet": "def format_examples(examples):\n    formatted = []\n    for i, example in enumerate(examples, 1):\n        header = f\"Example {i}:\\n\\n\"\n        node_id = f\"<node_id>: {i}\\n\"\n        feedback = f\"<feedback>: {example}\"\n        formatted.append(header + node_id + feedback)\n    return \"\\n\\n\".join(formatted)"
  },
  {
    "name": "calculate_similarity",
    "docstring": "Calculates the similarity score between the two FileContext instances.\n\nReturns:\n    float: The similarity score between 0 and 1.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "context_a",
      "context_b"
    ],
    "calls": [
      "set",
      "set",
      "jaccard_similarity",
      "files_a.intersection",
      "files_a.intersection",
      "context_a._files.keys",
      "context_b._files.keys",
      "jaccard_similarity",
      "span_similarities.append",
      "span_similarities.append",
      "sum",
      "len",
      "string_similarity",
      "patch_similarities.append",
      "patch_similarities.append",
      "sum",
      "len"
    ],
    "code_location": {
      "file": "similarity.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 7,
      "end_line": 58
    },
    "code_snippet": "def calculate_similarity(context_a: FileContext, context_b: FileContext) -> float:\n    \"\"\"\n    Calculates the similarity score between the two FileContext instances.\n\n    Returns:\n        float: The similarity score between 0 and 1.\n    \"\"\"\n    # Step 1: File path similarity\n    files_a = set(context_a._files.keys())\n    files_b = set(context_b._files.keys())\n    file_path_similarity = jaccard_similarity(files_a, files_b)\n\n    # Step 2: Span similarity\n    span_similarities = []\n    for file_pat..."
  },
  {
    "name": "jaccard_similarity",
    "docstring": "Calculates the Jaccard similarity between two sets.\n\nReturns:\n    float: Jaccard similarity score.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "set1",
      "set2"
    ],
    "calls": [
      "set1.intersection",
      "set1.union",
      "len",
      "len"
    ],
    "code_location": {
      "file": "similarity.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 61,
      "end_line": 72
    },
    "code_snippet": "def jaccard_similarity(set1: Set, set2: Set) -> float:\n    \"\"\"\n    Calculates the Jaccard similarity between two sets.\n\n    Returns:\n        float: Jaccard similarity score.\n    \"\"\"\n    intersection = set1.intersection(set2)\n    union = set1.union(set2)\n    if not union:\n        return 1.0  # Both sets are empty\n    return len(intersection) / len(union)"
  },
  {
    "name": "string_similarity",
    "docstring": "Calculates the similarity between two strings using difflib.\n\nReturns:\n    float: Similarity score between 0 and 1.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "s1",
      "s2"
    ],
    "calls": [
      "difflib.SequenceMatcher",
      "matcher.ratio"
    ],
    "code_location": {
      "file": "similarity.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 75,
      "end_line": 85
    },
    "code_snippet": "def string_similarity(s1: str, s2: str) -> float:\n    \"\"\"\n    Calculates the similarity between two strings using difflib.\n\n    Returns:\n        float: Similarity score between 0 and 1.\n    \"\"\"\n    if not s1 and not s2:\n        return 1.0  # Both strings are empty\n    matcher = difflib.SequenceMatcher(None, s1, s2)\n    return matcher.ratio()"
  },
  {
    "name": "select",
    "docstring": "Select a node based on existing feedback analysis.",
    "is_method": true,
    "class_name": "FeedbackSelector",
    "parameters": [
      "self",
      "nodes"
    ],
    "calls": [
      "max",
      "hasattr",
      "logger.warning",
      "logger.info"
    ],
    "code_location": {
      "file": "feedback_selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 18,
      "end_line": 48
    },
    "code_snippet": "def select(self, nodes: List[Node]) -> Optional[Node]:\n        \"\"\"Select a node based on existing feedback analysis.\"\"\"\n        if not nodes:\n            return None\n\n        for node in nodes:\n            # Check for existing feedback in node.completions\n            if hasattr(node, \"completions\") and \"feedback\" in node.completions:\n                feedback_completion: Completion = node.completions[\"feedback\"]\n                if feedback_completion and feedback_completion.response:\n            ..."
  },
  {
    "name": "__post_init__",
    "docstring": "",
    "is_method": true,
    "class_name": "ToolCall",
    "parameters": [
      "self"
    ],
    "calls": [
      "str"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 25,
      "end_line": 27
    },
    "code_snippet": "def __post_init__(self):\n        # Ensure name is always a string\n        self.name = str(self.name)"
  },
  {
    "name": "tool_call_id",
    "docstring": "Generate a deterministic tool call ID based on the tool call content",
    "is_method": true,
    "class_name": "AssistantMessage",
    "parameters": [
      "self"
    ],
    "calls": [
      "hexdigest",
      "str",
      "json.dumps",
      "hashlib.sha256",
      "tool_str.encode"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 38,
      "end_line": 47
    },
    "code_snippet": "def tool_call_id(self) -> Optional[str]:\n        \"\"\"Generate a deterministic tool call ID based on the tool call content\"\"\"\n        if not self.tool_call:\n            return None\n\n        # Create a string combining name and input for hashing\n        tool_str = f\"{str(self.tool_call.name)}:{json.dumps(self.tool_call.input, sort_keys=True)}\"\n        # Generate SHA-256 hash and take first 8 characters\n        hash_id = hashlib.sha256(tool_str.encode()).hexdigest()[:8]\n        return f\"call_{hash_i..."
  },
  {
    "name": "from_completion_response",
    "docstring": "",
    "is_method": true,
    "class_name": "Usage",
    "parameters": [
      "cls",
      "completion_response",
      "model"
    ],
    "calls": [
      "logger.debug",
      "usage.get",
      "usage.get",
      "cls",
      "isinstance",
      "hasattr",
      "completion_response.usage.model_dump",
      "usage.get",
      "usage.get",
      "usage.get",
      "usage.get",
      "usage.get",
      "litellm.completion_cost",
      "isinstance",
      "logger.warning",
      "json.dumps",
      "cost_per_token",
      "logger.debug",
      "logger.debug"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 62,
      "end_line": 128
    },
    "code_snippet": "def from_completion_response(\n        cls, completion_response: dict | BaseModel, model: str\n    ) -> Union[\"Usage\", None]:\n        if isinstance(completion_response, BaseModel) and hasattr(\n            completion_response, \"usage\"\n        ):\n            usage = completion_response.usage.model_dump()\n        elif isinstance(completion_response, dict) and \"usage\" in completion_response:\n            usage = completion_response[\"usage\"]\n        else:\n            logger.warning(\n                f\"No..."
  },
  {
    "name": "__add__",
    "docstring": "",
    "is_method": true,
    "class_name": "Usage",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "getattr",
      "getattr",
      "getattr",
      "getattr",
      "Usage"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 130,
      "end_line": 142
    },
    "code_snippet": "def __add__(self, other: \"Usage\") -> \"Usage\":\n        # Get completion cost, defaulting to 0 if not available\n        other_cost = getattr(other, \"completion_cost\", 0)\n        other_completion = getattr(other, \"completion_tokens\", 0)\n        other_prompt = getattr(other, \"prompt_tokens\", 0)\n        other_cached = getattr(other, \"cached_tokens\", 0)\n\n        return Usage(\n            completion_cost=self.completion_cost + other_cost,\n            completion_tokens=self.completion_tokens + other_com..."
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "Usage",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 144,
      "end_line": 150
    },
    "code_snippet": "def __str__(self) -> str:\n        return (\n            f\"Usage(cost: ${self.completion_cost:.4f}, \"\n            f\"completion tokens: {self.completion_tokens}, \"\n            f\"prompt tokens: {self.prompt_tokens}, \"\n            f\"cached tokens: {self.cached_tokens})\"\n        )"
  },
  {
    "name": "fix_null_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "Usage",
    "parameters": [
      "cls",
      "data"
    ],
    "calls": [
      "model_validator",
      "isinstance",
      "data.items"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 154,
      "end_line": 160
    },
    "code_snippet": "def fix_null_tokens(cls, data: Any) -> Any:\n        if isinstance(data, dict):\n            for key, value in data.items():\n                if not value:\n                    data[key] = 0\n\n        return data"
  },
  {
    "name": "from_llm_completion",
    "docstring": "",
    "is_method": true,
    "class_name": "Completion",
    "parameters": [
      "cls",
      "input_messages",
      "completion_response",
      "model",
      "usage",
      "retries",
      "flags"
    ],
    "calls": [
      "isinstance",
      "cls",
      "completion_response.model_dump",
      "isinstance",
      "Usage.from_completion_response",
      "logger.error",
      "type"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 175,
      "end_line": 204
    },
    "code_snippet": "def from_llm_completion(\n        cls,\n        input_messages: list[dict],\n        completion_response: Any,\n        model: str,\n        usage: Usage | None = None,\n        retries: int | None = None,\n        flags: list[str] | None = None,\n    ) -> Optional[\"Completion\"]:\n        if isinstance(completion_response, BaseModel):\n            response = completion_response.model_dump()\n        elif isinstance(completion_response, dict):\n            response = completion_response\n        else:\n       ..."
  },
  {
    "name": "__get__",
    "docstring": "",
    "is_method": true,
    "class_name": "NameDescriptor",
    "parameters": [
      "self",
      "obj",
      "cls"
    ],
    "calls": [
      "hasattr",
      "hasattr"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 208,
      "end_line": 211
    },
    "code_snippet": "def __get__(self, obj, cls=None) -> str:\n        if hasattr(cls, \"Config\") and hasattr(cls.Config, \"title\") and cls.Config.title:\n            return cls.Config.title\n        return cls.__name__"
  },
  {
    "name": "description",
    "docstring": "",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls"
    ],
    "calls": [
      "get",
      "cls.model_json_schema"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 221,
      "end_line": 222
    },
    "code_snippet": "def description(cls):\n        return cls.model_json_schema().get(\"description\", \"\")"
  },
  {
    "name": "openai_schema",
    "docstring": "Return the schema in the format of OpenAI's schema as jsonschema",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls",
      "thoughts_in_action"
    ],
    "calls": [
      "cls.model_json_schema",
      "parse",
      "remove_defaults",
      "sorted",
      "get",
      "isinstance",
      "obj.items",
      "parameters.pop",
      "resolve_refs",
      "schema.items",
      "obj.values",
      "isinstance",
      "isinstance",
      "isinstance",
      "remove_defaults",
      "isinstance",
      "ref_path.startswith",
      "resolve_refs",
      "isinstance",
      "items",
      "remove_defaults",
      "ref_path.startswith",
      "ref_path.split",
      "copy",
      "ref_path.split",
      "copy",
      "referenced.update",
      "resolve_refs",
      "isinstance",
      "resolve_refs",
      "obj.items"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 225,
      "end_line": 332
    },
    "code_snippet": "def openai_schema(cls, thoughts_in_action: bool = False) -> dict[str, Any]:\n        \"\"\"\n        Return the schema in the format of OpenAI's schema as jsonschema\n        \"\"\"\n        schema = cls.model_json_schema()\n        docstring = parse(cls.__doc__ or \"\")\n        parameters = {\n            k: v\n            for k, v in schema.items()\n            if k not in (\"title\", \"description\")\n            and (thoughts_in_action or k != \"thoughts\")\n        }\n\n        if not thoughts_in_action and paramete..."
  },
  {
    "name": "anthropic_schema",
    "docstring": "",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls"
    ],
    "calls": [
      "cls.model_json_schema",
      "schema.get",
      "remove"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 335,
      "end_line": 359
    },
    "code_snippet": "def anthropic_schema(cls) -> dict[str, Any]:\n        schema = cls.model_json_schema()\n        del schema[\"title\"]\n\n        if \"description\" in schema:\n            description = schema[\"description\"]\n            del schema[\"description\"]\n        else:\n            description = None\n\n        response = {\n            \"name\": cls.name,\n            \"input_schema\": schema,\n        }\n\n        if description:\n            response[\"description\"] = description\n\n        # Exclude thoughts field from proper..."
  },
  {
    "name": "model_validate_xml",
    "docstring": "Parse XML format into model fields.",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls",
      "xml_text"
    ],
    "calls": [
      "cls.model_validate",
      "xml_text.index",
      "xml_text.index",
      "len",
      "content.startswith",
      "content.endswith",
      "rstrip"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 362,
      "end_line": 384
    },
    "code_snippet": "def model_validate_xml(cls, xml_text: str) -> Self:\n        \"\"\"Parse XML format into model fields.\"\"\"\n        parsed_input = {}\n        # Fields that can be parsed from XML format\n        xml_fields = [\"path\", \"old_str\", \"new_str\", \"file_text\", \"insert_line\"]\n\n        for field in xml_fields:\n            start_tag = f\"<{field}>\"\n            end_tag = f\"</{field}>\"\n            if start_tag in xml_text and end_tag in xml_text:\n                start_idx = xml_text.index(start_tag) + len(start_tag)\n..."
  },
  {
    "name": "model_validate_json",
    "docstring": "",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls",
      "json_data"
    ],
    "calls": [
      "ValidationError",
      "isinstance",
      "json.loads",
      "unescape_values",
      "json.dumps",
      "model_validate_json",
      "strip",
      "isinstance",
      "logger.warning",
      "join",
      "replace",
      "extract_json_from_message",
      "isinstance",
      "logger.debug",
      "model_validate_json",
      "isinstance",
      "super",
      "logger.info",
      "replace",
      "json_data.strip",
      "unescape_values",
      "message.replace",
      "len",
      "logger.warning",
      "super",
      "isinstance",
      "json.dumps",
      "obj.items",
      "unescape_values",
      "isinstance",
      "decode",
      "message.replace",
      "repr",
      "repr",
      "repr",
      "obj.encode",
      "ord"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 387,
      "end_line": 448
    },
    "code_snippet": "def model_validate_json(\n        cls,\n        json_data: str | bytes | bytearray,\n        **kwarg,\n    ) -> Self:\n        if not json_data:\n            raise ValidationError(\"Message is empty\")\n\n        try:\n            if isinstance(json_data,str):\n                json_data = json_data.strip(\"```json\\n\").strip(\"\\n```\")\n            parsed_data = json.loads(json_data, strict=False)\n\n            def unescape_values(obj):\n                if isinstance(obj, dict):\n                    return {k: unes..."
  },
  {
    "name": "format_args_for_llm",
    "docstring": "Format the input arguments for LLM completion calls. Override in subclasses for custom formats.\nDefault implementation returns JSON format.",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "self"
    ],
    "calls": [
      "json.dumps",
      "self.model_dump",
      "hasattr"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 450,
      "end_line": 460
    },
    "code_snippet": "def format_args_for_llm(self) -> str:\n        \"\"\"\n        Format the input arguments for LLM completion calls. Override in subclasses for custom formats.\n        Default implementation returns JSON format.\n        \"\"\"\n        return json.dumps(\n            self.model_dump(\n                exclude={\"thoughts\"} if hasattr(self, \"thoughts\") else None\n            ),\n            indent=2,\n        )"
  },
  {
    "name": "format_schema_for_llm",
    "docstring": "Format the schema description for LLM completion calls.\nDefault implementation returns JSON schema.",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls",
      "thoughts_in_action"
    ],
    "calls": [
      "cls.model_json_schema",
      "get",
      "sorted",
      "json.dumps",
      "items"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 463,
      "end_line": 478
    },
    "code_snippet": "def format_schema_for_llm(cls, thoughts_in_action: bool = False) -> str:\n        \"\"\"\n        Format the schema description for LLM completion calls.\n        Default implementation returns JSON schema.\n        \"\"\"\n        schema = cls.model_json_schema()\n\n        if not thoughts_in_action and schema[\"properties\"].get(\"thoughts\"):\n            del schema[\"properties\"][\"thoughts\"]\n            schema[\"required\"] = sorted(\n                k\n                for k, v in schema[\"properties\"].items()\n    ..."
  },
  {
    "name": "format_xml_schema",
    "docstring": "Format XML schema description.\nUsed by actions that require XML-formatted input.\n\nArgs:\n    xml_fields: Dictionary mapping field names to their descriptions",
    "is_method": true,
    "class_name": "StructuredOutput",
    "parameters": [
      "cls",
      "xml_fields"
    ],
    "calls": [
      "xml_fields.items",
      "join",
      "example.append"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 481,
      "end_line": 496
    },
    "code_snippet": "def format_xml_schema(cls, xml_fields: dict[str, str]) -> str:\n        \"\"\"\n        Format XML schema description.\n        Used by actions that require XML-formatted input.\n\n        Args:\n            xml_fields: Dictionary mapping field names to their descriptions\n        \"\"\"\n        schema = [f\"Requires the following XML format:\"]\n\n        # Build example XML structure\n        example = []\n        for field_name, field_desc in xml_fields.items():\n            example.append(f\"<{field_name}>{field..."
  },
  {
    "name": "extract_json_from_message",
    "docstring": "Extract JSON from a message, handling both code blocks and raw JSON.\nReturns a tuple of (selected_json_dict, all_found_json_dicts).",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "message"
    ],
    "calls": [
      "json_str.split",
      "join",
      "rstrip",
      "join",
      "message.find",
      "message.find",
      "clean_json_string",
      "logger.warning",
      "message.find",
      "range",
      "logger.warning",
      "lines.append",
      "strip",
      "json.loads",
      "max",
      "len",
      "max",
      "isinstance",
      "all",
      "all_found_jsons.append",
      "clean_json_string",
      "json.loads",
      "split",
      "isinstance",
      "all",
      "all_found_jsons.append",
      "isinstance",
      "len",
      "len",
      "ord",
      "json_dict.keys",
      "isinstance",
      "line.split",
      "json_dict.keys"
    ],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 499,
      "end_line": 579
    },
    "code_snippet": "def extract_json_from_message(message: str) -> tuple[dict | str, list[dict]]:\n    \"\"\"\n    Extract JSON from a message, handling both code blocks and raw JSON.\n    Returns a tuple of (selected_json_dict, all_found_json_dicts).\n    \"\"\"\n\n    def clean_json_string(json_str: str) -> str:\n        # Remove single-line comments and clean control characters\n        lines = []\n        for line in json_str.split(\"\\n\"):\n            # Remove everything after // or #\n            line = line.split(\"//\")[0].spl..."
  },
  {
    "name": "create",
    "docstring": "",
    "is_method": true,
    "class_name": "CompletionResponse",
    "parameters": [
      "cls",
      "text",
      "output",
      "completion"
    ],
    "calls": [
      "isinstance",
      "cls",
      "isinstance"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 39,
      "end_line": 54
    },
    "code_snippet": "def create(\n        cls,\n        text: str | None = None,\n        output: List[StructuredOutput] | StructuredOutput | None = None,\n        completion: Completion | None = None,\n    ) -> \"CompletionResponse\":\n        if isinstance(output, StructuredOutput):\n            outputs = [output]\n        elif isinstance(output, list):\n            outputs = output\n        else:\n            outputs = None\n\n        return cls(\n            text_response=text, structured_outputs=outputs, completion=completion\n..."
  },
  {
    "name": "structured_output",
    "docstring": "Get the first structured output",
    "is_method": true,
    "class_name": "CompletionResponse",
    "parameters": [
      "self"
    ],
    "calls": [
      "len",
      "logger.warning"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 57,
      "end_line": 66
    },
    "code_snippet": "def structured_output(self) -> Optional[StructuredOutput]:\n        \"\"\"Get the first structured output\"\"\"\n        if len(self.structured_outputs) > 1:\n            ignored_outputs = [\n                output.__class__.__name__ for output in self.structured_outputs[1:]\n            ]\n            logger.warning(\n                f\"Multiple structured outputs found in completion response, returning {self.structured_outputs[0].__class__.__name__} and ignoring: {ignored_outputs}\"\n            )\n        ret..."
  },
  {
    "name": "clone",
    "docstring": "Create a copy of the completion model with optional parameter overrides.\n\nArgs:\n    **kwargs: Parameters to override in the cloned model\n\nReturns:\n    A new CompletionModel instance with the specified overrides",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.model_dump",
      "model_data.update",
      "CompletionModel.model_validate"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 101,
      "end_line": 112
    },
    "code_snippet": "def clone(self, **kwargs) -> \"CompletionModel\":\n        \"\"\"Create a copy of the completion model with optional parameter overrides.\n\n        Args:\n            **kwargs: Parameters to override in the cloned model\n\n        Returns:\n            A new CompletionModel instance with the specified overrides\n        \"\"\"\n        model_data = self.model_dump()\n        model_data.update(kwargs)\n        return CompletionModel.model_validate(model_data)"
  },
  {
    "name": "create_completion",
    "docstring": "",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "self",
      "messages",
      "system_prompt",
      "response_model"
    ],
    "calls": [
      "dedent",
      "messages.insert",
      "tenacity.Retrying",
      "CompletionRuntimeError",
      "isinstance",
      "retries",
      "len",
      "CompletionRuntimeError",
      "Field",
      "Field",
      "model_validator",
      "tenacity.retry_if_not_exception_type",
      "tenacity.stop_after_attempt",
      "tenacity.wait_exponential",
      "print",
      "self._litellm_base_completion",
      "print",
      "isinstance",
      "print",
      "messages.append",
      "response_model.model_validate_json",
      "print",
      "Completion.from_llm_completion",
      "hasattr",
      "CompletionResponse.create",
      "e.reraise",
      "hasattr",
      "tuple",
      "print",
      "data.get",
      "next",
      "data.get",
      "action_class.model_validate",
      "json.dumps",
      "CompletionRuntimeError",
      "message.content.model_dump",
      "CompletionRuntimeError",
      "CompletionResponse.create",
      "logger.warning",
      "messages.append",
      "CompletionRejectError",
      "logger.exception",
      "CompletionRuntimeError",
      "isinstance",
      "ValidationError",
      "ValidationError",
      "ValidationError",
      "response_model.model_json_schema",
      "str",
      "join"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 114,
      "end_line": 259
    },
    "code_snippet": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        if not response_model:\n            raise CompletionRuntimeError(f\"Response model is required for completion\")\n\n        if isinstance(response_model, list) and len(response_model) > 1:\n            avalabile_actions = [\n                action for action in response_model if hasattr(action, ..."
  },
  {
    "name": "_litellm_base_completion",
    "docstring": "Base method for making litellm completion calls with common parameters.\n\nArgs:\n    messages: List of message dictionaries\n    tools: Optional list of tool definitions for function calling\n    tool_choice: Optional tool choice configuration\n    response_format: Optional response format configuration\n\nReturns:\n    The completion response from litellm",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "self",
      "messages",
      "tools",
      "tool_choice",
      "response_format"
    ],
    "calls": [
      "tenacity.retry",
      "litellm.completion",
      "_do_completion",
      "tenacity.stop_after_attempt",
      "tenacity.wait_exponential",
      "tenacity.retry_if_exception_type",
      "e.last_attempt.exception",
      "isinstance",
      "logger.warning",
      "logger.error",
      "logger.warning",
      "str",
      "retry_state.outcome.exception"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 261,
      "end_line": 329
    },
    "code_snippet": "def _litellm_base_completion(\n        self,\n        messages: list[dict],\n        tools: list[dict] | None = None,\n        tool_choice: str | None = None,\n        response_format: dict | None = None,\n    ) -> Any:\n        \"\"\"Base method for making litellm completion calls with common parameters.\n\n        Args:\n            messages: List of message dictionaries\n            tools: Optional list of tool definitions for function calling\n            tool_choice: Optional tool choice configuration\n   ..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 331,
      "end_line": 337
    },
    "code_snippet": "def model_dump(self, **kwargs):\n        dump = super().model_dump(**kwargs)\n        if \"model_api_key\" in dump:\n            dump[\"model_api_key\"] = None\n        if \"response_format\" in dump:\n            dump[\"response_format\"] = dump[\"response_format\"].value\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "cls",
      "isinstance",
      "LLMResponseFormat",
      "AnthtropicCompletionModel",
      "ToolCallCompletionModel",
      "ReActCompletionModel"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 340,
      "end_line": 356
    },
    "code_snippet": "def model_validate(cls, obj):\n        if isinstance(obj, dict) and \"response_format\" in obj:\n            if \"claude-3-5\" in obj[\"model\"]:\n                from moatless_qa.completion.anthropic import AnthtropicCompletionModel\n                return AnthtropicCompletionModel(**obj)\n\n            response_format = LLMResponseFormat(obj[\"response_format\"])\n            obj[\"response_format\"] = response_format\n\n            if response_format == LLMResponseFormat.TOOLS:\n                from moatless_qa...."
  },
  {
    "name": "set_api_key",
    "docstring": "Update the model with the API key from en vars if model base URL is set but API key is not as we don't persist the API key.",
    "is_method": true,
    "class_name": "CompletionModel",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_validator",
      "os.getenv"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 359,
      "end_line": 366
    },
    "code_snippet": "def set_api_key(self) -> \"CompletionModel\":\n        \"\"\"\n        Update the model with the API key from en vars if model base URL is set but API key is not as we don't persist the API key.\n        \"\"\"\n        if self.model_base_url and not self.model_api_key:\n            self.model_api_key = os.getenv(\"CUSTOM_LLM_API_KEY\")\n\n        return self"
  },
  {
    "name": "supports_anthropic_computer_use",
    "docstring": "",
    "is_method": true,
    "class_name": "AnthtropicCompletionModel",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "anthropic.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 30,
      "end_line": 31
    },
    "code_snippet": "def supports_anthropic_computer_use(self):\n        return \"claude-3-5-sonnet-20241022\" in self.model"
  },
  {
    "name": "create_completion",
    "docstring": "",
    "is_method": true,
    "class_name": "AnthtropicCompletionModel",
    "parameters": [
      "self",
      "messages",
      "system_prompt",
      "response_model"
    ],
    "calls": [
      "Usage",
      "anthropic_messages_pt",
      "tenacity.Retrying",
      "isinstance",
      "AnthropicBedrock",
      "Anthropic",
      "_inject_prompt_caching",
      "retries",
      "hasattr",
      "msg.model_dump",
      "action.anthropic_schema",
      "tools.append",
      "tenacity.retry_if_not_exception_type",
      "tenacity.stop_after_attempt",
      "anthropic_client.beta.messages.create",
      "Usage.from_completion_response",
      "Completion.from_llm_completion",
      "bool",
      "CompletionResponse",
      "e.reraise",
      "logger.info",
      "logger.info",
      "logger.warning",
      "messages.append",
      "messages.append",
      "CompletionRejectError",
      "CompletionRuntimeError",
      "len",
      "isinstance",
      "isinstance",
      "action.model_validate",
      "structured_outputs.append",
      "text.strip",
      "self._create_user_message",
      "len",
      "ValueError",
      "isinstance",
      "isinstance",
      "logger.warning",
      "str",
      "json.dumps",
      "block.model_dump",
      "completion_response.model_dump"
    ],
    "code_location": {
      "file": "anthropic.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 33,
      "end_line": 214
    },
    "code_snippet": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        # Convert Message objects to dictionaries if needed\n        messages = [\n            msg.model_dump() if hasattr(msg, \"model_dump\") else msg for msg in messages\n        ]\n\n        total_usage = Usage()\n        retry_count = 0\n\n        tools = []\n        tool_choice = {\"type\": \"any\"}\n\n    ..."
  },
  {
    "name": "_inject_prompt_caching",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "messages"
    ],
    "calls": [
      "reversed",
      "isinstance",
      "BetaCacheControlEphemeralParam",
      "pop"
    ],
    "code_location": {
      "file": "anthropic.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 217,
      "end_line": 243
    },
    "code_snippet": "def _inject_prompt_caching(\n    messages: list[\n        Union[\n            \"AnthropicMessagesUserMessageParam\", \"AnthopicMessagesAssistantMessageParam\"\n        ]\n    ],\n):\n    from anthropic.types.beta import BetaCacheControlEphemeralParam\n\n    \"\"\"\n    Set cache breakpoints for the 3 most recent turns\n    one cache breakpoint is left for tools/system prompt, to be shared across sessions\n    \"\"\"\n\n    breakpoints_remaining = 3\n    for message in reversed(messages):\n        # message[\"role\"] == \"us..."
  },
  {
    "name": "create_completion",
    "docstring": "",
    "is_method": true,
    "class_name": "ReActCompletionModel",
    "parameters": [
      "self",
      "messages",
      "system_prompt",
      "response_model"
    ],
    "calls": [
      "Usage",
      "dedent",
      "messages.insert",
      "tenacity.Retrying",
      "action_input_schemas.append",
      "self._litellm_base_completion",
      "Usage.from_completion_response",
      "retries",
      "tenacity.retry_if_not_exception_type",
      "tenacity.stop_after_attempt",
      "self._validate_react_format",
      "response_text.find",
      "response_text.find",
      "strip",
      "strip",
      "action_input.split",
      "strip",
      "strip",
      "next",
      "Completion.from_llm_completion",
      "CompletionResponse",
      "e.reraise",
      "join",
      "ValueError",
      "len",
      "ValueError",
      "ValueError",
      "startswith",
      "startswith",
      "logger.warning",
      "messages.append",
      "messages.append",
      "CompletionRejectError",
      "action.format_schema_for_llm",
      "action_class.model_validate_xml",
      "action_class.model_validate_json",
      "action_input.strip",
      "action_input.strip",
      "ValueError",
      "action_class.model_json_schema",
      "ValueError",
      "str",
      "join",
      "hasattr",
      "action_class.format_schema_for_llm",
      "json.dumps"
    ],
    "code_location": {
      "file": "react.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 18,
      "end_line": 160
    },
    "code_snippet": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]],\n    ) -> CompletionResponse:\n        action_input_schemas = []\n\n        total_usage = Usage()\n        retry_count = 0\n\n        for action in response_model:\n            action_input_schemas.append(\n                f\" * {action.name} {action.format_schema_for_llm()}\"\n            )\n\n        system_prompt += dedent(f\"\"\"\\n# Response format\n\nUse the foll..."
  },
  {
    "name": "_validate_react_format",
    "docstring": "",
    "is_method": true,
    "class_name": "ReActCompletionModel",
    "parameters": [
      "self",
      "response_text"
    ],
    "calls": [
      "sum",
      "sum",
      "next",
      "next",
      "line.strip",
      "logger.warning",
      "ValueError",
      "ValueError",
      "response_text.split",
      "line.strip",
      "line.startswith",
      "line.startswith",
      "enumerate",
      "line.startswith",
      "enumerate",
      "line.startswith"
    ],
    "code_location": {
      "file": "react.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 162,
      "end_line": 190
    },
    "code_snippet": "def _validate_react_format(self, response_text: str):\n        # Split into lines and remove empty ones\n        lines = [line.strip() for line in response_text.split(\"\\n\") if line.strip()]\n\n        # Count occurrences of each section\n        thought_count = sum(1 for line in lines if line.startswith(\"Thought:\"))\n        action_count = sum(1 for line in lines if line.startswith(\"Action:\"))\n\n        # Check for multiple action blocks\n        if thought_count > 1 or action_count > 1:\n            log..."
  },
  {
    "name": "create_completion",
    "docstring": "",
    "is_method": true,
    "class_name": "ToolCallCompletionModel",
    "parameters": [
      "self",
      "messages",
      "system_prompt",
      "response_model"
    ],
    "calls": [
      "isinstance",
      "Usage",
      "messages.insert",
      "tenacity.Retrying",
      "tools.extend",
      "retries",
      "tools.append",
      "tenacity.retry_if_not_exception_type",
      "tenacity.stop_after_attempt",
      "print",
      "self._litellm_base_completion",
      "Usage.from_completion_response",
      "set",
      "set",
      "Completion.from_llm_completion",
      "CompletionResponse.create",
      "e.reraise",
      "r.openai_schema",
      "response_model.openai_schema",
      "CompletionRuntimeError",
      "isinstance",
      "ValueError",
      "logger.warning",
      "messages.append",
      "CompletionRejectError",
      "get_response_model",
      "seen_arguments.add",
      "action.model_validate_json",
      "response_objects.append",
      "ValueError",
      "list",
      "logger.warning",
      "invalid_function_names.append",
      "logger.warning",
      "flags.add",
      "str"
    ],
    "code_location": {
      "file": "tool_call.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 21,
      "end_line": 159
    },
    "code_snippet": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        tools = []\n\n        if isinstance(response_model, list):\n            tools.extend(\n                [\n                    r.openai_schema(thoughts_in_action=self.thoughts_in_action)\n                    for r in response_model\n                ]\n            )\n        elif response_model:\n   ..."
  },
  {
    "name": "get_reward",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self._create_message",
      "self._build_system_prompt",
      "logger.warning",
      "self.completion_model.create_completion",
      "Reward",
      "logger.error",
      "logger.error"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 85,
      "end_line": 121
    },
    "code_snippet": "def get_reward(self, node: Node) -> Tuple[Optional[Reward], Optional[Completion]]:\n        if node.action.name != \"Finish\":\n            logger.warning(\n                f\"TerminalValueFunction can only evaluate finished solutions, but got action {node.action.name}\"\n            )\n            return None, None\n\n        user_message = self._create_message(node)\n        messages = [user_message]\n        system_prompt = self._build_system_prompt(node)\n\n        try:\n            response_model = (\n     ..."
  },
  {
    "name": "_show_existing_solutions",
    "docstring": "Format existing solutions with node IDs below current. Returns True if any solutions were found.",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "node.get_root",
      "root_node.get_leaf_nodes",
      "enumerate",
      "solution_node.get_trajectory",
      "solution_node.file_context.create_prompt",
      "n.is_finished",
      "solution_node.file_context.is_empty"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 123,
      "end_line": 179
    },
    "code_snippet": "def _show_existing_solutions(self, node: Node) -> bool:\n        \"\"\"Format existing solutions with node IDs below current. Returns True if any solutions were found.\"\"\"\n        root_node = node.get_root()\n        leaf_nodes = root_node.get_leaf_nodes()\n\n        # Filter for finished nodes with lower IDs\n        existing_solutions = [\n            n for n in leaf_nodes if n.is_finished() and n.node_id < node.node_id\n        ]\n\n        if not existing_solutions:\n            return False\n\n        atte..."
  },
  {
    "name": "_create_message",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "ChatCompletionUserMessage",
      "node.get_trajectory",
      "node.get_root",
      "node.get_root",
      "root_node.get_leaf_nodes",
      "any",
      "join",
      "self._show_existing_solutions",
      "node.file_context.create_prompt",
      "previous_node.action.to_prompt",
      "node.file_context.is_empty",
      "formatted_history.append",
      "logger.warning",
      "n.is_finished"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 181,
      "end_line": 246
    },
    "code_snippet": "def _create_message(self, node: Node) -> ChatCompletionUserMessage:\n        previous_nodes = node.get_trajectory()[:-1]\n\n        message = node.get_root().message\n\n        # Add history if enabled\n        if self.show_history:\n            formatted_history: List[str] = []\n            counter = 0\n            for previous_node in previous_nodes:\n                if previous_node.action:\n                    counter += 1\n                    formatted_state = (\n                        f\"\\n## {counter}..."
  },
  {
    "name": "_build_system_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "Action.get_action_by_args_class",
      "len",
      "action.get_evaluation_criteria",
      "action.get_reward_scale",
      "action.get_reward_range",
      "ValueFunction._format_evaluation_criteria",
      "ValueFunction._format_reward_scale",
      "type",
      "node.get_trajectory"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 248,
      "end_line": 311
    },
    "code_snippet": "def _build_system_prompt(self, node: Node):\n        action = Action.get_action_by_args_class(type(node.action))\n        trajectory_length = len(node.get_trajectory())\n\n        prompt = \"\"\"You are evaluating a finished solution to determine how well it solves the original task.\n\nYour role is to evaluate the CURRENT solution independently\"\"\"\n\n        if self.show_previous_solutions:\n            prompt += \", while using previous attempts for context and comparison\"\n        prompt += \".\\n\\n\"\n\n      ..."
  },
  {
    "name": "_format_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "criteria_list"
    ],
    "calls": [],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 314,
      "end_line": 318
    },
    "code_snippet": "def _format_evaluation_criteria(criteria_list: List[str]) -> str:\n        formatted_criteria = \"\\n# Evaluation Criteria:\\n\"\n        for criterion in criteria_list:\n            formatted_criteria += f\"* {criterion}\\n\"\n        return formatted_criteria"
  },
  {
    "name": "_format_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "reward_scale_list",
      "min_value",
      "max_value"
    ],
    "calls": [
      "sorted"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 321,
      "end_line": 335
    },
    "code_snippet": "def _format_reward_scale(\n        reward_scale_list: List[RewardScaleEntry], min_value: int, max_value: int\n    ) -> str:\n        formatted_scale = \"\\n# Reward Scale and Guidelines:\\n\"\n        sorted_entries = sorted(reward_scale_list, key=lambda x: -x.max_value)\n\n        formatted_scale += f\"The reward value must be an integer between {min_value} and {max_value}, where:\\n\\n\"\n\n        for entry in sorted_entries:\n            if entry.min_value == entry.max_value:\n                formatted_scale ..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "self.completion_model.model_dump",
      "self.coding_value_function.model_dump",
      "super"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 337,
      "end_line": 347
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion_model\"] = self.completion_model.model_dump(**kwargs)\n        dump[\"value_function_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        if self.coding_value_function:\n            dump[\"coding_value_function\"] = self.coding_value_function.model_dump(\n                **kwargs\n            )\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "TerminalValueFunction",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "obj.pop",
      "CompletionModel.model_validate",
      "value_function_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "value_function_class",
      "cls",
      "super"
    ],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 350,
      "end_line": 373
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"TerminalValueFunction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion_model\", None)\n            value_function_class_path = obj.pop(\"value_function_class\", None)\n\n            if completion_data:\n                obj[\"completion_model\"] = CompletionModel.model_validate(\n                    completion_data\n                )\n            else:\n                obj[\"completion_model\"] = None\n\n      ..."
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodingValueFunction",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "TerminalValueFunction",
      "super"
    ],
    "code_location": {
      "file": "coding.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 39,
      "end_line": 43
    },
    "code_snippet": "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._terminal_function = TerminalValueFunction(\n            completion_model=self.completion_model\n        )"
  },
  {
    "name": "get_reward",
    "docstring": "",
    "is_method": true,
    "class_name": "CodingValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "logger.warning",
      "max",
      "logger.info",
      "logger.info",
      "self._terminal_function.get_reward",
      "logger.info",
      "node.observation.properties.get",
      "isinstance",
      "values",
      "Reward",
      "Reward",
      "Reward",
      "logger.info",
      "FAILURE_REWARDS.items",
      "Reward",
      "Reward",
      "node.observation.properties.get",
      "Reward",
      "node.observation.properties.get",
      "file.get",
      "len",
      "len",
      "Reward",
      "Reward",
      "Reward",
      "Reward"
    ],
    "code_location": {
      "file": "coding.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 45,
      "end_line": 131
    },
    "code_snippet": "def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        if node.observation.expect_correction and self.correction_award is not None:\n            # Start with the base correction award\n            correction_penalty = 0\n            current_node = node.parent\n\n            # Check parent nodes for expect_correction\n            while (\n                current_node\n                and current_node.observation\n                and current_node.observation.expect_correction\n    ..."
  },
  {
    "name": "get_reward",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.message_generator.generate",
      "self._create_system_prompt",
      "self.coding_value_function.get_reward",
      "node.action.to_prompt",
      "node.parent.file_context.is_empty",
      "node.file_context.create_prompt",
      "generate_ascii_tree",
      "messages.append",
      "self.completion_model.create_completion",
      "node.get_root",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "logger.error"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 38,
      "end_line": 129
    },
    "code_snippet": "def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        # First get coding value function result if enabled\n        coding_reward = None\n        if self.coding_value_function:\n            coding_reward, _ = self.coding_value_function.get_reward(node)\n\n        messages = self.message_generator.generate(node)\n        if messages is None:\n            messages = []  # Ensure we have a valid list\n        last_message = \"\"\n        # Handle automatic reward cases by adding them..."
  },
  {
    "name": "_create_system_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "self",
      "node",
      "coding_reward"
    ],
    "calls": [
      "self._build_system_prompt",
      "format"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 131,
      "end_line": 163
    },
    "code_snippet": "def _create_system_prompt(\n        self, node: Node, coding_reward: Optional[Reward] = None\n    ) -> str:\n        base_prompt = self._build_system_prompt(node)\n\n        if coding_reward:\n            base_prompt += \"\"\"\n# Coding Value Function Context\n<coding_assessment>\nThe automated coding value function has provided the following assessment:\n* Value: {coding_reward.value}\n* Explanation: {coding_reward.explanation}\nIt's based on coding heuristics, and may not be perfect.\n\nEvaluation Guidelines:\n..."
  },
  {
    "name": "_build_system_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "Action.get_action_by_args_class",
      "len",
      "action.get_value_function_prompt",
      "action.get_evaluation_criteria",
      "action.get_reward_scale",
      "action.get_reward_range",
      "ValueFunction._format_evaluation_criteria",
      "ValueFunction._format_reward_scale",
      "type",
      "node.get_trajectory",
      "Action.get_action_by_name",
      "action.args_schema.model_json_schema",
      "logger.error"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 165,
      "end_line": 207
    },
    "code_snippet": "def _build_system_prompt(self, node: Node):\n        action = Action.get_action_by_args_class(type(node.action))\n        trajectory_length = len(node.get_trajectory())\n\n        base_prompt = action.get_value_function_prompt()\n\n        criteria_list = action.get_evaluation_criteria(trajectory_length)\n        reward_scale_list = action.get_reward_scale(trajectory_length)\n        min_value, max_value = action.get_reward_range(trajectory_length)\n\n        evaluation_criteria_text = ValueFunction._form..."
  },
  {
    "name": "_format_evaluation_criteria",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "criteria_list"
    ],
    "calls": [],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 210,
      "end_line": 214
    },
    "code_snippet": "def _format_evaluation_criteria(criteria_list: List[str]) -> str:\n        formatted_criteria = \"\\n# Evaluation Criteria:\\n\"\n        for criterion in criteria_list:\n            formatted_criteria += f\"* {criterion}\\n\"\n        return formatted_criteria"
  },
  {
    "name": "_format_reward_scale",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "reward_scale_list",
      "min_value",
      "max_value"
    ],
    "calls": [
      "sorted"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 217,
      "end_line": 231
    },
    "code_snippet": "def _format_reward_scale(\n        reward_scale_list: List[RewardScaleEntry], min_value: int, max_value: int\n    ) -> str:\n        formatted_scale = \"\\n# Reward Scale and Guidelines:\\n\"\n        sorted_entries = sorted(reward_scale_list, key=lambda x: -x.max_value)\n\n        formatted_scale += f\"The reward value must be an integer between {min_value} and {max_value}, where:\\n\\n\"\n\n        for entry in sorted_entries:\n            if entry.min_value == entry.max_value:\n                formatted_scale ..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "self.completion_model.model_dump",
      "self.coding_value_function.model_dump",
      "super"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 233,
      "end_line": 243
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion_model\"] = self.completion_model.model_dump(**kwargs)\n        dump[\"value_function_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        if self.coding_value_function:\n            dump[\"coding_value_function\"] = self.coding_value_function.model_dump(\n                **kwargs\n            )\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "obj.pop",
      "obj.pop",
      "CompletionModel.model_validate",
      "CodingValueFunction.model_validate",
      "value_function_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "value_function_class",
      "cls",
      "super"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 246,
      "end_line": 277
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"ValueFunction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion_model\", None)\n            value_function_class_path = obj.pop(\"value_function_class\", None)\n            coding_value_function_data = obj.pop(\"coding_value_function\", None)\n\n            if completion_data:\n                obj[\"completion_model\"] = CompletionModel.model_validate(\n                    completion_data\n                )\n..."
  },
  {
    "name": "_combine_rewards",
    "docstring": "Combine two rewards by averaging their values and concatenating explanations.",
    "is_method": true,
    "class_name": "ValueFunction",
    "parameters": [
      "self",
      "reward1",
      "reward2"
    ],
    "calls": [
      "Reward"
    ],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 279,
      "end_line": 287
    },
    "code_snippet": "def _combine_rewards(self, reward1: Reward, reward2: Reward) -> Reward:\n        \"\"\"Combine two rewards by averaging their values and concatenating explanations.\"\"\"\n        combined_value = (reward1.value + reward2.value) // 2  # Integer division\n        combined_explanation = (\n            \"Combined Assessment:\\n\"\n            f\"1. General Assessment: {reward1.explanation}\\n\"\n            f\"2. Code Quality Assessment: {reward2.explanation}\"\n        )\n        return Reward(value=combined_value, exp..."
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "Repo",
      "data.get",
      "logger.error",
      "checkout_commit",
      "super"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 24,
      "end_line": 37
    },
    "code_snippet": "def __init__(self, **data):\n        super().__init__(**data)\n        from git import Repo\n\n        self._repo = Repo(path=self.repo_path)\n\n        if not self._repo.heads:\n            logger.error(f\"Repo at {self.repo_path} has no branches\")\n\n        if data.get(\"commit\"):\n            checkout_commit(self.repo_path, data[\"commit\"])\n\n        self.current_commit = self._repo.head.commit.hexsha\n        self.initial_commit = self.current_commit"
  },
  {
    "name": "from_repo",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "cls",
      "git_repo_url",
      "repo_path",
      "commit"
    ],
    "calls": [
      "logger.info",
      "os.path.exists",
      "cls",
      "clone_and_checkout",
      "maybe_clone",
      "subprocess.run",
      "cls",
      "logger.warning",
      "shutil.rmtree",
      "logger.warning",
      "shutil.rmtree",
      "subprocess.run",
      "subprocess.run",
      "cls",
      "logger.warning",
      "shutil.rmtree"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 40,
      "end_line": 95
    },
    "code_snippet": "def from_repo(cls, git_repo_url: str, repo_path: str, commit: Optional[str] = None):\n        logger.info(\n            f\"Create GitRepository for {git_repo_url} with commit {commit} on path {repo_path} \"\n        )\n        \n        # 检查目标路径是否存在，如果存在但有问题则删除\n        if os.path.exists(repo_path):\n            try:\n                # 尝试检查这是否是一个有效的git仓库\n                import subprocess\n                result = subprocess.run(\n                    [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\n           ..."
  },
  {
    "name": "from_dict",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "cls",
      "data"
    ],
    "calls": [
      "cls.from_repo"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 98,
      "end_line": 103
    },
    "code_snippet": "def from_dict(cls, data: dict):\n        return cls.from_repo(\n            git_repo_url=data[\"repo_url\"],\n            repo_path=data[\"path\"],\n            commit=data[\"commit\"],\n        )"
  },
  {
    "name": "restore_from_snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "snapshot"
    ],
    "calls": [
      "snapshot.get",
      "self.clean_untracked_files",
      "self._repo.git.reset",
      "self._repo.git.checkout",
      "logger.error"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 105,
      "end_line": 116
    },
    "code_snippet": "def restore_from_snapshot(self, snapshot: dict):\n        self.current_commit = snapshot[\"commit\"]\n\n        if snapshot.get(\"patch\"):\n            self.current_diff = snapshot[\"patch\"]\n\n        try:\n            self.clean_untracked_files()\n            self._repo.git.reset(\"--hard\", \"HEAD\")  # Discard all local changes\n            self._repo.git.checkout(\"-f\", self.current_commit)  # Force checkout\n        except Exception as e:\n            logger.error(f\"Error checking out commit {self.current_com..."
  },
  {
    "name": "clean_untracked_files",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self"
    ],
    "calls": [
      "self._repo.git.clean",
      "logger.info",
      "logger.error"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 120,
      "end_line": 125
    },
    "code_snippet": "def clean_untracked_files(self):\n        try:\n            self._repo.git.clean(\"-fd\")\n            logger.info(\"Removed all untracked files.\")\n        except Exception as e:\n            logger.error(f\"Error removing untracked files: {e}\")"
  },
  {
    "name": "dict",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 127,
      "end_line": 133
    },
    "code_snippet": "def dict(self):\n        return {\n            \"type\": \"git\",\n            \"repo_path\": self.repo_path,\n            \"git_repo_url\": self.repo_url,\n            \"commit\": self.initial_commit,\n        }"
  },
  {
    "name": "snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.diff"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 135,
      "end_line": 139
    },
    "code_snippet": "def snapshot(self) -> dict:\n        return {\n            \"commit\": self.current_commit,\n            \"patch\": self.diff(),\n        }"
  },
  {
    "name": "create_empty_file",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "create_empty_file",
      "self.commit",
      "super"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 141,
      "end_line": 143
    },
    "code_snippet": "def create_empty_file(self, file_path: str):\n        super().create_empty_file(file_path)\n        self.commit(file_path)"
  },
  {
    "name": "save_file",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "file_path",
      "updated_content"
    ],
    "calls": [
      "save_file",
      "self.commit",
      "super"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 145,
      "end_line": 148
    },
    "code_snippet": "def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        file = super().save_file(file_path, updated_content)\n        self.commit(file_path)\n        return file"
  },
  {
    "name": "commit",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.commit_message",
      "self._repo.index.commit",
      "logger.info",
      "self.clean_untracked_files",
      "self._repo.index.add",
      "self._repo.index.add",
      "logger.error",
      "logger.error",
      "os.chdir",
      "logger.info",
      "self._repo.index.commit",
      "logger.info",
      "self._repo.index.add",
      "self._repo.index.add",
      "logger.error"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 150,
      "end_line": 188
    },
    "code_snippet": "def commit(self, file_path: str | None = None):\n        commit_message = self.commit_message(file_path)\n\n        try:\n            if file_path:\n                self._repo.index.add([file_path])\n            else:\n                self._repo.index.add(\"*\")\n            self._repo.index.commit(commit_message)\n            self.current_commit = self._repo.head.commit.hexsha\n\n            logger.info(\n                f\"Committed changes to git with message '{commit_message}' and commit hash '{self.curren..."
  },
  {
    "name": "commit_message",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self._repo.git.diff",
      "self._repo.git.diff",
      "self.completion.create_text_completion",
      "message.content.strip",
      "logging.error",
      "ChatCompletionUserMessage"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 190,
      "end_line": 213
    },
    "code_snippet": "def commit_message(self, file_path: str | None = None) -> str:\n        if file_path:\n            diff = self._repo.git.diff(\"HEAD\", file_path)\n        else:\n            diff = self._repo.git.diff(\"HEAD\")\n\n        if not diff:\n            return \"No changes.\"\n\n        if self.completion and self.generate_commit_message:\n            prompt = f\"Generate a concise commit message for the following git diff\"\n            if file_path:\n                prompt += f\" of file {file_path}\"\n            prompt..."
  },
  {
    "name": "diff",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self",
      "ignore_paths"
    ],
    "calls": [
      "logger.info",
      "self._repo.git.diff",
      "self._repo.git.diff",
      "logger.info",
      "logger.error"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 215,
      "end_line": 236
    },
    "code_snippet": "def diff(self, ignore_paths: Optional[List[str]] = None):\n        logger.info(f\"Get diff between {self.initial_commit} and {self.current_commit}\")\n\n        if ignore_paths:\n            exclude_patterns = [f\":(exclude){path}\" for path in ignore_paths]\n            diff_command = [\n                self.initial_commit,\n                self.current_commit,\n                \"--\",\n            ] + exclude_patterns\n            return self._repo.git.diff(*diff_command)\n        else:\n            try:\n      ..."
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "GitRepository",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "dump.update",
      "super"
    ],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 238,
      "end_line": 247
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump.update(\n            {\n                \"repo_path\": self.repo_path,\n                \"git_repo_url\": self.repo_url,\n                \"commit\": self.initial_commit,\n            }\n        )\n        return dump"
  },
  {
    "name": "get_file_content",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 10,
      "end_line": 11
    },
    "code_snippet": "def get_file_content(self, file_path: str) -> Optional[str]:\n        pass"
  },
  {
    "name": "file_exists",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 13,
      "end_line": 14
    },
    "code_snippet": "def file_exists(self, file_path: str) -> bool:\n        return True"
  },
  {
    "name": "save_file",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self",
      "file_path",
      "updated_content"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 16,
      "end_line": 17
    },
    "code_snippet": "def save_file(self, file_path: str, updated_content: str):\n        pass"
  },
  {
    "name": "is_directory",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 19,
      "end_line": 20
    },
    "code_snippet": "def is_directory(self, file_path: str) -> bool:\n        return False"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 22,
      "end_line": 27
    },
    "code_snippet": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"repository_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "repository_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "repository_class",
      "super"
    ],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 30,
      "end_line": 45
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"Repository\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            repository_class_path = obj.pop(\"repository_class\", None)\n\n            if repository_class_path:\n                module_name, class_name = repository_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                repository_class = getattr(module, class_name)\n                instance = repository_class(**obj)\n            else:\n    ..."
  },
  {
    "name": "list_directory",
    "docstring": "Lists files and directories in the specified directory.\nReturns a dictionary with 'files' and 'directories' lists.",
    "is_method": true,
    "class_name": "Repository",
    "parameters": [
      "self",
      "directory_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 48,
      "end_line": 53
    },
    "code_snippet": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        \"\"\"\n        Lists files and directories in the specified directory.\n        Returns a dictionary with 'files' and 'directories' lists.\n        \"\"\"\n        pass"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "files"
    ],
    "calls": [
      "__init__",
      "super"
    ],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 59,
      "end_line": 61
    },
    "code_snippet": "def __init__(self, files: Dict[str, str] = None, **kwargs):\n        files = files or {}\n        super().__init__(files=files, **kwargs)"
  },
  {
    "name": "get_file_content",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.files.get"
    ],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 63,
      "end_line": 64
    },
    "code_snippet": "def get_file_content(self, file_path: str) -> Optional[str]:\n        return self.files.get(file_path)"
  },
  {
    "name": "file_exists",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 66,
      "end_line": 67
    },
    "code_snippet": "def file_exists(self, file_path: str) -> bool:\n        return file_path in self.files"
  },
  {
    "name": "save_file",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "file_path",
      "updated_content"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 69,
      "end_line": 70
    },
    "code_snippet": "def save_file(self, file_path: str, updated_content: str):\n        self.files[file_path] = updated_content"
  },
  {
    "name": "is_directory",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 72,
      "end_line": 73
    },
    "code_snippet": "def is_directory(self, file_path: str) -> bool:\n        return False"
  },
  {
    "name": "list_directory",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self",
      "directory_path"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 75,
      "end_line": 76
    },
    "code_snippet": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        return {\"files\": [], \"directories\": []}"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 78,
      "end_line": 79
    },
    "code_snippet": "def model_dump(self) -> Dict:\n        return {\"files\": self.files}"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "InMemRepository",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "cls",
      "obj.get"
    ],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 82,
      "end_line": 83
    },
    "code_snippet": "def model_validate(cls, obj: Dict):\n        return cls(files=obj.get(\"files\", {}))"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "kwargs.get",
      "kwargs.get",
      "kwargs.get",
      "kwargs.get",
      "super"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 29,
      "end_line": 34
    },
    "code_snippet": "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._content = kwargs.get(\"_content\", \"\")\n        self._repo_path = kwargs.get(\"repo_path\", None)\n        self._module = kwargs.get(\"_module\", None)\n        self._last_modified = kwargs.get(\"_last_modified\", None)"
  },
  {
    "name": "from_file",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "cls",
      "repo_path",
      "file_path"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 37,
      "end_line": 38
    },
    "code_snippet": "def from_file(cls, repo_path: str, file_path: str):\n        return cls(file_path=file_path, repo_path=repo_path)"
  },
  {
    "name": "from_content",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "cls",
      "file_path",
      "content"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 41,
      "end_line": 42
    },
    "code_snippet": "def from_content(cls, file_path: str, content: str):\n        return cls(file_path=file_path, _content=content)"
  },
  {
    "name": "get_file_content",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 44,
      "end_line": 45
    },
    "code_snippet": "def get_file_content(self, file_path: str) -> Optional[str]:\n        return"
  },
  {
    "name": "has_been_modified",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "ValueError",
      "os.path.join",
      "datetime.fromtimestamp",
      "os.path.getmtime",
      "logger.debug",
      "logger.warning"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 47,
      "end_line": 65
    },
    "code_snippet": "def has_been_modified(self) -> bool:\n        if not self._repo_path:\n            raise ValueError(\"CodeFile must be initialized with a repo path\")\n\n        try:\n            full_file_path = os.path.join(self._repo_path, self.file_path)\n            current_mod_time = datetime.fromtimestamp(os.path.getmtime(full_file_path))\n            is_modified = (\n                self._last_modified is None or current_mod_time > self._last_modified\n            )\n            if is_modified and self._last_modifi..."
  },
  {
    "name": "save",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self",
      "updated_content"
    ],
    "calls": [
      "os.path.join",
      "open",
      "f.write",
      "datetime.fromtimestamp",
      "os.path.getmtime"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 67,
      "end_line": 73
    },
    "code_snippet": "def save(self, updated_content: str):\n        full_file_path = os.path.join(self._repo_path, self.file_path)\n        with open(full_file_path, \"w\") as f:\n            f.write(updated_content)\n            self._content = updated_content\n            self._last_modified = datetime.fromtimestamp(os.path.getmtime(f.name))\n            self._module = None"
  },
  {
    "name": "supports_codeblocks",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 76,
      "end_line": 77
    },
    "code_snippet": "def supports_codeblocks(self):\n        return self.module is not None"
  },
  {
    "name": "content",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.has_been_modified",
      "open",
      "f.read",
      "datetime.fromtimestamp",
      "os.path.join",
      "os.path.getmtime"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 80,
      "end_line": 87
    },
    "code_snippet": "def content(self):\n        if self.has_been_modified():\n            with open(os.path.join(self._repo_path, self.file_path)) as f:\n                self._content = f.read()\n                self._last_modified = datetime.fromtimestamp(os.path.getmtime(f.name))\n                self._module = None\n\n        return self._content"
  },
  {
    "name": "module",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeFile",
    "parameters": [
      "self"
    ],
    "calls": [
      "get_parser_by_path",
      "self.has_been_modified",
      "self.content.strip",
      "parser.parse"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 90,
      "end_line": 98
    },
    "code_snippet": "def module(self) -> Module | None:\n        if self._module is None or self.has_been_modified() and self.content.strip():\n            parser = get_parser_by_path(self.file_path)\n            if parser:\n                self._module = parser.parse(self.content)\n            else:\n                return None\n\n        return self._module"
  },
  {
    "name": "repo_dir",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 105,
      "end_line": 106
    },
    "code_snippet": "def repo_dir(self):\n        return self.repo_path"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 108,
      "end_line": 109
    },
    "code_snippet": "def model_dump(self) -> Dict:\n        return {\"type\": \"file\", \"repo_path\": self.repo_path}"
  },
  {
    "name": "get_full_path",
    "docstring": "Generates the full file path by combining repo_path and file_path.\nAll paths are treated as relative to repo_path, even if they start with '/'.\n\nArgs:\n    file_path: The file path to process (e.g., 'file.py' or '/src/file.py')\n\nReturns:\n    str: The full path relative to repo_path",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "file_path.lstrip",
      "file_path.startswith",
      "file_path.startswith",
      "os.path.join",
      "lstrip",
      "file_path.replace",
      "file_path.startswith",
      "file_path.replace",
      "file_path.replace"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 111,
      "end_line": 135
    },
    "code_snippet": "def get_full_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the full file path by combining repo_path and file_path.\n        All paths are treated as relative to repo_path, even if they start with '/'.\n\n        Args:\n            file_path: The file path to process (e.g., 'file.py' or '/src/file.py')\n\n        Returns:\n            str: The full path relative to repo_path\n        \"\"\"\n        # Strip leading slash if present\n        file_path = file_path.lstrip(\"/\")\n\n        # If f..."
  },
  {
    "name": "get_relative_path",
    "docstring": "Generates the relative path by removing repo_path from the full path.\n\nArgs:\n    file_path: The file path to process\n\nReturns:\n    str: The relative path",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.get_full_path",
      "lstrip",
      "full_path.replace"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 137,
      "end_line": 149
    },
    "code_snippet": "def get_relative_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the relative path by removing repo_path from the full path.\n\n        Args:\n            file_path: The file path to process\n\n        Returns:\n            str: The relative path\n        \"\"\"\n\n        full_path = self.get_full_path(file_path)\n        return full_path.replace(self.repo_path, \"\").lstrip(\"/\")"
  },
  {
    "name": "get_file_content",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.get_full_path",
      "os.path.exists",
      "open",
      "f.read"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 151,
      "end_line": 156
    },
    "code_snippet": "def get_file_content(self, file_path: str) -> str | None:\n        full_path = self.get_full_path(file_path)\n        if os.path.exists(full_path):\n            with open(full_path) as f:\n                return f.read()\n        return None"
  },
  {
    "name": "snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 158,
      "end_line": 159
    },
    "code_snippet": "def snapshot(self) -> dict:\n        return {}"
  },
  {
    "name": "restore_from_snapshot",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "snapshot"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 161,
      "end_line": 162
    },
    "code_snippet": "def restore_from_snapshot(self, snapshot: dict):\n        pass"
  },
  {
    "name": "path",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 165,
      "end_line": 166
    },
    "code_snippet": "def path(self):\n        return self.repo_path"
  },
  {
    "name": "is_directory",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "path"
    ],
    "calls": [
      "os.path.isdir",
      "self.get_full_path"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 168,
      "end_line": 169
    },
    "code_snippet": "def is_directory(self, path: str):\n        return os.path.isdir(self.get_full_path(path))"
  },
  {
    "name": "get_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "file_path.startswith",
      "self.get_full_path",
      "CodeFile.from_file",
      "file_path.replace",
      "file_path.startswith",
      "os.path.exists",
      "logger.debug",
      "os.path.isfile",
      "logger.warning"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 171,
      "end_line": 187
    },
    "code_snippet": "def get_file(self, file_path: str):\n        if file_path.startswith(self.repo_dir):\n            file_path = file_path.replace(self.repo_dir, \"\")\n            if file_path.startswith(\"/\"):\n                file_path = file_path[1:]\n\n        full_file_path = self.get_full_path(file_path)\n        if not os.path.exists(full_file_path):\n            logger.debug(f\"File not found: {full_file_path}\")\n            return None\n\n        if not os.path.isfile(full_file_path):\n            logger.warning(f\"{full..."
  },
  {
    "name": "file_exists",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "Path",
      "full_path.exists",
      "self.get_full_path"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 189,
      "end_line": 191
    },
    "code_snippet": "def file_exists(self, file_path: str):\n        full_path = Path(self.get_full_path(file_path))\n        return full_path.exists()"
  },
  {
    "name": "create_empty_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path"
    ],
    "calls": [
      "self.get_full_path",
      "os.path.exists",
      "logger.info",
      "os.makedirs",
      "open",
      "f.write",
      "os.path.dirname",
      "os.path.dirname"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 193,
      "end_line": 200
    },
    "code_snippet": "def create_empty_file(self, file_path: str):\n        full_file_path = self.get_full_path(file_path)\n        if not os.path.exists(os.path.dirname(full_file_path)):\n            logger.info(f\"Creating directory for {full_file_path}\")\n            os.makedirs(os.path.dirname(full_file_path))\n\n        with open(full_file_path, \"w\") as f:\n            f.write(\"\")"
  },
  {
    "name": "save_file",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_path",
      "updated_content"
    ],
    "calls": [
      "self.file_exists",
      "self.create_empty_file",
      "open",
      "f.write",
      "self.get_full_path"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 202,
      "end_line": 209
    },
    "code_snippet": "def save_file(self, file_path: str, updated_content: str):\n        assert updated_content, \"Updated content must be provided\"\n\n        if not self.file_exists(file_path):\n            file = self.create_empty_file(file_path)\n\n        with open(self.get_full_path(file_path), \"w\") as f:\n            f.write(updated_content)"
  },
  {
    "name": "matching_files",
    "docstring": "Returns a list of files matching the given pattern within the repository.\n\nParameters:\n    file_pattern (str): The glob pattern to match files.\n\nReturns:\n    List[str]: A list of relative file paths matching the pattern.",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_pattern"
    ],
    "calls": [
      "file_pattern.startswith",
      "file_pattern.split",
      "any",
      "Path",
      "repo_path.glob",
      "logger.warning",
      "filename.replace",
      "join",
      "path.is_file",
      "logger.exception",
      "len",
      "join",
      "replace",
      "matched_files.append",
      "file_pattern.startswith",
      "dir_pattern.startswith",
      "str",
      "path.relative_to"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 211,
      "end_line": 281
    },
    "code_snippet": "def matching_files(self, file_pattern: str):\n        \"\"\"\n        Returns a list of files matching the given pattern within the repository.\n\n        Parameters:\n            file_pattern (str): The glob pattern to match files.\n\n        Returns:\n            List[str]: A list of relative file paths matching the pattern.\n        \"\"\"\n\n        try:\n            # If absolute path, log warning and remove first slash\n            if file_pattern.startswith(\"/\"):\n                logger.warning(\n            ..."
  },
  {
    "name": "find_files",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_patterns"
    ],
    "calls": [
      "set",
      "self.matching_files",
      "found_files.update"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 283,
      "end_line": 289
    },
    "code_snippet": "def find_files(self, file_patterns: list[str]) -> set[str]:\n        found_files = set()\n        for file_pattern in file_patterns:\n            matched_files = self.matching_files(file_pattern)\n            found_files.update(matched_files)\n\n        return found_files"
  },
  {
    "name": "has_matching_files",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_pattern"
    ],
    "calls": [
      "glob.iglob"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 291,
      "end_line": 296
    },
    "code_snippet": "def has_matching_files(self, file_pattern: str):\n        for _matched_file in glob.iglob(\n            file_pattern, root_dir=self.repo_path, recursive=True\n        ):\n            return True\n        return False"
  },
  {
    "name": "file_match",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "file_pattern",
      "file_path"
    ],
    "calls": [
      "glob.iglob"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 298,
      "end_line": 306
    },
    "code_snippet": "def file_match(self, file_pattern: str, file_path: str):\n        match = False\n        for matched_file in glob.iglob(\n            file_pattern, root_dir=self.repo_path, recursive=True\n        ):\n            if matched_file == file_path:\n                match = True\n                break\n        return match"
  },
  {
    "name": "find_by_pattern",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "patterns"
    ],
    "calls": [
      "matched_files.extend",
      "glob.iglob"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 308,
      "end_line": 314
    },
    "code_snippet": "def find_by_pattern(self, patterns: list[str]) -> List[str]:\n        matched_files = []\n        for pattern in patterns:\n            matched_files.extend(\n                glob.iglob(f\"**/{pattern}\", root_dir=self.repo_path, recursive=True)\n            )\n        return matched_files"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 316,
      "end_line": 320
    },
    "code_snippet": "def model_dump(self) -> Dict:\n        return {\n            \"type\": \"file\",\n            \"path\": self.repo_path,\n        }"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "cls"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 323,
      "end_line": 325
    },
    "code_snippet": "def model_validate(cls, obj: Dict):\n        repo = cls(repo_path=obj[\"path\"])\n        return repo"
  },
  {
    "name": "find_exact_matches",
    "docstring": "Uses grep to search for exact text matches in files.",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "search_text",
      "file_pattern"
    ],
    "calls": [
      "logger.info",
      "replace",
      "logger.info",
      "logger.info",
      "subprocess.run",
      "logger.info",
      "result.stdout.splitlines",
      "logger.info",
      "logger.info",
      "grep_pattern.split",
      "replace",
      "logger.warning",
      "line.split",
      "matches.append",
      "len",
      "join",
      "len",
      "len",
      "logger.info",
      "os.path.isfile",
      "int",
      "file_path.startswith",
      "int",
      "logger.info",
      "replace",
      "result.stdout.splitlines",
      "os.path.join",
      "int",
      "replace",
      "replace",
      "replace",
      "replace",
      "replace",
      "replace",
      "replace",
      "search_text.replace"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 327,
      "end_line": 412
    },
    "code_snippet": "def find_exact_matches(\n        self, search_text: str, file_pattern: Optional[str] = None\n    ) -> List[tuple[str, int]]:\n        \"\"\"\n        Uses grep to search for exact text matches in files.\n        \"\"\"\n        matches = []\n        if not file_pattern:\n            file_pattern = \".\"\n\n        try:\n            # Remove '**' and everything after it\n            grep_pattern = file_pattern\n            if \"**\" in grep_pattern:\n                grep_pattern = grep_pattern.split(\"**\")[0]\n\n          ..."
  },
  {
    "name": "list_directory",
    "docstring": "Lists files and directories in the specified directory.\nReturns a dictionary with 'files' and 'directories' lists.",
    "is_method": true,
    "class_name": "FileRepository",
    "parameters": [
      "self",
      "directory_path"
    ],
    "calls": [
      "self.get_full_path",
      "os.listdir",
      "os.path.exists",
      "os.path.isdir",
      "os.path.join",
      "replace",
      "os.path.isfile",
      "sorted",
      "sorted",
      "files.append",
      "os.path.isdir",
      "os.path.relpath",
      "directories.append"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 414,
      "end_line": 441
    },
    "code_snippet": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        \"\"\"\n        Lists files and directories in the specified directory.\n        Returns a dictionary with 'files' and 'directories' lists.\n        \"\"\"\n        full_path = self.get_full_path(directory_path)\n\n        if not os.path.exists(full_path):\n            return {\"files\": [], \"directories\": []}\n\n        if not os.path.isdir(full_path):\n            return {\"files\": [], \"directories\": []}\n\n        files = []\n     ..."
  },
  {
    "name": "remove_duplicate_lines",
    "docstring": "Removes overlapping lines at the end of replacement_lines that match the beginning of original_lines.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "replacement_lines",
      "original_lines"
    ],
    "calls": [
      "min",
      "range",
      "len",
      "len"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 444,
      "end_line": 457
    },
    "code_snippet": "def remove_duplicate_lines(replacement_lines, original_lines):\n    \"\"\"\n    Removes overlapping lines at the end of replacement_lines that match the beginning of original_lines.\n    \"\"\"\n    if not replacement_lines or not original_lines:\n        return replacement_lines\n\n    max_overlap = min(len(replacement_lines), len(original_lines))\n\n    for overlap in range(max_overlap, 0, -1):\n        if replacement_lines[-overlap:] == original_lines[:overlap]:\n            return replacement_lines[:-overlap..."
  },
  {
    "name": "do_diff",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "file_path",
      "original_content",
      "updated_content"
    ],
    "calls": [
      "join",
      "difflib.unified_diff",
      "splitlines",
      "splitlines",
      "original_content.strip",
      "updated_content.strip"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 460,
      "end_line": 471
    },
    "code_snippet": "def do_diff(\n    file_path: str, original_content: str, updated_content: str\n) -> Optional[str]:\n    return \"\".join(\n        difflib.unified_diff(\n            original_content.strip().splitlines(True),\n            updated_content.strip().splitlines(True),\n            fromfile=file_path,\n            tofile=file_path,\n            lineterm=\"\\n\",\n        )\n    )"
  },
  {
    "name": "supports_codeblocks",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "path"
    ],
    "calls": [
      "path.endswith"
    ],
    "code_location": {
      "file": "__init__.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 8,
      "end_line": 9
    },
    "code_snippet": "def supports_codeblocks(path: str):\n    return path.endswith(\".py\")"
  },
  {
    "name": "get_parser_by_path",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "file_path"
    ],
    "calls": [
      "file_path.endswith",
      "PythonParser",
      "file_path.endswith",
      "JavaParser"
    ],
    "code_location": {
      "file": "__init__.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 12,
      "end_line": 18
    },
    "code_snippet": "def get_parser_by_path(file_path: str) -> CodeParser | None:\n    if file_path.endswith(\".py\"):\n        return PythonParser()\n    elif file_path.endswith(\".java\"):\n        return JavaParser()\n    else:\n        return None"
  },
  {
    "name": "__post_init__",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 26,
      "end_line": 28
    },
    "code_snippet": "def __post_init__(self):\n        if not self.code_block.type == CodeBlockType.MODULE:\n            self.code_block.type = CodeBlockType.MODULE"
  },
  {
    "name": "__getattr__",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self",
      "name"
    ],
    "calls": [
      "getattr"
    ],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 31,
      "end_line": 32
    },
    "code_snippet": "def __getattr__(self, name):\n        return getattr(self.code_block, name)"
  },
  {
    "name": "module",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 35,
      "end_line": 36
    },
    "code_snippet": "def module(self) -> \"Module\":  # noqa: F821\n        return self"
  },
  {
    "name": "find_span_by_id",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "self.spans_by_id.get"
    ],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 38,
      "end_line": 39
    },
    "code_snippet": "def find_span_by_id(self, span_id: str) -> BlockSpan | None:\n        return self.spans_by_id.get(span_id)"
  },
  {
    "name": "sum_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [
      "sum",
      "self.spans_by_id.get",
      "child.sum_tokens"
    ],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 41,
      "end_line": 51
    },
    "code_snippet": "def sum_tokens(self, span_ids: set[str] | None = None):\n        tokens = self.tokens\n        if span_ids:\n            for span_id in span_ids:\n                span = self.spans_by_id.get(span_id)\n                if span:\n                    tokens += span.tokens\n            return tokens\n\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens"
  },
  {
    "name": "show_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self",
      "span_ids",
      "show_related",
      "max_tokens"
    ],
    "calls": [
      "self.spans_by_id.values",
      "set",
      "self.spans.values",
      "logger.info",
      "self.spans_by_id.get",
      "checked_span_ids.add",
      "span_ids_to_check.append",
      "span_ids_to_check.pop",
      "self.find_related_spans",
      "logger.info",
      "span_ids_to_check.append",
      "logger.info",
      "checked_span_ids.add",
      "span_ids_to_check.append",
      "len"
    ],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 53,
      "end_line": 111
    },
    "code_snippet": "def show_spans(\n        self,\n        span_ids: list[str] | None = None,\n        show_related: bool = False,\n        max_tokens: int = 2000,\n    ) -> bool:\n        for span in self.spans_by_id.values():\n            span.visible = False\n\n        checked_span_ids = set()\n        span_ids_to_check = []\n\n        tokens = 0\n        for span_id in span_ids:\n            span = self.spans_by_id.get(span_id)\n            if not span:\n                return False\n\n            tokens += span.tokens\n        ..."
  },
  {
    "name": "find_related_span_ids",
    "docstring": "",
    "is_method": true,
    "class_name": "Module",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "set",
      "self.find_blocks_by_span_id",
      "self.spans_by_id.values",
      "list",
      "list",
      "self._graph.successors",
      "self._graph.predecessors",
      "related_span_ids.add",
      "related_span_ids.add",
      "block.path_string",
      "related_span_ids.add",
      "block.path_string",
      "related_span_ids.add",
      "related_span_ids.add"
    ],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 113,
      "end_line": 149
    },
    "code_snippet": "def find_related_span_ids(self, span_id: Optional[str] = None) -> set[str]:\n        related_span_ids = set()\n\n        blocks = self.find_blocks_by_span_id(span_id)\n        for block in blocks:\n            # Find successors (outgoing relationships)\n            successors = list(self._graph.successors(block.path_string()))\n            for succ in successors:\n                node_data = self._graph.nodes[succ]\n                if \"block\" in node_data:\n                    span = node_data[\"block\"].be..."
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlockTypeGroup",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 31,
      "end_line": 32
    },
    "code_snippet": "def __str__(self):\n        return self.value"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlockType",
    "parameters": [
      "self",
      "value",
      "group"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 74,
      "end_line": 76
    },
    "code_snippet": "def __init__(self, value: str, group: CodeBlockTypeGroup):\n        self._value = value\n        self.group = group"
  },
  {
    "name": "display_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlockType",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 79,
      "end_line": 80
    },
    "code_snippet": "def display_name(self):\n        return self._value"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlockType",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 82,
      "end_line": 83
    },
    "code_snippet": "def __str__(self):\n        return self._value"
  },
  {
    "name": "from_string",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlockType",
    "parameters": [
      "cls",
      "tag"
    ],
    "calls": [
      "tag_to_block_type.get",
      "tag.startswith"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 86,
      "end_line": 109
    },
    "code_snippet": "def from_string(cls, tag: str) -> Optional[\"CodeBlockType\"]:\n        if not tag.startswith(\"definition\"):\n            return None\n\n        tag_to_block_type = {\n            \"definition.assignment\": cls.ASSIGNMENT,\n            \"definition.block_delimiter\": cls.BLOCK_DELIMITER,\n            \"definition.call\": cls.CALL,\n            \"definition.class\": cls.CLASS,\n            \"definition.code\": cls.CODE,\n            \"definition.comment\": cls.COMMENT,\n            \"definition.compound\": cls.COMPOUND,\n  ..."
  },
  {
    "name": "from_block_paths",
    "docstring": "",
    "is_method": true,
    "class_name": "PathTree",
    "parameters": [
      "block_paths"
    ],
    "calls": [
      "PathTree",
      "tree.add_to_tree"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 137,
      "end_line": 142
    },
    "code_snippet": "def from_block_paths(block_paths: list[BlockPath]) -> \"PathTree\":\n        tree = PathTree()\n        for block_path in block_paths:\n            tree.add_to_tree(block_path)\n\n        return tree"
  },
  {
    "name": "child_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "PathTree",
    "parameters": [
      "self",
      "key"
    ],
    "calls": [
      "self.tree.get"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 144,
      "end_line": 145
    },
    "code_snippet": "def child_tree(self, key: str) -> Optional[\"PathTree\"]:\n        return self.tree.get(key, None)"
  },
  {
    "name": "merge",
    "docstring": "",
    "is_method": true,
    "class_name": "PathTree",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "other.tree.items",
      "merge",
      "PathTree"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 147,
      "end_line": 154
    },
    "code_snippet": "def merge(self, other: \"PathTree\"):\n        if other.show:\n            self.show = True\n\n        for key, value in other.tree.items():\n            if key not in self.tree:\n                self.tree[key] = PathTree()\n            self.tree[key].merge(value)"
  },
  {
    "name": "extend_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "PathTree",
    "parameters": [
      "self",
      "paths"
    ],
    "calls": [
      "self.add_to_tree"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 156,
      "end_line": 158
    },
    "code_snippet": "def extend_tree(self, paths: list[list[str]]):\n        for path in paths:\n            self.add_to_tree(path)"
  },
  {
    "name": "add_to_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "PathTree",
    "parameters": [
      "self",
      "path"
    ],
    "calls": [
      "add_to_tree",
      "len",
      "len",
      "PathTree",
      "PathTree"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 160,
      "end_line": 179
    },
    "code_snippet": "def add_to_tree(self, path: list[str]):\n        if path is None:\n            return\n\n        if len(path) == 0:\n            self.show = True\n            return\n\n        if len(path) == 1:\n            if path[0] not in self.tree:\n                self.tree[path[0]] = PathTree(show=True)\n            else:\n                self.tree[path[0]].show = True\n\n            return\n\n        if path[0] not in self.tree:\n            self.tree[path[0]] = PathTree(show=False)\n\n        self.tree[path[0]].add_to_tr..."
  },
  {
    "name": "__post_init__",
    "docstring": "",
    "is_method": true,
    "class_name": "Relationship",
    "parameters": [
      "self"
    ],
    "calls": [
      "ValueError"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 213,
      "end_line": 215
    },
    "code_snippet": "def __post_init__(self):\n        if not self.external_path and not self.path:\n            raise ValueError(\"Cannot create Reference without external_path or path.\")"
  },
  {
    "name": "__hash__",
    "docstring": "",
    "is_method": true,
    "class_name": "Relationship",
    "parameters": [
      "self"
    ],
    "calls": [
      "hash",
      "tuple"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 217,
      "end_line": 218
    },
    "code_snippet": "def __hash__(self):\n        return hash((self.scope, tuple(self.path)))"
  },
  {
    "name": "__eq__",
    "docstring": "",
    "is_method": true,
    "class_name": "Relationship",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 220,
      "end_line": 221
    },
    "code_snippet": "def __eq__(self, other):\n        return (self.scope, self.path) == (other.scope, other.path)"
  },
  {
    "name": "full_path",
    "docstring": "",
    "is_method": true,
    "class_name": "Relationship",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 223,
      "end_line": 224
    },
    "code_snippet": "def full_path(self):\n        return self.external_path + self.path"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "Relationship",
    "parameters": [
      "self"
    ],
    "calls": [
      "join",
      "join"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 226,
      "end_line": 237
    },
    "code_snippet": "def __str__(self):\n        start_node = self.identifier if self.identifier else \"\"\n\n        end_node = \"\"\n        if self.external_path:\n            end_node = \"/\".join(self.external_path)\n        if self.path:\n            if self.external_path:\n                end_node += \"/\"\n            end_node += \".\".join(self.path)\n\n        return f\"({start_node})-[:{self.type.name} {{scope: {self.scope.value}}}]->({end_node})\""
  },
  {
    "name": "block_type",
    "docstring": "",
    "is_method": true,
    "class_name": "BlockSpan",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 267,
      "end_line": 268
    },
    "code_snippet": "def block_type(self):\n        return self.initiating_block.type if self.initiating_block else None"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "BlockSpan",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 270,
      "end_line": 271
    },
    "code_snippet": "def __str__(self):\n        return f\"{self.span_id} ({self.span_type.value}, {self.tokens} tokens)\""
  },
  {
    "name": "get_first_child_block_path",
    "docstring": "",
    "is_method": true,
    "class_name": "BlockSpan",
    "parameters": [
      "self"
    ],
    "calls": [
      "len",
      "len"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 273,
      "end_line": 277
    },
    "code_snippet": "def get_first_child_block_path(self):\n        for block_path in self.block_paths:\n            if len(block_path) == len(self.parent_block_path):\n                continue\n            return block_path"
  },
  {
    "name": "__post_init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.pre_code.split",
      "len"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 310,
      "end_line": 322
    },
    "code_snippet": "def __post_init__(self):\n        self._content_lines = None\n\n        if self.children:\n            for child in self.children:\n                child.parent = self\n\n        if self.pre_code and not self.indentation and not self.pre_lines:\n            pre_code_lines = self.pre_code.split(\"\\n\")\n            self.pre_lines = len(pre_code_lines) - 1\n            self.indentation = (\n                pre_code_lines[-1] if self.pre_lines > 0 else self.pre_code\n            )"
  },
  {
    "name": "content_lines",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.content.split"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 325,
      "end_line": 328
    },
    "code_snippet": "def content_lines(self):\n        if self._content_lines is None:\n            self._content_lines = self.content.split(\"\\n\")\n        return self._content_lines"
  },
  {
    "name": "validate_pre_code",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "ValueError",
      "re.match"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 330,
      "end_line": 335
    },
    "code_snippet": "def validate_pre_code(self):\n        if self.pre_code and not re.match(r\"^[ \\n\\\\]*$\", self.pre_code):\n            raise ValueError(\n                f\"Failed to parse code block with type {self.type} and content `{self.content}`. \"\n                f\"Expected pre_code to only contain spaces and line breaks. Got `{self.pre_code}`\"\n            )"
  },
  {
    "name": "last",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.next.last"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 337,
      "end_line": 340
    },
    "code_snippet": "def last(self):\n        if self.next:\n            return self.next.last()\n        return self"
  },
  {
    "name": "insert_child",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "index",
      "child"
    ],
    "calls": [
      "self.children.insert"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 342,
      "end_line": 347
    },
    "code_snippet": "def insert_child(self, index: int, child: \"CodeBlock\"):\n        if index == 0 and self.children[0].pre_lines == 0:\n            self.children[0].pre_lines = 1\n\n        self.children.insert(index, child)\n        child.parent = self"
  },
  {
    "name": "insert_children",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "index",
      "children"
    ],
    "calls": [
      "self.insert_child"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 349,
      "end_line": 352
    },
    "code_snippet": "def insert_children(self, index: int, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.insert_child(index, child)\n            index += 1"
  },
  {
    "name": "append_child",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "child"
    ],
    "calls": [
      "self.children.append",
      "self.span_ids.update"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 354,
      "end_line": 357
    },
    "code_snippet": "def append_child(self, child: \"CodeBlock\"):\n        self.children.append(child)\n        self.span_ids.update(child.span_ids)\n        child.parent = self"
  },
  {
    "name": "append_children",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "children"
    ],
    "calls": [
      "self.append_child"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 359,
      "end_line": 361
    },
    "code_snippet": "def append_children(self, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.append_child(child)"
  },
  {
    "name": "replace_children",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_index",
      "end_index",
      "children"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 363,
      "end_line": 370
    },
    "code_snippet": "def replace_children(\n        self, start_index: int, end_index: int, children: list[\"CodeBlock\"]\n    ):\n        self.children = (\n            self.children[:start_index] + children + self.children[end_index:]\n        )\n        for child in children:\n            child.parent = self"
  },
  {
    "name": "replace_child",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "index",
      "child"
    ],
    "calls": [
      "self.sync_indentation"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 372,
      "end_line": 379
    },
    "code_snippet": "def replace_child(self, index: int, child: \"CodeBlock\"):\n        # TODO: Do a proper update of everything when replacing child blocks\n        child.pre_code = self.children[index].pre_code\n        child.pre_lines = self.children[index].pre_lines\n        self.sync_indentation(self.children[index], child)\n\n        self.children[index] = child\n        child.parent = self"
  },
  {
    "name": "remove_child",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "index"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 381,
      "end_line": 382
    },
    "code_snippet": "def remove_child(self, index: int):\n        del self.children[index]"
  },
  {
    "name": "sync_indentation",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "original_block",
      "updated_block"
    ],
    "calls": [
      "len",
      "len",
      "len",
      "len",
      "len",
      "updated_block.add_indentation"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 384,
      "end_line": 403
    },
    "code_snippet": "def sync_indentation(self, original_block: \"CodeBlock\", updated_block: \"CodeBlock\"):\n        original_indentation_length = len(original_block.indentation) + len(\n            self.indentation\n        )\n        updated_indentation_length = len(updated_block.indentation) + len(\n            updated_block.parent.indentation\n        )\n\n        # To handle separate code blocks provdided out of context\n        if (\n            original_indentation_length == updated_indentation_length\n            and len..."
  },
  {
    "name": "replace_by_path",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "path",
      "new_block"
    ],
    "calls": [
      "enumerate",
      "len",
      "self.replace_child",
      "child.replace_by_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 405,
      "end_line": 415
    },
    "code_snippet": "def replace_by_path(self, path: list[str], new_block: \"CodeBlock\"):\n        if not path:\n            return\n\n        for i, child in enumerate(self.children):\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    self.replace_child(i, new_block)\n                    return\n                else:\n                    child.replace_by_path(path[1:], new_block)"
  },
  {
    "name": "__str__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 417,
      "end_line": 418
    },
    "code_snippet": "def __str__(self):\n        return f\"{self.display_name} ({self.type.display_name} {self.start_line} - {self.end_line})\""
  },
  {
    "name": "to_string",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self._to_string"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 420,
      "end_line": 421
    },
    "code_snippet": "def to_string(self):\n        return self._to_string()"
  },
  {
    "name": "sum_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "sum",
      "child.sum_tokens"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 423,
      "end_line": 426
    },
    "code_snippet": "def sum_tokens(self):\n        tokens = self.tokens\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens"
  },
  {
    "name": "get_all_child_blocks",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "blocks.append",
      "blocks.extend",
      "child.get_all_child_blocks"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 428,
      "end_line": 433
    },
    "code_snippet": "def get_all_child_blocks(self) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child in self.children:\n            blocks.append(child)\n            blocks.extend(child.get_all_child_blocks())\n        return blocks"
  },
  {
    "name": "get_children",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "exclude_blocks"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 435,
      "end_line": 440
    },
    "code_snippet": "def get_children(\n        self, exclude_blocks: list[CodeBlockType] = None\n    ) -> list[\"CodeBlock\"]:\n        if exclude_blocks is None:\n            exclude_blocks = []\n        return [child for child in self.children if child.type not in exclude_blocks]"
  },
  {
    "name": "show_related_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "self.find_related_spans"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 442,
      "end_line": 448
    },
    "code_snippet": "def show_related_spans(\n        self,\n        span_id: Optional[str] = None,  # TODO: Set max tokens to show\n    ):\n        related_spans = self.find_related_spans(span_id)\n        for span in related_spans:\n            span.visible = True"
  },
  {
    "name": "has_visible_children",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "child.has_visible_children"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 450,
      "end_line": 458
    },
    "code_snippet": "def has_visible_children(self):\n        for child in self.children:\n            if child.is_visible:\n                return True\n\n            if child.has_visible_children():\n                return True\n\n        return False"
  },
  {
    "name": "is_visible",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 461,
      "end_line": 462
    },
    "code_snippet": "def is_visible(self):\n        return self.belongs_to_span and self.belongs_to_span.visible"
  },
  {
    "name": "_to_string",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "enumerate",
      "enumerate",
      "child._to_string"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 464,
      "end_line": 482
    },
    "code_snippet": "def _to_string(self) -> str:\n        contents = \"\"\n\n        if self.pre_lines:\n            contents += \"\\n\" * (self.pre_lines - 1)\n            for i, line in enumerate(self.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + self.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        else:\n            contents += self.pre_code + self.content\n\n        for _i..."
  },
  {
    "name": "_build_path_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_paths",
      "include_references"
    ],
    "calls": [
      "PathTree",
      "block_path.split",
      "path_tree.add_to_tree",
      "self.find_by_path",
      "path_tree.add_to_tree",
      "self._fix_reference_path",
      "self._fix_reference_path",
      "self.get_all_relationships",
      "self.get_all_relationships"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 484,
      "end_line": 522
    },
    "code_snippet": "def _build_path_tree(\n        self, block_paths: list[str], include_references: bool = False\n    ):\n        path_tree = PathTree()\n\n        for block_path in block_paths:\n            if block_path:\n                path = block_path.split(\".\")\n                if include_references:\n                    block = self.find_by_path(path)\n                    if block:\n                        if self.type == CodeBlockType.CLASS:\n                            references = [\n                                ..."
  },
  {
    "name": "to_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "indent",
      "current_span",
      "highlight_spans",
      "only_identifiers",
      "show_full_path",
      "show_tokens",
      "show_spans",
      "debug",
      "exclude_not_highlighted",
      "include_line_numbers",
      "include_types",
      "include_parameters",
      "include_block_delimiters",
      "include_references",
      "include_merge_history"
    ],
    "calls": [
      "enumerate",
      "child.to_tree",
      "self.belongs_to_any_span",
      "join",
      "join",
      "child.has_any_span",
      "str",
      "replace",
      "join",
      "str",
      "self.path_string",
      "self.content.strip"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 524,
      "end_line": 633
    },
    "code_snippet": "def to_tree(\n        self,\n        indent: int = 0,\n        current_span: BlockSpan | None = None,\n        highlight_spans: set[str] | None = None,\n        only_identifiers: bool = False,\n        show_full_path: bool = True,\n        show_tokens: bool = False,\n        show_spans: bool = False,\n        debug: bool = False,\n        exclude_not_highlighted: bool = False,\n        include_line_numbers: bool = False,\n        include_types: list[CodeBlockType] | None = None,\n        include_parameters: ..."
  },
  {
    "name": "_to_prompt_string",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "show_span_id",
      "span_marker",
      "show_line_numbers"
    ],
    "calls": [
      "enumerate",
      "print_line",
      "range",
      "print_line",
      "self.create_comment",
      "print_line"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 635,
      "end_line": 688
    },
    "code_snippet": "def _to_prompt_string(\n        self,\n        show_span_id: bool = False,\n        span_marker: SpanMarker = SpanMarker.COMMENT,\n        show_line_numbers: bool = False,\n    ) -> str:\n        contents = \"\"\n\n        if show_span_id:\n            contents += \"\\n\\n\"\n            if span_marker == SpanMarker.COMMENT:\n                span_comment = self.create_comment(\n                    f\"span_id: {self.belongs_to_span.span_id}\"\n                )\n                contents += f\"{self.indentation}{span_co..."
  },
  {
    "name": "to_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_ids",
      "start_line",
      "end_line",
      "show_outcommented_code",
      "outcomment_code_comment",
      "show_span_id",
      "current_span_id",
      "show_line_numbers",
      "exclude_block_types",
      "include_block_types"
    ],
    "calls": [
      "self._to_prompt_string",
      "enumerate",
      "to_string",
      "child.has_any_span",
      "child.has_blocks_with_types",
      "child.to_prompt",
      "child.has_lines",
      "child.is_within_lines",
      "to_string",
      "child.create_commented_out_block",
      "child.create_commented_out_block"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 690,
      "end_line": 776
    },
    "code_snippet": "def to_prompt(\n        self,\n        span_ids: set[str] | None = None,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        current_span_id: Optional[str] = None,\n        show_line_numbers: bool = False,\n        exclude_block_types: list[CodeBlockType] | None = None,\n        include_block_types: list[CodeBlockType] | None = None,\n    ..."
  },
  {
    "name": "__eq__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "other"
    ],
    "calls": [
      "isinstance",
      "self.full_path",
      "other.full_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 778,
      "end_line": 782
    },
    "code_snippet": "def __eq__(self, other):\n        if not isinstance(other, CodeBlock):\n            return False\n\n        return self.full_path() == other.full_path()"
  },
  {
    "name": "compare_indentation",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "other_block"
    ],
    "calls": [
      "len",
      "len"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 784,
      "end_line": 787
    },
    "code_snippet": "def compare_indentation(self, other_block: \"CodeBlock\"):\n        existing_indentation = len(self.indentation)\n        new_indentation = len(other_block.indentation)\n        return existing_indentation - new_indentation"
  },
  {
    "name": "find_block_by_type",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_type"
    ],
    "calls": [
      "child.find_block_by_type"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 789,
      "end_line": 798
    },
    "code_snippet": "def find_block_by_type(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if self.type == block_type:\n            return self\n\n        for child in self.children:\n            block = child.find_block_by_type(block_type)\n            if block:\n                return block\n\n        return None"
  },
  {
    "name": "find_type_in_parents",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_type"
    ],
    "calls": [
      "self.parent.find_type_in_parents"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 800,
      "end_line": 810
    },
    "code_snippet": "def find_type_in_parents(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type == block_type:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_in_parents(block_type)\n\n        return None"
  },
  {
    "name": "structure_block",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.parent.structure_block"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 812,
      "end_line": 819
    },
    "code_snippet": "def structure_block(self):\n        if self.type.group == CodeBlockTypeGroup.STRUCTURE:\n            return self\n\n        if self.parent:\n            return self.parent.structure_block()\n\n        return None"
  },
  {
    "name": "find_type_group_in_parents",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_type_group"
    ],
    "calls": [
      "self.parent.find_type_group_in_parents"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 821,
      "end_line": 833
    },
    "code_snippet": "def find_type_group_in_parents(\n        self, block_type_group: CodeBlockTypeGroup\n    ) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type.group == block_type_group:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_group_in_parents(block_type_group)\n\n        return None"
  },
  {
    "name": "find_spans_by_line_numbers",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_line",
      "end_line"
    ],
    "calls": [
      "child.find_spans_by_line_numbers",
      "spans.append",
      "self.find_last_by_end_line",
      "spans.append",
      "spans.append"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 835,
      "end_line": 871
    },
    "code_snippet": "def find_spans_by_line_numbers(\n        self, start_line: int, end_line: int | None = None\n    ) -> list[BlockSpan]:\n        spans = []\n        for child in self.children:\n            if end_line is None:\n                end_line = start_line\n\n            if child.end_line < start_line:\n                continue\n\n            if child.start_line > end_line:\n                if not spans:\n                    last_block = self.find_last_by_end_line(end_line)\n                    if last_block:\n       ..."
  },
  {
    "name": "dict",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "dict",
      "super"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 873,
      "end_line": 875
    },
    "code_snippet": "def dict(self, **kwargs):\n        # TODO: Add **kwargs to dict call\n        return super().dict(exclude={\"parent\", \"merge_history\"})"
  },
  {
    "name": "display_name",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.full_path",
      "self.path_string"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 878,
      "end_line": 882
    },
    "code_snippet": "def display_name(self):\n        if self.full_path():\n            return self.path_string()\n        else:\n            return \"<module>\""
  },
  {
    "name": "path_string",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "join",
      "self.full_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 884,
      "end_line": 885
    },
    "code_snippet": "def path_string(self):\n        return \".\".join(self.full_path())"
  },
  {
    "name": "full_path",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "path.extend",
      "path.append",
      "self.parent.full_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 887,
      "end_line": 895
    },
    "code_snippet": "def full_path(self):\n        path = []\n        if self.parent:\n            path.extend(self.parent.full_path())\n\n        if self.identifier:\n            path.append(self.identifier)\n\n        return path"
  },
  {
    "name": "module",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 898,
      "end_line": 901
    },
    "code_snippet": "def module(self) -> \"Module\":  # noqa: F821\n        if self.parent:\n            return self.parent.module\n        return None"
  },
  {
    "name": "root",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "deprecated"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 904,
      "end_line": 905
    },
    "code_snippet": "def root(self) -> \"Module\":  # noqa: F821\n        return self.module"
  },
  {
    "name": "get_blocks",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "has_identifier",
      "include_types"
    ],
    "calls": [
      "blocks.extend",
      "child.get_indexable_blocks"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 907,
      "end_line": 920
    },
    "code_snippet": "def get_blocks(\n        self, has_identifier: bool, include_types: list[CodeBlockType] | None = None\n    ) -> list[\"CodeBlock\"]:\n        blocks = [self]\n\n        for child in self.children:\n            if has_identifier and not child.identifier:\n                continue\n\n            if include_types and child.type not in include_types:\n                continue\n\n            blocks.extend(child.get_indexable_blocks())\n        return blocks"
  },
  {
    "name": "find_reference",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "ref_path"
    ],
    "calls": [
      "child.full_path",
      "self.parent.find_reference",
      "Relationship",
      "Relationship",
      "Relationship",
      "len",
      "len",
      "len",
      "len"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 922,
      "end_line": 947
    },
    "code_snippet": "def find_reference(self, ref_path: [str]) -> Relationship | None:\n        for child in self.children:\n            if child.type == CodeBlockType.IMPORT:\n                for reference in child.relationships:\n                    if (\n                        reference.path[len(reference.path) - len(ref_path) :]\n                        == ref_path\n                    ):\n                        return reference\n\n            child_path = child.full_path()\n\n            if child_path[len(child_path) - l..."
  },
  {
    "name": "get_all_relationships",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "exclude_types"
    ],
    "calls": [
      "references.extend",
      "references.extend",
      "childblock.get_all_relationships"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 949,
      "end_line": 962
    },
    "code_snippet": "def get_all_relationships(\n        self, exclude_types: list[CodeBlockType] = None\n    ) -> list[Relationship]:\n        if exclude_types is None:\n            exclude_types = []\n        references = []\n        references.extend(self.relationships)\n        for childblock in self.children:\n            if not exclude_types or childblock.type not in exclude_types:\n                references.extend(\n                    childblock.get_all_relationships(exclude_types=exclude_types)\n                )\n\n  ..."
  },
  {
    "name": "is_complete",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "all",
      "child.is_complete"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 964,
      "end_line": 967
    },
    "code_snippet": "def is_complete(self):\n        if self.type == CodeBlockType.COMMENTED_OUT_CODE:\n            return False\n        return all(child.is_complete() for child in self.children)"
  },
  {
    "name": "find_errors",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "errors.extend",
      "errors.extend",
      "errors.append",
      "child.find_errors",
      "self.path_string"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 969,
      "end_line": 982
    },
    "code_snippet": "def find_errors(self) -> list[str]:\n        errors = []\n\n        if self.children:\n            for child in self.children:\n                errors.extend(child.find_errors())\n\n        if self.type == CodeBlockType.ERROR:\n            if self.validation_errors:\n                errors.extend(self.validation_errors)\n            else:\n                errors.append(f\"Found validation errors in {self.path_string()}\")\n\n        return errors"
  },
  {
    "name": "create_commented_out_block",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "comment_out_str"
    ],
    "calls": [
      "CodeBlock",
      "self.create_comment"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 984,
      "end_line": 991
    },
    "code_snippet": "def create_commented_out_block(self, comment_out_str: str = \"...\"):\n        return CodeBlock(\n            type=CodeBlockType.COMMENTED_OUT_CODE,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=1,\n            content=self.create_comment(comment_out_str),\n        )"
  },
  {
    "name": "create_comment_block",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "comment",
      "pre_lines"
    ],
    "calls": [
      "CodeBlock",
      "self.create_comment"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 993,
      "end_line": 1000
    },
    "code_snippet": "def create_comment_block(self, comment: str = \"...\", pre_lines: int = 1):\n        return CodeBlock(\n            type=CodeBlockType.COMMENT,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=pre_lines,\n            content=self.create_comment(comment),\n        )"
  },
  {
    "name": "create_comment",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "comment"
    ],
    "calls": [
      "get_comment_symbol"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1002,
      "end_line": 1004
    },
    "code_snippet": "def create_comment(self, comment: str) -> str:\n        symbol = get_comment_symbol(\"python\")  # FIXME: Derive language from Module\n        return f\"{symbol} {comment}\""
  },
  {
    "name": "add_indentation",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "indentation"
    ],
    "calls": [
      "self.content.split",
      "child.add_indentation",
      "line.startswith"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1006,
      "end_line": 1020
    },
    "code_snippet": "def add_indentation(self, indentation: str):\n        if self.pre_lines:\n            self.indentation += indentation\n\n        # TODO: Find a more graceful way to solve multi line blocks\n        if \"\\n\" in self.content:\n            lines = self.content.split(\"\\n\")\n            content = lines[0]\n            for line in lines[1:]:\n                if line.startswith(\" \"):\n                    content += \"\\n\" + indentation + line\n            self.content = content\n\n        for child in self.children:\n ..."
  },
  {
    "name": "find_by_path",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "path"
    ],
    "calls": [
      "len",
      "child.find_by_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1022,
      "end_line": 1036
    },
    "code_snippet": "def find_by_path(self, path: list[str]) -> Optional[\"CodeBlock\"]:\n        if path is None:\n            return None\n\n        if not path:\n            return self\n\n        for child in self.children:\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    return child\n                else:\n                    return child.find_by_path(path[1:])\n\n        return None"
  },
  {
    "name": "find_blocks_by_span_id",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "blocks.append",
      "blocks.extend",
      "child.find_blocks_by_span_id"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1038,
      "end_line": 1047
    },
    "code_snippet": "def find_blocks_by_span_id(self, span_id: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            blocks.append(self)\n\n        for child in self.children:\n            # TODO: Optimize to just check relevant children (by mapping spans?\n            blocks.extend(child.find_blocks_by_span_id(span_id))\n\n        return blocks"
  },
  {
    "name": "find_last_before_span",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id",
      "last_before_span"
    ],
    "calls": [
      "child.find_last_before_span"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1049,
      "end_line": 1066
    },
    "code_snippet": "def find_last_before_span(\n        self, span_id: str, last_before_span: Optional[\"CodeBlock\"] = None\n    ) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return last_before_span\n\n        for child in self.children:\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return last_before_span\n\n            if child.belongs_to_span and child.belongs_to_span.span_id != span_id:\n         ..."
  },
  {
    "name": "find_first_by_span_id",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "child.find_first_by_span_id"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1068,
      "end_line": 1077
    },
    "code_snippet": "def find_first_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return self\n\n        for child in self.children:\n            found = child.find_first_by_span_id(span_id)\n            if found:\n                return found\n\n        return None"
  },
  {
    "name": "find_last_by_span_id",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "reversed",
      "child.find_last_by_span_id"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1079,
      "end_line": 1088
    },
    "code_snippet": "def find_last_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        for child in reversed(self.children):\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return child\n\n            found = child.find_last_by_span_id(span_id)\n            if found:\n                return found\n\n        return None"
  },
  {
    "name": "has_any_block",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "blocks"
    ],
    "calls": [
      "self.full_path",
      "block.full_path",
      "len",
      "self.full_path"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1090,
      "end_line": 1094
    },
    "code_snippet": "def has_any_block(self, blocks: list[\"CodeBlock\"]) -> bool:\n        for block in blocks:\n            if block.full_path()[: len(self.full_path())] == self.full_path():\n                return True\n        return False"
  },
  {
    "name": "find_by_identifier",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "identifier",
      "type",
      "recursive"
    ],
    "calls": [
      "child.find_by_identifier"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1096,
      "end_line": 1110
    },
    "code_snippet": "def find_by_identifier(\n        self,\n        identifier: str,\n        type: CodeBlockType | None = None,\n        recursive: bool = False,\n    ):\n        for child in self.children:\n            if child.identifier == identifier and (not type or child.type == type):\n                return child\n\n            if recursive:\n                found = child.find_by_identifier(identifier, type, recursive)\n                if found:\n                    return found\n        return None"
  },
  {
    "name": "find_blocks_with_identifier",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "identifier"
    ],
    "calls": [
      "blocks.extend",
      "blocks.append",
      "child_block.find_blocks_with_identifier"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1112,
      "end_line": 1118
    },
    "code_snippet": "def find_blocks_with_identifier(self, identifier: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child_block in self.children:\n            if child_block.identifier == identifier:\n                blocks.append(child_block)\n            blocks.extend(child_block.find_blocks_with_identifier(identifier))\n        return blocks"
  },
  {
    "name": "find_incomplete_blocks_with_type",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_type"
    ],
    "calls": [
      "self.find_incomplete_blocks_with_types"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1120,
      "end_line": 1121
    },
    "code_snippet": "def find_incomplete_blocks_with_type(self, block_type: CodeBlockType):\n        return self.find_incomplete_blocks_with_types([block_type])"
  },
  {
    "name": "find_incomplete_blocks_with_types",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_types"
    ],
    "calls": [
      "matching_blocks.append",
      "matching_blocks.extend",
      "child_block.is_complete",
      "child_block.find_incomplete_blocks_with_types"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1123,
      "end_line": 1134
    },
    "code_snippet": "def find_incomplete_blocks_with_types(self, block_types: [CodeBlockType]):\n        matching_blocks = []\n        for child_block in self.children:\n            if child_block.type in block_types and not child_block.is_complete():\n                matching_blocks.append(child_block)\n\n            if child_block.children:\n                matching_blocks.extend(\n                    child_block.find_incomplete_blocks_with_types(block_types)\n                )\n\n        return matching_blocks"
  },
  {
    "name": "find_blocks_with_types",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_types"
    ],
    "calls": [
      "matching_blocks.append",
      "matching_blocks.extend",
      "child_block.find_blocks_with_types"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1136,
      "end_line": 1146
    },
    "code_snippet": "def find_blocks_with_types(\n        self, block_types: list[CodeBlockType]\n    ) -> list[\"CodeBlock\"]:\n        matching_blocks = []\n        if self.type in block_types:\n            matching_blocks.append(self)\n        for child_block in self.children:\n            matching_blocks.extend(\n                child_block.find_blocks_with_types(block_types=block_types)\n            )\n        return matching_blocks"
  },
  {
    "name": "has_blocks_with_types",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_types"
    ],
    "calls": [
      "child_block.has_blocks_with_types"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1148,
      "end_line": 1154
    },
    "code_snippet": "def has_blocks_with_types(self, block_types: list[CodeBlockType]) -> bool:\n        if self.type in block_types:\n            return True\n        for child_block in self.children:\n            if child_block.has_blocks_with_types(block_types):\n                return True\n        return False"
  },
  {
    "name": "has_placeholders",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self"
    ],
    "calls": [
      "self.find_blocks_with_type"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1156,
      "end_line": 1157
    },
    "code_snippet": "def has_placeholders(self):\n        return self.find_blocks_with_type(CodeBlockType.COMMENTED_OUT_CODE)"
  },
  {
    "name": "find_blocks_with_type",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_type"
    ],
    "calls": [
      "self.find_blocks_with_types"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1159,
      "end_line": 1160
    },
    "code_snippet": "def find_blocks_with_type(self, block_type: CodeBlockType) -> list[\"CodeBlock\"]:\n        return self.find_blocks_with_types([block_type])"
  },
  {
    "name": "find_first_by_start_line",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_line"
    ],
    "calls": [
      "child.find_first_by_start_line"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1162,
      "end_line": 1175
    },
    "code_snippet": "def find_first_by_start_line(self, start_line: int) -> Optional[\"CodeBlock\"]:\n        for child in self.children:\n            if child.start_line >= start_line:\n                return child\n\n            if child.end_line >= start_line:\n                if not child.children:\n                    return child\n\n                found = child.find_first_by_start_line(start_line)\n                if found:\n                    return found\n\n        return None"
  },
  {
    "name": "find_blocks_by_line_numbers",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_line",
      "end_line",
      "include_parents"
    ],
    "calls": [
      "block.has_lines",
      "blocks.append",
      "blocks.append"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1177,
      "end_line": 1192
    },
    "code_snippet": "def find_blocks_by_line_numbers(\n        self,\n        start_line: int,\n        end_line: int | None = None,\n        include_parents: bool = False,\n    ) -> List[\"CodeBlock\"]:\n        blocks = []\n        block = self\n        while block.next and (end_line is None or block.start_line <= end_line):\n            if include_parents and block.has_lines(start_line, end_line):\n                blocks.append(block)\n            elif block.start_line >= start_line:\n                blocks.append(block)\n     ..."
  },
  {
    "name": "find_last_by_end_line",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "end_line",
      "tokens"
    ],
    "calls": [
      "child.find_last_by_end_line"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1194,
      "end_line": 1212
    },
    "code_snippet": "def find_last_by_end_line(\n        self, end_line: int, tokens: Optional[int] = None\n    ) -> Optional[\"CodeBlock\"]:\n        last_child = None\n        for child in self.children:\n            if child.start_line > end_line or (tokens and child.tokens > tokens):\n                return last_child\n\n            if tokens:\n                tokens -= child.tokens\n\n            last_child = child\n\n            if child.end_line > end_line:\n                found = child.find_last_by_end_line(end_line, token..."
  },
  {
    "name": "line_within_token_context",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "line_number",
      "tokens"
    ],
    "calls": [
      "self.next.line_within_token_context",
      "self.previous.line_within_token_context"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1214,
      "end_line": 1235
    },
    "code_snippet": "def line_within_token_context(self, line_number: int, tokens: int) -> bool:\n        if tokens <= 0:\n            return False\n\n        if self.end_line < line_number:\n            if not self.next:\n                return False\n            if self.next.start_line > line_number:\n                return True\n            else:\n                return self.next.line_within_token_context(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if not self.previous..."
  },
  {
    "name": "find_last_previous_block_with_block_group",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_group"
    ],
    "calls": [
      "self.previous.find_last_previous_block_with_block_group"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1237,
      "end_line": 1246
    },
    "code_snippet": "def find_last_previous_block_with_block_group(\n        self, block_group: CodeBlockTypeGroup\n    ):\n        if not self.previous:\n            return None\n\n        if self.previous.type.group == block_group:\n            return self.previous\n\n        return self.previous.find_last_previous_block_with_block_group(block_group)"
  },
  {
    "name": "find_next_block_with_block_group",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "block_group"
    ],
    "calls": [
      "self.next.find_next_block_with_block_group"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1248,
      "end_line": 1255
    },
    "code_snippet": "def find_next_block_with_block_group(self, block_group: CodeBlockTypeGroup):\n        if not self.next:\n            return None\n\n        if self.next.type.group == block_group:\n            return self.next\n\n        return self.next.find_next_block_with_block_group(block_group)"
  },
  {
    "name": "tokens_from_line",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "line_number"
    ],
    "calls": [
      "self.previous.tokens_from_line"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1257,
      "end_line": 1261
    },
    "code_snippet": "def tokens_from_line(self, line_number: int) -> Optional[int]:\n        if not self.previous or self.previous.end_line < line_number:\n            return self.tokens\n\n        return self.tokens + self.previous.tokens_from_line(line_number)"
  },
  {
    "name": "last_block_until_line",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "line_number",
      "tokens"
    ],
    "calls": [
      "self.next.last_block_until_line",
      "self.previous.last_block_until_line"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1263,
      "end_line": 1285
    },
    "code_snippet": "def last_block_until_line(self, line_number: int, tokens: int) -> \"CodeBlock\":\n        if self.end_line < line_number:\n            if (\n                not self.next\n                or self.next.start_line > line_number\n                or self.next.tokens > tokens\n            ):\n                return self\n            else:\n                return self.next.last_block_until_line(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if (\n               ..."
  },
  {
    "name": "get_all_span_ids",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "include_self"
    ],
    "calls": [
      "set",
      "span_ids.add",
      "span_ids.update",
      "child.get_all_span_ids"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1287,
      "end_line": 1296
    },
    "code_snippet": "def get_all_span_ids(self, include_self: bool = True) -> set[str]:\n        span_ids = set()\n\n        if include_self and self.belongs_to_span:\n            span_ids.add(self.belongs_to_span.span_id)\n\n        for child in self.children:\n            span_ids.update(child.get_all_span_ids())\n\n        return span_ids"
  },
  {
    "name": "get_all_spans",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "include_self"
    ],
    "calls": [
      "self.get_all_span_ids",
      "self.module.find_span_by_id"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1298,
      "end_line": 1300
    },
    "code_snippet": "def get_all_spans(self, include_self: bool = True) -> list[BlockSpan]:\n        span_ids = self.get_all_span_ids(include_self=include_self)\n        return [self.module.find_span_by_id(span_id) for span_id in span_ids]"
  },
  {
    "name": "has_span",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_id"
    ],
    "calls": [
      "self.has_any_span"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1302,
      "end_line": 1303
    },
    "code_snippet": "def has_span(self, span_id: str):\n        return self.has_any_span({span_id})"
  },
  {
    "name": "has_any_span",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [
      "self.get_all_span_ids",
      "any"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1305,
      "end_line": 1307
    },
    "code_snippet": "def has_any_span(self, span_ids: set[str]):\n        all_span_ids = self.get_all_span_ids(include_self=False)\n        return any([span_id in all_span_ids for span_id in span_ids])"
  },
  {
    "name": "belongs_to_any_span",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "span_ids"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1309,
      "end_line": 1310
    },
    "code_snippet": "def belongs_to_any_span(self, span_ids: set[str]):\n        return self.belongs_to_span and self.belongs_to_span.span_id in span_ids"
  },
  {
    "name": "has_lines",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_line",
      "end_line"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1312,
      "end_line": 1316
    },
    "code_snippet": "def has_lines(self, start_line: int, end_line: int | None = None):\n        # Returns True if any part of the block is within the provided line range\n        if end_line is None:\n            return self.end_line >= start_line\n        return not (self.end_line < start_line or self.start_line > end_line)"
  },
  {
    "name": "is_within_lines",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "start_line",
      "end_line"
    ],
    "calls": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1318,
      "end_line": 1319
    },
    "code_snippet": "def is_within_lines(self, start_line: int, end_line: int):\n        return self.start_line >= start_line and self.end_line <= end_line"
  },
  {
    "name": "has_content",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeBlock",
    "parameters": [
      "self",
      "query",
      "span_id"
    ],
    "calls": [
      "any",
      "self.has_span",
      "child.has_content"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 1321,
      "end_line": 1335
    },
    "code_snippet": "def has_content(self, query: str, span_id: Optional[str] = None):\n        if (\n            self.content\n            and query in self.content\n            and (\n                not span_id\n                or (self.belongs_to_span and self.belongs_to_span.span_id == span_id)\n            )\n        ):\n            return True\n\n        if span_id and not self.has_span(span_id):\n            return False\n\n        return any(child.has_content(query, span_id) for child in self.children)"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "JavaParser",
    "parameters": [
      "self"
    ],
    "calls": [
      "__init__",
      "self.queries.extend",
      "Language",
      "self._build_queries",
      "super",
      "java.language"
    ],
    "code_location": {
      "file": "java.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 8,
      "end_line": 12
    },
    "code_snippet": "def __init__(self, **kwargs):\n        super().__init__(Language(java.language()), **kwargs)\n        self.queries = []\n        self.queries.extend(self._build_queries(\"java.scm\"))\n        self.gpt_queries = []"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "PythonParser",
    "parameters": [
      "self"
    ],
    "calls": [
      "Language",
      "__init__",
      "self.queries.extend",
      "tspython.language",
      "self._build_queries",
      "self.gpt_queries.extend",
      "super",
      "self._build_queries"
    ],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 27,
      "end_line": 36
    },
    "code_snippet": "def __init__(self, **kwargs):\n        language = Language(tspython.language())\n\n        super().__init__(language, **kwargs)\n\n        self.queries = []\n        self.queries.extend(self._build_queries(\"python.scm\"))\n\n        if self.apply_gpt_tweaks:\n            self.gpt_queries.extend(self._build_queries(\"python_gpt.scm\"))"
  },
  {
    "name": "language",
    "docstring": "",
    "is_method": true,
    "class_name": "PythonParser",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 39,
      "end_line": 40
    },
    "code_snippet": "def language(self):\n        return \"python\""
  },
  {
    "name": "pre_process",
    "docstring": "",
    "is_method": true,
    "class_name": "PythonParser",
    "parameters": [
      "self",
      "codeblock",
      "node_match"
    ],
    "calls": [
      "endswith",
      "logger.debug",
      "strip"
    ],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 42,
      "end_line": 61
    },
    "code_snippet": "def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        if (\n            codeblock.type == CodeBlockType.FUNCTION\n            and codeblock.identifier == \"__init__\"\n        ):\n            codeblock.type = CodeBlockType.CONSTRUCTOR\n\n        # Handle line breaks after assignment without \\\n        if (\n            codeblock.type == CodeBlockType.ASSIGNMENT\n            and codeblock.content_lines[0].strip().endswith(\"=\")\n            and node_match.check_child\n            and node..."
  },
  {
    "name": "post_process",
    "docstring": "",
    "is_method": true,
    "class_name": "PythonParser",
    "parameters": [
      "self",
      "codeblock"
    ],
    "calls": [
      "codeblock.relationships.extend",
      "set",
      "set",
      "self.is_outcommented_code",
      "codeblock.find_type_in_parents",
      "codeblock.find_type_in_parents",
      "len",
      "function_names.add",
      "class_names.add",
      "child.validation_errors.append",
      "child.validation_errors.append",
      "len",
      "codeblock.module.find_by_path",
      "ValidationError",
      "ValidationError",
      "class_block.full_path",
      "super_class.full_path"
    ],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 63,
      "end_line": 130
    },
    "code_snippet": "def post_process(self, codeblock: CodeBlock):\n        if codeblock.type == CodeBlockType.COMMENT and self.is_outcommented_code(\n            codeblock.content\n        ):\n            codeblock.type = CodeBlockType.COMMENTED_OUT_CODE\n\n        if codeblock.type == CodeBlockType.ASSIGNMENT:\n            for reference in codeblock.relationships:\n                reference.type = RelationshipType.TYPE\n\n        new_references = []\n        for reference in codeblock.relationships:\n            # Set parent ..."
  },
  {
    "name": "is_outcommented_code",
    "docstring": "",
    "is_method": true,
    "class_name": "PythonParser",
    "parameters": [
      "self",
      "comment"
    ],
    "calls": [
      "comment.startswith",
      "any",
      "comment.lower"
    ],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 132,
      "end_line": 135
    },
    "code_snippet": "def is_outcommented_code(self, comment):\n        return comment.startswith(\"# ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )"
  },
  {
    "name": "is_supported",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "language"
    ],
    "calls": [],
    "code_location": {
      "file": "create.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 6,
      "end_line": 7
    },
    "code_snippet": "def is_supported(language: str) -> bool:\n    return language and language in [\"python\", \"java\"]"
  },
  {
    "name": "create_parser_by_ext",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "ext"
    ],
    "calls": [
      "NotImplementedError",
      "PythonParser",
      "JavaParser"
    ],
    "code_location": {
      "file": "create.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 10,
      "end_line": 16
    },
    "code_snippet": "def create_parser_by_ext(ext: str, **kwargs) -> CodeParser | None:\n    if ext == \".py\":\n        return PythonParser(**kwargs)\n    elif ext == \".java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Extension {ext} is not supported.\")"
  },
  {
    "name": "create_parser",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "language"
    ],
    "calls": [
      "NotImplementedError",
      "PythonParser",
      "JavaParser"
    ],
    "code_location": {
      "file": "create.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 19,
      "end_line": 25
    },
    "code_snippet": "def create_parser(language: str, **kwargs) -> CodeParser | None:\n    if language == \"python\":\n        return PythonParser(**kwargs)\n    elif language == \"java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Language {language} is not supported.\")"
  },
  {
    "name": "get_comment_symbol",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "language"
    ],
    "calls": [
      "comment_symbols.get",
      "language.lower"
    ],
    "code_location": {
      "file": "comment.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 75,
      "end_line": 78
    },
    "code_snippet": "def get_comment_symbol(language):\n    if language:\n        return comment_symbols.get(language.lower(), None)\n    return \"#\""
  },
  {
    "name": "_find_type",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "node",
      "type"
    ],
    "calls": [
      "enumerate"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 44,
      "end_line": 48
    },
    "code_snippet": "def _find_type(node: Node, type: str):\n    for i, child in enumerate(node.children):\n        if child.type == type:\n            return i, child\n    return None, None"
  },
  {
    "name": "find_type",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "node",
      "types"
    ],
    "calls": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 51,
      "end_line": 55
    },
    "code_snippet": "def find_type(node: Node, types: list[str]):\n    for child in node.children:\n        if child.type in types:\n            return child\n    return None"
  },
  {
    "name": "find_nested_type",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "node",
      "type",
      "levels"
    ],
    "calls": [
      "find_nested_type"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 58,
      "end_line": 67
    },
    "code_snippet": "def find_nested_type(node: Node, type: str, levels: int = -1):\n    if levels == 0:\n        return None\n    if node.type == type:\n        return node\n    for child in node.children:\n        found_node = find_nested_type(child, type, levels - 1)\n        if found_node:\n            return found_node\n    return None"
  },
  {
    "name": "__init__",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "language",
      "encoding",
      "max_tokens_in_span",
      "min_tokens_for_docs_span",
      "min_lines_to_parse_block",
      "enable_code_graph",
      "index_callback",
      "tokenizer",
      "apply_gpt_tweaks",
      "debug"
    ],
    "calls": [
      "Parser",
      "get_tokenizer",
      "logger.warning"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 71,
      "end_line": 115
    },
    "code_snippet": "def __init__(\n        self,\n        language: Language,\n        encoding: str = \"utf8\",\n        max_tokens_in_span: int = 500,\n        min_tokens_for_docs_span: int = 100,\n        min_lines_to_parse_block: Optional[\n            int\n        ] = None,  # If this is set code will just be parsed if they have more line than this\n        enable_code_graph: bool = True,\n        index_callback: Callable[[CodeBlock], None] | None = None,\n        tokenizer: Callable[[str], list] | None = None,\n        app..."
  },
  {
    "name": "language",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 118,
      "end_line": 119
    },
    "code_snippet": "def language(self):\n        pass"
  },
  {
    "name": "_extract_node_type",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "query"
    ],
    "calls": [
      "re.search",
      "match.group"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 121,
      "end_line": 127
    },
    "code_snippet": "def _extract_node_type(self, query: str):\n        pattern = r\"\\(\\s*(\\w+)\"\n        match = re.search(pattern, query)\n        if match:\n            return match.group(1)\n        else:\n            return None"
  },
  {
    "name": "_build_queries",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "query_file"
    ],
    "calls": [
      "open",
      "split",
      "enumerate",
      "joinpath",
      "strip",
      "self._extract_node_type",
      "parsed_queries.append",
      "logging.error",
      "resources.files",
      "file.read",
      "self.tree_language.query"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 129,
      "end_line": 150
    },
    "code_snippet": "def _build_queries(self, query_file: str):\n        with (\n            resources.files(\"moatless_qa.codeblocks.parser.queries\")\n            .joinpath(query_file)\n            .open() as file\n        ):\n            query_list = file.read().strip().split(\"\\n\\n\")\n            parsed_queries = []\n            for i, query in enumerate(query_list):\n                try:\n                    node_type = self._extract_node_type(query)\n                    parsed_queries.append(\n                        (\n     ..."
  },
  {
    "name": "parse_code",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "content_bytes",
      "node",
      "start_byte",
      "level",
      "file_path",
      "parent_block",
      "current_span"
    ],
    "calls": [
      "self.find_in_tree",
      "decode",
      "decode",
      "self.debug_log",
      "self.debug_log",
      "self.post_process",
      "self.add_to_index",
      "self.get_previous",
      "decode",
      "self.create_references",
      "self.create_parameters",
      "CodeBlock",
      "self.pre_process",
      "Module",
      "self.debug_log",
      "self.parse_code",
      "code_block.append_child",
      "self.debug_log",
      "comment_block.span_ids.add",
      "current_span.block_paths.append",
      "CodeBlock",
      "code_block.append_child",
      "self.comments_with_no_span.append",
      "self._create_new_span",
      "current_span.block_paths.append",
      "code_block.span_ids.add",
      "self._graph.add_node",
      "self.debug_log",
      "comment_block.full_path",
      "set",
      "self._count_tokens",
      "re.sub",
      "lower",
      "len",
      "code_block.span_ids.add",
      "current_span.block_paths.append",
      "code_block.full_path",
      "code_block.path_string",
      "self._graph.add_edge",
      "self.get_parent_next",
      "decode",
      "strip",
      "len",
      "comment_block.full_path",
      "code_block.path_string",
      "join",
      "str",
      "code_block.content.split"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 152,
      "end_line": 412
    },
    "code_snippet": "def parse_code(\n        self,\n        content_bytes: bytes,\n        node: Node,\n        start_byte: int = 0,\n        level: int = 0,\n        file_path: Optional[str] = None,\n        parent_block: CodeBlock | None = None,\n        current_span: BlockSpan | None = None,\n    ) -> tuple[CodeBlock, Node, BlockSpan]:\n        node_match = self.find_in_tree(node)\n\n        if not parent_block and node.children:\n            node_match.first_child = node.children[0]\n        elif node.type == \"ERROR\":\n      ..."
  },
  {
    "name": "is_commented_out_code",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "strip",
      "comment.startswith",
      "any",
      "node.text.decode",
      "get_comment_symbol",
      "comment.lower"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 414,
      "end_line": 418
    },
    "code_snippet": "def is_commented_out_code(self, node: Node):\n        comment = node.text.decode(\"utf8\").strip()\n        return comment.startswith(f\"{get_comment_symbol(self.language)} ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )"
  },
  {
    "name": "find_in_tree",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.find_match",
      "self.find_match_with_gpt_tweaks",
      "NodeMatch",
      "self.debug_log",
      "self.debug_log",
      "NodeMatch",
      "self.debug_log"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 420,
      "end_line": 444
    },
    "code_snippet": "def find_in_tree(self, node: Node) -> NodeMatch | None:\n        if self.apply_gpt_tweaks:\n            match = self.find_match_with_gpt_tweaks(node)\n            if match:\n                self.debug_log(\n                    f\"find_in_tree() GPT match: {match.block_type} on {node}\"\n                )\n                return match\n\n        if not node.parent and node.children:\n            return NodeMatch(\n                block_type=CodeBlockType.MODULE, first_child=node.children[0]\n            )\n\n   ..."
  },
  {
    "name": "find_match_with_gpt_tweaks",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self._find_match",
      "self.debug_log"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 446,
      "end_line": 459
    },
    "code_snippet": "def find_match_with_gpt_tweaks(self, node: Node) -> NodeMatch | None:\n        for label, node_type, query in self.gpt_queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label, capture_from_parent=True)\n            if match:\n                self.debug_log(\n                    f\"find_match_with_gpt_tweaks() Found match on node {node.type} with query {label}\"\n                )\n                ..."
  },
  {
    "name": "find_match",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "self.debug_log",
      "self._find_match",
      "self.debug_log"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 461,
      "end_line": 478
    },
    "code_snippet": "def find_match(self, node: Node) -> NodeMatch | None:\n        self.debug_log(f\"find_match() node type {node.type}\")\n\n        queries = 0\n        for label, node_type, query in self.queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label)\n            queries += 1\n            if match:\n                self.debug_log(\n                    f\"find_match() Found match on node {node.type} with que..."
  },
  {
    "name": "_find_match",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node",
      "query",
      "label",
      "capture_from_parent"
    ],
    "calls": [
      "NodeMatch",
      "logger.info",
      "query.captures",
      "query.captures",
      "self.debug_log",
      "self.debug_log",
      "len",
      "self.debug_log",
      "self.debug_log",
      "self.find_match",
      "self.debug_log",
      "self.find_match",
      "node_match.parameters.append",
      "tag.startswith",
      "node_match.relationships.append",
      "CodeBlockType.from_string",
      "self.debug_log",
      "self.debug_log",
      "node_match.parameters.extend",
      "len",
      "len"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 480,
      "end_line": 566
    },
    "code_snippet": "def _find_match(\n        self, node: Node, query, label: str, capture_from_parent: bool = False\n    ) -> NodeMatch | None:\n        if capture_from_parent:\n            captures = query.captures(node.parent)\n        else:\n            captures = query.captures(node)\n\n        node_match = NodeMatch()\n\n        if not captures:\n            return None\n\n        root_node = None\n        logger.info(captures)\n        for capture in captures:\n            # 安全地解包捕获结果，确保即使格式变化也能正常工作\n            if len(captu..."
  },
  {
    "name": "create_references",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "code",
      "content_bytes",
      "identifier",
      "node_match"
    ],
    "calls": [
      "self.get_content",
      "self.get_content",
      "reference_id.split",
      "references.append",
      "len",
      "references.append",
      "logger.warning",
      "Relationship",
      "Relationship",
      "self.get_content",
      "references.append",
      "self.get_content",
      "references.append",
      "Relationship",
      "Relationship"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 568,
      "end_line": 652
    },
    "code_snippet": "def create_references(self, code, content_bytes, identifier, node_match):\n        references = []\n        if node_match.block_type == CodeBlockType.IMPORT and node_match.relationships:\n            module_nodes = [\n                ref for ref in node_match.relationships if ref[1] == \"reference.module\"\n            ]\n            if module_nodes:\n                module_reference_id = self.get_content(\n                    module_nodes[0][0], content_bytes\n                )\n                if len(node..."
  },
  {
    "name": "create_parameters",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "content_bytes",
      "node_match",
      "references"
    ],
    "calls": [
      "self.get_content",
      "parameters.append",
      "self.get_content",
      "Parameter",
      "parameter_type.replace",
      "parameter_type.split",
      "Relationship",
      "references.append"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 654,
      "end_line": 673
    },
    "code_snippet": "def create_parameters(self, content_bytes, node_match, references):\n        parameters = []\n        for parameter in node_match.parameters:\n            parameter_type = (\n                self.get_content(parameter[1], content_bytes) if parameter[1] else None\n            )\n            parameter_id = self.get_content(parameter[0], content_bytes)\n\n            parameters.append(Parameter(identifier=parameter_id, type=parameter_type))\n\n            if parameter_type:\n                parameter_type = p..."
  },
  {
    "name": "add_to_index",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "codeblock"
    ],
    "calls": [
      "self.index_callback"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 675,
      "end_line": 677
    },
    "code_snippet": "def add_to_index(self, codeblock: CodeBlock):\n        if self.index_callback:\n            self.index_callback(codeblock)"
  },
  {
    "name": "pre_process",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "codeblock",
      "node_match"
    ],
    "calls": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 679,
      "end_line": 680
    },
    "code_snippet": "def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        pass"
  },
  {
    "name": "post_process",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "codeblock"
    ],
    "calls": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 682,
      "end_line": 683
    },
    "code_snippet": "def post_process(self, codeblock: CodeBlock):\n        pass"
  },
  {
    "name": "get_previous",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node",
      "origin_node"
    ],
    "calls": [
      "self.get_previous"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 685,
      "end_line": 693
    },
    "code_snippet": "def get_previous(self, node: Node, origin_node: Node):\n        if node == origin_node:\n            return node.start_byte\n        if node.prev_sibling:\n            return node.prev_sibling.end_byte\n        elif node.parent:\n            return self.get_previous(node.parent, origin_node)\n        else:\n            return node.start_byte"
  },
  {
    "name": "get_parent_next",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node",
      "orig_node"
    ],
    "calls": [
      "self.debug_log",
      "self.debug_log",
      "self.get_parent_next"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 695,
      "end_line": 705
    },
    "code_snippet": "def get_parent_next(self, node: Node, orig_node: Node):\n        self.debug_log(f\"get_parent_next: {node.type} - {orig_node.type}\")\n        if node != orig_node:\n            if node.next_sibling:\n                self.debug_log(\n                    f\"get_parent_next: node.next_sibling -> {node.next_sibling}\"\n                )\n                return node.next_sibling\n            else:\n                return self.get_parent_next(node.parent, orig_node)\n        return None"
  },
  {
    "name": "has_error",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node"
    ],
    "calls": [
      "any",
      "self.has_error"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 707,
      "end_line": 712
    },
    "code_snippet": "def has_error(self, node: Node):\n        if node.type == \"ERROR\":\n            return True\n        if node.children:\n            return any(self.has_error(child) for child in node.children)\n        return False"
  },
  {
    "name": "parse",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "content",
      "file_path"
    ],
    "calls": [
      "isinstance",
      "self.tree_parser.parse",
      "self.parse_code",
      "bytes",
      "isinstance",
      "nx.DiGraph",
      "tree.walk",
      "ValueError"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 714,
      "end_line": 738
    },
    "code_snippet": "def parse(self, content, file_path: Optional[str] = None) -> Module:\n        if isinstance(content, str):\n            content_in_bytes = bytes(content, self.encoding)\n        elif isinstance(content, bytes):\n            content_in_bytes = content\n        else:\n            raise ValueError(\"Content must be either a string or bytes\")\n\n        # TODO: make thread safe?\n        self.spans_by_id = {}\n        self._span_counter = {}\n\n        # TODO: Should me moved to a central CodeGraph\n        if se..."
  },
  {
    "name": "get_content",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "node",
      "content_bytes"
    ],
    "calls": [
      "decode"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 740,
      "end_line": 741
    },
    "code_snippet": "def get_content(self, node: Node, content_bytes: bytes) -> str:\n        return content_bytes[node.start_byte : node.end_byte].decode(self.encoding)"
  },
  {
    "name": "_create_new_span",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "current_span",
      "block"
    ],
    "calls": [
      "self._create_span_id",
      "BlockSpan",
      "BlockSpan",
      "len",
      "len",
      "BlockSpan",
      "BlockSpan",
      "self._create_span_id",
      "BlockSpan",
      "BlockSpan",
      "block.parent.full_path",
      "len",
      "len",
      "block.parent.full_path",
      "block.full_path",
      "block.parent.full_path",
      "self._create_span_id",
      "self._create_span_id",
      "block.full_path",
      "block.full_path",
      "block.sum_tokens",
      "block.full_path",
      "block.parent.full_path"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 743,
      "end_line": 889
    },
    "code_snippet": "def _create_new_span(\n        self, current_span: BlockSpan | None, block: CodeBlock\n    ) -> BlockSpan | None:\n        # Set documentation phase on comments in the start of structure blocks if more than min_tokens_for_docs_span\n        # TODO: This is isn't valid in other languages, try to set block type to docstring?\n        block_types_with_document_span = [\n            CodeBlockType.MODULE\n        ]  # TODO: Make this configurable\n\n        # Set initation phase on imports in module blocks\n  ..."
  },
  {
    "name": "_create_span_id",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "block",
      "label"
    ],
    "calls": [
      "structure_block.path_string",
      "block.find_type_group_in_parents"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 891,
      "end_line": 916
    },
    "code_snippet": "def _create_span_id(self, block: CodeBlock, label: Optional[str] = None):\n        if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n            structure_block = block\n        else:\n            structure_block = block.find_type_group_in_parents(\n                CodeBlockTypeGroup.STRUCTURE\n            )\n\n        if not structure_block:\n            return \"unknown\"\n\n        span_id = structure_block.path_string()\n        if label and span_id:\n            span_id += f\":{label}\"\n        elif lab..."
  },
  {
    "name": "_count_tokens",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "content"
    ],
    "calls": [
      "len",
      "self.tokenizer"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 918,
      "end_line": 921
    },
    "code_snippet": "def _count_tokens(self, content: str):\n        if not self.tokenizer:\n            return 0\n        return len(self.tokenizer(content))"
  },
  {
    "name": "debug_log",
    "docstring": "",
    "is_method": true,
    "class_name": "CodeParser",
    "parameters": [
      "self",
      "message"
    ],
    "calls": [
      "logger.debug"
    ],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 923,
      "end_line": 925
    },
    "code_snippet": "def debug_log(self, message: str):\n        if self.debug:\n            logger.debug(message)"
  },
  {
    "name": "anthropic_schema",
    "docstring": "Provide schema in format expected by Anthropic's tool calling",
    "is_method": true,
    "class_name": "FeedbackResponse",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 36,
      "end_line": 60
    },
    "code_snippet": "def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_feedback\",\n            \"description\": \"Provide feedback on the current state\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"analysis\": {\n                        \"type\": \"string\",\n                        \"description\": \"Brief analys..."
  },
  {
    "name": "to_dict",
    "docstring": "Convert Message objects to dictionaries",
    "is_method": true,
    "class_name": "FeedbackResponse",
    "parameters": [
      "self"
    ],
    "calls": [
      "hasattr",
      "hasattr",
      "str"
    ],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 62,
      "end_line": 67
    },
    "code_snippet": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert Message objects to dictionaries\"\"\"\n        return {\n            \"role\": self.role if hasattr(self, \"role\") else \"assistant\",\n            \"content\": self.content if hasattr(self, \"content\") else str(self),\n        }"
  },
  {
    "name": "model_post_init",
    "docstring": "Initialize feedback file after model initialization",
    "is_method": true,
    "class_name": "FeedbackAgent",
    "parameters": [
      "self",
      "__context"
    ],
    "calls": [
      "model_post_init",
      "os.getcwd",
      "os.makedirs",
      "os.path.join",
      "super"
    ],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 84,
      "end_line": 96
    },
    "code_snippet": "def model_post_init(self, __context) -> None:\n        \"\"\"Initialize feedback file after model initialization\"\"\"\n        super().model_post_init(__context)\n\n        # Set instance directory if not provided\n        if not self.instance_dir:\n            self.instance_dir = os.getcwd()\n\n        # Set feedback file path\n        if not self.feedback_file:\n            # Create instance directory if it doesn't exist\n            os.makedirs(self.instance_dir, exist_ok=True)\n            self.feedback_file..."
  },
  {
    "name": "generate_feedback",
    "docstring": "",
    "is_method": true,
    "class_name": "FeedbackAgent",
    "parameters": [
      "self",
      "node",
      "actions"
    ],
    "calls": [
      "self._create_analysis_messages",
      "self._create_system_prompt",
      "logger.info",
      "self.completion_model.create_completion",
      "logger.debug",
      "print",
      "FeedbackData",
      "self.save_feedback",
      "logger.exception",
      "FeedbackResponse"
    ],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 101,
      "end_line": 165
    },
    "code_snippet": "def generate_feedback(\n        self, node: Node, actions: List[Action] | None = None\n    ) -> FeedbackData | None:\n        if not node.parent:\n            logger.info(\n                f\"Node {node.node_id} has no parent node, skipping feedback generation\"\n            )\n            return None\n\n        messages = self._create_analysis_messages(\n            node,\n        )\n        system_prompt = self._create_system_prompt(actions)\n\n        try:\n            completion_response = self.completion_mo..."
  },
  {
    "name": "_create_analysis_messages",
    "docstring": "",
    "is_method": true,
    "class_name": "FeedbackAgent",
    "parameters": [
      "self",
      "current_node"
    ],
    "calls": [
      "messages.append",
      "current_node.get_root",
      "messages.append",
      "MessageHistoryGenerator",
      "message_generator.generate",
      "generate_ascii_tree",
      "messages.append",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "messages.extend",
      "messages.append",
      "current_node.get_sibling_nodes",
      "current_node.get_root",
      "ChatCompletionUserMessage",
      "sibling.action.to_prompt",
      "ChatCompletionUserMessage",
      "current_node.get_sibling_nodes"
    ],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 167,
      "end_line": 270
    },
    "code_snippet": "def _create_analysis_messages(\n        self, current_node: Node\n    ) -> List[ChatCompletionUserMessage]:\n        messages = []\n\n        # Only get siblings that have been run (have actions set)\n        sibling_nodes = [\n            s for s in current_node.get_sibling_nodes() if s.action is not None\n        ]\n\n        # Format tree visualization section\n        if self.include_tree:\n            tree_message = \"# Search Tree Visualization\\n\"\n            tree_message += \"<search_tree>\\n\"\n         ..."
  },
  {
    "name": "_create_system_prompt",
    "docstring": "",
    "is_method": true,
    "class_name": "FeedbackAgent",
    "parameters": [
      "self",
      "actions"
    ],
    "calls": [],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 272,
      "end_line": 372
    },
    "code_snippet": "def _create_system_prompt(\n        self,\n        actions: List[Action],\n    ) -> str:\n        start_num = 1\n        base_prompt = \"\"\"\nYou are a feedback agent that guides an AI assistant's next action.\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n⚠️  CRITICAL: ACTION AGENT LIMITATIONS  ⚠️\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nThe action agent receiving your feedback:\n• CANNOT see the search tree\n• Has NO CONTEXT about ..."
  },
  {
    "name": "save_feedback",
    "docstring": "Save raw prompts and responses to feedback file",
    "is_method": true,
    "class_name": "FeedbackAgent",
    "parameters": [
      "self",
      "node",
      "feedback",
      "system_prompt",
      "messages",
      "raw_completion"
    ],
    "calls": [
      "strftime",
      "enumerate",
      "feedback_entry.extend",
      "logger.info",
      "os.path.dirname",
      "os.path.join",
      "os.makedirs",
      "feedback_entry.extend",
      "open",
      "f.write",
      "os.path.splitext",
      "datetime.now",
      "join",
      "os.path.basename"
    ],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 374,
      "end_line": 427
    },
    "code_snippet": "def save_feedback(\n        self,\n        node: Node,\n        feedback: FeedbackResponse,\n        system_prompt: str | None = None,\n        messages: List | None = None,\n        raw_completion: str | None = None,\n    ) -> None:\n        \"\"\"Save raw prompts and responses to feedback file\"\"\"\n        # Setup file path\n        if self.persist_path:\n            save_dir = os.path.dirname(self.persist_path)\n            base_name = os.path.splitext(os.path.basename(self.persist_path))[0]\n            self..."
  },
  {
    "name": "generate_feedback",
    "docstring": "Generate feedback based on the node.",
    "is_method": true,
    "class_name": "FeedbackGenerator",
    "parameters": [
      "self",
      "node",
      "actions"
    ],
    "calls": [],
    "code_location": {
      "file": "feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 16,
      "end_line": 20
    },
    "code_snippet": "def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node.\"\"\"\n        pass"
  },
  {
    "name": "model_dump",
    "docstring": "",
    "is_method": true,
    "class_name": "FeedbackGenerator",
    "parameters": [
      "self"
    ],
    "calls": [
      "model_dump",
      "super"
    ],
    "code_location": {
      "file": "feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 22,
      "end_line": 27
    },
    "code_snippet": "def model_dump(self, **kwargs) -> dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"feedback_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump"
  },
  {
    "name": "model_validate",
    "docstring": "",
    "is_method": true,
    "class_name": "FeedbackGenerator",
    "parameters": [
      "cls",
      "obj"
    ],
    "calls": [
      "isinstance",
      "model_validate",
      "obj.copy",
      "obj.pop",
      "feedback_class_path.rsplit",
      "importlib.import_module",
      "getattr",
      "feedback_class",
      "super",
      "logger.warning"
    ],
    "code_location": {
      "file": "feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 30,
      "end_line": 49
    },
    "code_snippet": "def model_validate(cls, obj: Any) -> \"FeedbackGenerator\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            feedback_class_path = obj.pop(\n                \"feedback_class\",\n                \"moatless_qa.feedback.ground_truth_feedback.GroundTruthFeedbackGenerator\",\n            )\n\n            try:\n                module_name, class_name = feedback_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                feedback_class = getattr..."
  },
  {
    "name": "anthropic_schema",
    "docstring": "Provide schema in format expected by Anthropic's tool calling",
    "is_method": true,
    "class_name": "GroundTruthResponse",
    "parameters": [
      "cls"
    ],
    "calls": [],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 36,
      "end_line": 64
    },
    "code_snippet": "def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_ground_truth_feedback\",\n            \"description\": \"Provide feedback on ground truth support\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"analysis\": {\n                        \"type\": \"string\",\n                        \"description..."
  },
  {
    "name": "to_dict",
    "docstring": "Convert Message objects to dictionaries",
    "is_method": true,
    "class_name": "GroundTruthResponse",
    "parameters": [
      "self"
    ],
    "calls": [
      "hasattr",
      "hasattr",
      "str"
    ],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 66,
      "end_line": 71
    },
    "code_snippet": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert Message objects to dictionaries\"\"\"\n        return {\n            \"role\": self.role if hasattr(self, \"role\") else \"assistant\",\n            \"content\": self.content if hasattr(self, \"content\") else str(self),\n        }"
  },
  {
    "name": "generate_feedback",
    "docstring": "Generate feedback based on the node",
    "is_method": true,
    "class_name": "GroundTruthFeedbackGenerator",
    "parameters": [
      "self",
      "node",
      "actions"
    ],
    "calls": [
      "self._create_analysis_messages",
      "self._create_system_prompt",
      "logger.info",
      "self.completion_model.create_completion",
      "logger.debug",
      "FeedbackData",
      "logger.exception"
    ],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 86,
      "end_line": 132
    },
    "code_snippet": "def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node\"\"\"\n        if not node.parent:\n            logger.info(\n                f\"Node {node.node_id} has no parent node, skipping feedback generation\"\n            )\n            return None\n        \n        messages = self._create_analysis_messages(node)\n        system_prompt = self._create_system_prompt()\n        \n        try:\n       ..."
  },
  {
    "name": "_create_analysis_messages",
    "docstring": "Create messages for analysis",
    "is_method": true,
    "class_name": "GroundTruthFeedbackGenerator",
    "parameters": [
      "self",
      "current_node"
    ],
    "calls": [
      "messages.append",
      "current_node.get_root",
      "messages.append",
      "generate_ascii_tree",
      "messages.append",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "messages.append",
      "messages.append",
      "current_node.get_sibling_nodes",
      "current_node.get_root",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "ChatCompletionUserMessage",
      "sibling.action.to_prompt",
      "current_node.get_sibling_nodes"
    ],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 134,
      "end_line": 218
    },
    "code_snippet": "def _create_analysis_messages(\n        self, current_node: Node\n    ) -> List[ChatCompletionUserMessage]:\n        \"\"\"Create messages for analysis\"\"\"\n        messages = []\n        \n        # Only get siblings that have been run (have actions set)\n        sibling_nodes = [\n            s for s in current_node.get_sibling_nodes() if s.action is not None\n        ]\n        \n        # Format tree visualization section\n        if self.include_tree:\n            tree_message = \"# Search Tree Visualization..."
  },
  {
    "name": "_create_system_prompt",
    "docstring": "Create system prompt",
    "is_method": true,
    "class_name": "GroundTruthFeedbackGenerator",
    "parameters": [
      "self"
    ],
    "calls": [],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 220,
      "end_line": 272
    },
    "code_snippet": "def _create_system_prompt(self) -> str:\n        \"\"\"Create system prompt\"\"\"\n        system_prompt = \"\"\"You are a feedback agent responsible for evaluating the quality of AI assistant responses.\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📋  YOUR TASK\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n1. Analyze whether the current node's response has reliable ground truth support\n   • Evaluate if the response is based on reliable f..."
  },
  {
    "name": "retry_clone",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_url",
      "repo_dir",
      "max_attempts"
    ],
    "calls": [
      "repo_url.startswith",
      "range",
      "os.path.isabs",
      "os.path.abspath",
      "logger.info",
      "subprocess.run",
      "logger.info",
      "logger.error",
      "logger.info",
      "time.sleep",
      "random.randint"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 10,
      "end_line": 40
    },
    "code_snippet": "def retry_clone(repo_url, repo_dir, max_attempts=3):\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    for attempt in range(max_attempts):\n        try:\n            logger.info(f\"Cloning {repo_url} to {repo_dir} (attempt {attempt + 1})\")\n     ..."
  },
  {
    "name": "setup_github_repo",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo",
      "base_commit",
      "base_dir"
    ],
    "calls": [
      "get_repo_dir_name",
      "logger.info",
      "maybe_clone",
      "checkout_commit",
      "os.path.exists",
      "os.makedirs",
      "logger.info"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 43,
      "end_line": 55
    },
    "code_snippet": "def setup_github_repo(repo: str, base_commit: str, base_dir: str = \"/tmp/repos\") -> str:\n    repo_name = get_repo_dir_name(repo)\n    repo_url = f\"https://github.com/{repo}.git\"\n    path = f\"{base_dir}/{repo_name}\"\n    logger.info(\n        f\"Clone Github repo {repo_url} to {path} and checkout commit {base_commit}\"\n    )\n    if not os.path.exists(path):\n        os.makedirs(path)\n        logger.info(f\"Directory '{path}' was created.\")\n    maybe_clone(repo_url, path)\n    checkout_commit(path, base_c..."
  },
  {
    "name": "get_repo_dir_name",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo"
    ],
    "calls": [
      "repo.replace"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 58,
      "end_line": 59
    },
    "code_snippet": "def get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"_\")"
  },
  {
    "name": "clone_and_checkout",
    "docstring": "Clone the repository and checkout to the specific commit.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_url",
      "repo_dir",
      "commit"
    ],
    "calls": [
      "repo_url.startswith",
      "subprocess.run",
      "subprocess.run",
      "os.path.isabs",
      "os.path.abspath",
      "subprocess.run",
      "subprocess.run",
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 62,
      "end_line": 115
    },
    "code_snippet": "def clone_and_checkout(repo_url, repo_dir, commit):\n    \"\"\"Clone the repository and checkout to the specific commit.\"\"\"\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    # 首先尝试常规克隆，避免设置深度限制\n    subprocess.run(\n        [\"git\", \"clone\", repo_ur..."
  },
  {
    "name": "maybe_clone",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_url",
      "repo_dir"
    ],
    "calls": [
      "repo_url.startswith",
      "os.path.exists",
      "logger.info",
      "logger.info",
      "os.path.isabs",
      "os.path.abspath",
      "retry_clone",
      "logger.error",
      "ValueError"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 118,
      "end_line": 134
    },
    "code_snippet": "def maybe_clone(repo_url, repo_dir):\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    if not os.path.exists(f\"{repo_dir}/.git\"):\n        logger.info(f\"Cloning repo '{repo_url}'\")\n        try:\n            retry_clone(repo_url, repo_dir)\n     ..."
  },
  {
    "name": "pull_latest",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 137,
      "end_line": 144
    },
    "code_snippet": "def pull_latest(repo_dir):\n    subprocess.run(\n        [\"git\", \"pull\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "name": "clean_and_reset_state",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir"
    ],
    "calls": [
      "subprocess.run",
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 147,
      "end_line": 161
    },
    "code_snippet": "def clean_and_reset_state(repo_dir):\n    subprocess.run(\n        [\"git\", \"clean\", \"-fd\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n    subprocess.run(\n        [\"git\", \"reset\", \"--hard\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "name": "create_branch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "subprocess.run",
      "logger.error"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 164,
      "end_line": 175
    },
    "code_snippet": "def create_branch(repo_dir, branch_name):\n    try:\n        subprocess.run(\n            [\"git\", \"branch\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "name": "create_and_checkout_branch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "stdout.split",
      "branch.strip",
      "subprocess.run",
      "subprocess.run",
      "logger.error",
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 178,
      "end_line": 206
    },
    "code_snippet": "def create_and_checkout_branch(repo_dir, branch_name):\n    try:\n        branches = subprocess.run(\n            [\"git\", \"branch\"],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        ).stdout.split(\"\\n\")\n        branches = [branch.strip() for branch in branches]\n        if branch_name in branches:\n            subprocess.run(\n                [\"git\", \"checkout\", branch_name],\n                cwd=repo_dir,\n                check=True,\n    ..."
  },
  {
    "name": "commit_changes",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "commit_message"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 209,
      "end_line": 216
    },
    "code_snippet": "def commit_changes(repo_dir, commit_message):\n    subprocess.run(\n        [\"git\", \"commit\", \"-m\", commit_message, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "name": "checkout_branch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 219,
      "end_line": 226
    },
    "code_snippet": "def checkout_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"checkout\", branch_name],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "name": "push_branch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 229,
      "end_line": 236
    },
    "code_snippet": "def push_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"push\", \"origin\", branch_name, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "name": "get_diff",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 239,
      "end_line": 244
    },
    "code_snippet": "def get_diff(repo_dir):\n    output = subprocess.run(\n        [\"git\", \"diff\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )\n\n    return output.stdout"
  },
  {
    "name": "stage_all_files",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir"
    ],
    "calls": [
      "subprocess.run"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 247,
      "end_line": 250
    },
    "code_snippet": "def stage_all_files(repo_dir):\n    subprocess.run(\n        [\"git\", \"add\", \".\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )"
  },
  {
    "name": "checkout_commit",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "commit_hash"
    ],
    "calls": [
      "logger.info",
      "subprocess.run",
      "logger.error"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 253,
      "end_line": 265
    },
    "code_snippet": "def checkout_commit(repo_dir, commit_hash):\n    logger.info(f\"Checking out commit {commit_hash} in {repo_dir}\")\n    try:\n        subprocess.run(\n            [\"git\", \"reset\", \"--hard\", commit_hash],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "name": "create_and_checkout_new_branch",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "subprocess.run",
      "logger.error"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 268,
      "end_line": 279
    },
    "code_snippet": "def create_and_checkout_new_branch(repo_dir: str, branch_name: str):\n    try:\n        subprocess.run(\n            [\"git\", \"checkout\", \"-b\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "name": "setup_repo",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_url",
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "maybe_clone",
      "clean_and_reset_state",
      "checkout_branch",
      "pull_latest"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 282,
      "end_line": 286
    },
    "code_snippet": "def setup_repo(repo_url, repo_dir, branch_name=\"master\"):\n    maybe_clone(repo_url, repo_dir)\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)"
  },
  {
    "name": "clean_and_reset_repo",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "repo_dir",
      "branch_name"
    ],
    "calls": [
      "clean_and_reset_state",
      "checkout_branch",
      "pull_latest"
    ],
    "code_location": {
      "file": "repo.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 289,
      "end_line": 292
    },
    "code_snippet": "def clean_and_reset_repo(repo_dir, branch_name=\"master\"):\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)"
  },
  {
    "name": "parse_explanation",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "response_content",
      "keyword"
    ],
    "calls": [
      "re.search",
      "strip",
      "match.group"
    ],
    "code_location": {
      "file": "parse.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 8,
      "end_line": 15
    },
    "code_snippet": "def parse_explanation(response_content, keyword=\"feedback\") -> str:\n    explanation_pattern = r\"<{keyword}>\\s*(.*?)\\s*(?:</{keyword}>|<Feedback_to_Alternative_Branch>|<Reward>|$)\"\n    match = re.search(explanation_pattern, response_content, re.DOTALL | re.IGNORECASE)\n\n    if match:\n        return match.group(1).strip()\n    else:\n        return response_content"
  },
  {
    "name": "parse_value",
    "docstring": "Parse the value associated with a given keyword from the LLM response content.\n\nArgs:\nresponse_content (str): The content of the LLM response.\nkeyword (str): The keyword to search for (default: 'reward').\nallowed_values (list or range, optional): A list or range of allowed values.\n\nReturns:\nint: The parsed integer value, or None if not found, not an integer, or not in allowed_values.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "response_content",
      "keyword",
      "allowed_values"
    ],
    "calls": [
      "re.search",
      "logger.warning",
      "logger.warning",
      "re.search",
      "strip",
      "int",
      "logger.warning",
      "logger.error",
      "keyword.capitalize",
      "keyword.capitalize",
      "keyword.capitalize",
      "keyword.capitalize",
      "keyword.capitalize",
      "strip",
      "int",
      "match.group",
      "match.group"
    ],
    "code_location": {
      "file": "parse.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 18,
      "end_line": 77
    },
    "code_snippet": "def parse_value(response_content, keyword=\"reward\", allowed_values=None):\n    \"\"\"\n    Parse the value associated with a given keyword from the LLM response content.\n\n    Args:\n    response_content (str): The content of the LLM response.\n    keyword (str): The keyword to search for (default: 'reward').\n    allowed_values (list or range, optional): A list or range of allowed values.\n\n    Returns:\n    int: The parsed integer value, or None if not found, not an integer, or not in allowed_values.\n   ..."
  },
  {
    "name": "parse_node_id",
    "docstring": "Parse the node_id from the LLM response content.\nLooks for patterns like:\n- \"expand node 5\"\n- \"node_id: 5\"\n- \"Node ID: 5\"\n- \"suggested node: 5\"\n- Or any JSON structure containing node_id or suggested_node_id\n\nArgs:\nresponse_content (str): The content of the LLM response.\n\nReturns:\nint: The parsed node ID, or None if not found or not a valid integer.",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "response_content"
    ],
    "calls": [
      "logger.debug",
      "re.search",
      "logger.warning",
      "logger.error",
      "strip",
      "int",
      "match.group"
    ],
    "code_location": {
      "file": "parse.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 80,
      "end_line": 129
    },
    "code_snippet": "def parse_node_id(response_content) -> Optional[int]:\n    \"\"\"\n    Parse the node_id from the LLM response content.\n    Looks for patterns like:\n    - \"expand node 5\"\n    - \"node_id: 5\"\n    - \"Node ID: 5\"\n    - \"suggested node: 5\"\n    - Or any JSON structure containing node_id or suggested_node_id\n\n    Args:\n    response_content (str): The content of the LLM response.\n\n    Returns:\n    int: The parsed node ID, or None if not found or not a valid integer.\n    \"\"\"\n    node_patterns = [\n        r\"ex..."
  },
  {
    "name": "is_test",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "file_path"
    ],
    "calls": [
      "Path",
      "any",
      "any",
      "fnmatch.fnmatch"
    ],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 5,
      "end_line": 20
    },
    "code_snippet": "def is_test(file_path: str) -> bool:\n    path = Path(file_path)\n\n    # All files in test directories are considered test files\n    if any(part in [\"testing\"] for part in path.parts):\n        return True\n\n    test_file_patterns = [\n        \"unittest_*.py\",\n        \"test_*.py\",\n        \"tests_*.py\",\n        \"*_test.py\",\n        \"test.py\",\n        \"tests.py\",\n    ]\n    return any(fnmatch.fnmatch(path.name, pattern) for pattern in test_file_patterns)"
  },
  {
    "name": "count_tokens",
    "docstring": "",
    "is_method": false,
    "class_name": null,
    "parameters": [
      "content",
      "model"
    ],
    "calls": [
      "model.startswith",
      "len",
      "_voyageai.count_tokens",
      "tiktoken.encoding_for_model",
      "_enc.encode",
      "voyageai.Client",
      "os.path.join",
      "ImportError",
      "os.path.dirname",
      "ImportError",
      "os.path.abspath"
    ],
    "code_location": {
      "file": "tokenizer.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 8,
      "end_line": 48
    },
    "code_snippet": "def count_tokens(content: str, model: str = \"gpt-3.5-turbo\") -> int:\n    global _enc, _voyageai\n\n    if model.startswith(\"voyage\"):\n        if _voyageai is None:\n            voyageai_import_err = (\n                \"`voyageai` package not found, please run `pip install voyageai`\"\n            )\n            try:\n                import voyageai\n            except ImportError as e:\n                raise ImportError(voyageai_import_err) from e\n\n            _voyageai = voyageai.Client()\n\n        return..."
  }
]