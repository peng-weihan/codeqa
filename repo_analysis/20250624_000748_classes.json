[
  {
    "name": "MoatlessError",
    "docstring": "Base exception class for all Moatless exceptions.",
    "methods": [
      "__init__"
    ],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 4,
      "end_line": 9
    },
    "code_snippet": "class MoatlessError(Exception):\n    \"\"\"Base exception class for all Moatless exceptions.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(message)"
  },
  {
    "name": "RuntimeError",
    "docstring": "Exception raised when an operation encounters a fundamental error that prevents further execution.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 12,
      "end_line": 15
    },
    "code_snippet": "class RuntimeError(MoatlessError):\n    \"\"\"Exception raised when an operation encounters a fundamental error that prevents further execution.\"\"\"\n\n    pass"
  },
  {
    "name": "RejectError",
    "docstring": "Exception raised when an operation should be rejected but the flow can continue.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 18,
      "end_line": 21
    },
    "code_snippet": "class RejectError(MoatlessError):\n    \"\"\"Exception raised when an operation should be rejected but the flow can continue.\"\"\"\n\n    pass"
  },
  {
    "name": "CompletionError",
    "docstring": "Base exception for completion-related errors.",
    "methods": [
      "__init__"
    ],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 24,
      "end_line": 32
    },
    "code_snippet": "class CompletionError(MoatlessError):\n    \"\"\"Base exception for completion-related errors.\"\"\"\n\n    def __init__(\n        self, message: str, last_completion: Any = None, messages: List[dict] = None\n    ):\n        super().__init__(message)\n        self.last_completion = last_completion\n        self.messages = messages or []"
  },
  {
    "name": "CompletionRuntimeError",
    "docstring": "Exception raised when completion encounters an unrecoverable error.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 35,
      "end_line": 38
    },
    "code_snippet": "class CompletionRuntimeError(RuntimeError, CompletionError):\n    \"\"\"Exception raised when completion encounters an unrecoverable error.\"\"\"\n\n    pass"
  },
  {
    "name": "CompletionRejectError",
    "docstring": "Exception raised when completion should reject the current node but continue search.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 41,
      "end_line": 44
    },
    "code_snippet": "class CompletionRejectError(RejectError, CompletionError):\n    \"\"\"Exception raised when completion should reject the current node but continue search.\"\"\"\n\n    pass"
  },
  {
    "name": "CompletionValidationError",
    "docstring": "Exception raised when completion encounters a validation error.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "exceptions.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 47,
      "end_line": 50
    },
    "code_snippet": "class CompletionValidationError(MoatlessError):\n    \"\"\"Exception raised when completion encounters a validation error.\"\"\"\n\n    pass"
  },
  {
    "name": "Expander",
    "docstring": "",
    "methods": [
      "expand",
      "_get_agent_settings",
      "_generate_unique_id"
    ],
    "attributes": [],
    "code_location": {
      "file": "expander.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 13,
      "end_line": 86
    },
    "code_snippet": "class Expander(BaseModel):\n    random_settings: bool = Field(\n        False, description=\"Whether to select agent settings randomly\"\n    )\n    max_expansions: int = Field(\n        1, description=\"The maximum number of children to create for each node\"\n    )\n\n    agent_settings: List[AgentSettings] = Field(\n        [],\n        description=\"The settings for the agent model\",\n    )\n\n    def expand(\n        self, node: Node, search_tree, force_expansion: bool = False\n    ) -> None | Node:\n        \"\"..."
  },
  {
    "name": "MessageHistoryGenerator",
    "docstring": "",
    "methods": [
      "__init__",
      "serialize_message_history_type",
      "generate",
      "_generate_message_history",
      "_generate_compact_message_history",
      "_generate_react_history",
      "_generate_summary_history",
      "get_node_messages"
    ],
    "attributes": [
      "model_config"
    ],
    "code_location": {
      "file": "message_history.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 21,
      "end_line": 463
    },
    "code_snippet": "class MessageHistoryGenerator(BaseModel):\n    message_history_type: MessageHistoryType = Field(\n        default=MessageHistoryType.MESSAGES,\n        description=\"Type of message history to generate\",\n    )\n    include_file_context: bool = Field(\n        default=True, description=\"Whether to include file context in messages\"\n    )\n    include_root_node: bool = Field(default=True)\n    max_tokens: int = Field(\n        default=20000, description=\"Maximum number of tokens allowed in message history\"\n..."
  },
  {
    "name": "ActionStep",
    "docstring": "",
    "methods": [
      "is_executed",
      "model_dump",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 21,
      "end_line": 45
    },
    "code_snippet": "class ActionStep(BaseModel):\n    action: ActionArguments\n    observation: Optional[Observation] = None\n    completion: Optional[Completion] = None\n\n    def is_executed(self) -> bool:\n        \"\"\"Check if this action step has been executed by verifying if it has observations.\"\"\"\n        return self.observation is not None\n\n    def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n\n        data[\"action\"] = self.action.model_dump(**kwargs)\n        data[\"action\"][\"action_args_cl..."
  },
  {
    "name": "FeedbackData",
    "docstring": "Structured feedback data model",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 48,
      "end_line": 57
    },
    "code_snippet": "class FeedbackData(BaseModel):\n    \"\"\"Structured feedback data model\"\"\"\n\n    feedback: str = Field(..., description=\"Direct feedback to the AI assistant\")\n    analysis: Optional[str] = Field(\n        None, description=\"Analysis of the task and alternative branch attempts\"\n    )\n    suggested_node_id: Optional[int] = Field(\n        None, description=\"ID of the node that should be expanded next (optional)\"\n    )"
  },
  {
    "name": "Node",
    "docstring": "",
    "methods": [
      "action",
      "action",
      "observation",
      "observation",
      "message",
      "message",
      "stub",
      "is_leaf",
      "expanded_count",
      "is_fully_expanded",
      "is_terminal",
      "is_finished",
      "add_child",
      "set_parent",
      "get_depth",
      "is_expandable",
      "find_duplicate",
      "get_sibling_nodes",
      "get_trajectory",
      "get_expandable_descendants",
      "get_expanded_descendants",
      "get_all_nodes",
      "get_leaf_nodes",
      "_get_all_nodes",
      "get_root",
      "calculate_mean_reward",
      "total_usage",
      "equals",
      "reset",
      "clone_and_reset",
      "model_dump",
      "_reconstruct_node",
      "reconstruct",
      "_reconstruct_from_list",
      "dump_as_list",
      "load_from_file",
      "persist",
      "truncate_children_by_id",
      "has_unexecuted_actions"
    ],
    "attributes": [],
    "code_location": {
      "file": "node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 60,
      "end_line": 617
    },
    "code_snippet": "class Node(BaseModel):\n    node_id: int = Field(..., description=\"The unique identifier of the node\")\n\n    parent: Optional[\"Node\"] = Field(None, description=\"The parent node\")\n    children: List[\"Node\"] = Field(default_factory=list, description=\"The child nodes\")\n\n    artifact_changes: List[ArtifactChange] = Field(\n        default_factory=list,\n        description=\"The artifact changes associated with the node\",\n    )\n\n    user_message: Optional[str] = Field(\n        None, description=\"The user..."
  },
  {
    "name": "ContextSpan",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 27,
      "end_line": 35
    },
    "code_snippet": "class ContextSpan(BaseModel):\n    span_id: str\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    tokens: Optional[int] = None\n    pinned: bool = Field(\n        default=False,\n        description=\"Whether the span is pinned and cannot be removed from context\",\n    )"
  },
  {
    "name": "CurrentPromptSpan",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 39,
      "end_line": 41
    },
    "code_snippet": "class CurrentPromptSpan:\n    span_id: Optional[str] = None\n    tokens: int = 0"
  },
  {
    "name": "ContextFile",
    "docstring": "Represents the context of a file, managing patches that reflect changes over time.\n\nAttributes:\n    file_path (str): The path to the file within the repository.\n    accumulated_patch (Optional[str]): A Git-formatted patch representing all changes from the original content.\n    patch (Optional[str]): A Git-formatted patch representing the latest changes applied in this ContextFile.\n    spans (List[ContextSpan]): A list of spans associated with this file.\n    show_all_spans (bool): A flag to indicate whether to display all spans.",
    "methods": [
      "__init__",
      "_add_import_span",
      "get_base_content",
      "module",
      "content",
      "model_dump",
      "span_ids",
      "to_prompt",
      "_find_span",
      "_within_span",
      "_to_prompt_with_line_spans",
      "_to_prompt",
      "set_patch",
      "context_size",
      "has_span",
      "add_spans",
      "add_span",
      "_add_class_span",
      "add_line_span",
      "lines_is_in_context",
      "remove_span",
      "remove_all_spans",
      "get_spans",
      "get_block_span",
      "get_span",
      "get_patches",
      "is_new"
    ],
    "attributes": [],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 44,
      "end_line": 644
    },
    "code_snippet": "class ContextFile(BaseModel):\n    \"\"\"\n    Represents the context of a file, managing patches that reflect changes over time.\n\n    Attributes:\n        file_path (str): The path to the file within the repository.\n        accumulated_patch (Optional[str]): A Git-formatted patch representing all changes from the original content.\n        patch (Optional[str]): A Git-formatted patch representing the latest changes applied in this ContextFile.\n        spans (List[ContextSpan]): A list of spans associa..."
  },
  {
    "name": "FileContext",
    "docstring": "",
    "methods": [
      "__init__",
      "from_dir",
      "from_json",
      "from_dict",
      "load_files_from_dict",
      "model_dump",
      "snapshot",
      "restore_from_snapshot",
      "to_files_with_spans",
      "add_files_with_spans",
      "add_file",
      "add_file_with_lines",
      "remove_file",
      "exists",
      "has_runtime",
      "files",
      "test_files",
      "add_spans_to_context",
      "add_span_to_context",
      "add_line_span_to_context",
      "remove_span_from_context",
      "remove_spans_from_context",
      "get_spans",
      "get_span",
      "has_span",
      "apply",
      "has_file",
      "get_file",
      "file_exists",
      "is_directory",
      "get_context_file",
      "get_context_files",
      "context_size",
      "available_context_size",
      "save_file",
      "reset",
      "is_empty",
      "strip_line_breaks_only",
      "create_prompt",
      "create_summary",
      "add_file_context",
      "clone",
      "span_count"
    ],
    "attributes": [
      "model_config"
    ],
    "code_location": {
      "file": "file_context.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 647,
      "end_line": 1141
    },
    "code_snippet": "class FileContext(BaseModel):\n    _repo: Repository | None = PrivateAttr(None)\n    # _runtime: RuntimeEnvironment = PrivateAttr(None)\n\n    _files: Dict[str, ContextFile] = PrivateAttr(default_factory=dict)\n    # _test_files: Dict[str, TestFile] = PrivateAttr(\n    #     default_factory=dict\n    # )  # Changed to Dict\n    _max_tokens: int = PrivateAttr(default=8000)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(\n        self,\n        repo: Repository | None,\n      ..."
  },
  {
    "name": "MoatlessSolve",
    "docstring": "",
    "methods": [
      "__init__",
      "moatless_solve"
    ],
    "attributes": [],
    "code_location": {
      "file": "moatless_solve.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 22,
      "end_line": 69
    },
    "code_snippet": "class MoatlessSolve:\n    def __init__(self, repo_name:str, repo_path: str):\n        # Global variables are used here as defined above the class:\n        # instance, repo_base_dir, index_store_dir, instance_path, persist_path\n    \n        completion_model = CompletionModel(model=\"deepseek/deepseek-chat\", temperature=0.7)\n        completion_model.response_format = LLMResponseFormat.TOOLS\n        repository = create_repository(instance, repo_base_dir=repo_base_dir)\n\n        code_index = CodeIndex.f..."
  },
  {
    "name": "MessageHistoryType",
    "docstring": "",
    "methods": [
      "_missing_",
      "__str__",
      "json"
    ],
    "attributes": [
      "MESSAGES",
      "SUMMARY",
      "REACT",
      "MESSAGES_COMPACT"
    ],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 10,
      "end_line": 29
    },
    "code_snippet": "class MessageHistoryType(Enum):\n    MESSAGES = \"messages\"  # Provides all messages in sequence\n    SUMMARY = \"summary\"  # Generates one message with summarized history\n    REACT = \"react\"\n    MESSAGES_COMPACT = \"messages_compact\"\n\n    @classmethod\n    def _missing_(cls, value: str):\n        \"\"\"Handle case-insensitive enum lookup\"\"\"\n        for member in cls:\n            if member.value.lower() == value.lower():\n                return member\n        return None\n\n    def __str__(self):\n        ret..."
  },
  {
    "name": "FileWithSpans",
    "docstring": "",
    "methods": [
      "add_span_id",
      "add_span_ids",
      "__eq__"
    ],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 32,
      "end_line": 50
    },
    "code_snippet": "class FileWithSpans(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span id is a unique identifier for a code sippet. It can be a class name or function name. For functions in classes separete with a dot like 'class.function'.\",\n    )\n\n    def add_span_id(self, span_id):\n        if span_id not in sel..."
  },
  {
    "name": "RankedFileSpan",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 53,
      "end_line": 57
    },
    "code_snippet": "class RankedFileSpan(BaseModel):\n    file_path: str\n    span_id: str\n    rank: int = 0\n    tokens: int = 0"
  },
  {
    "name": "ActionView",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 60,
      "end_line": 61
    },
    "code_snippet": "class ActionView(BaseModel):\n    name: str"
  },
  {
    "name": "Attachment",
    "docstring": "Represents a file attachment in a chat message",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 64,
      "end_line": 71
    },
    "code_snippet": "class Attachment(BaseModel):\n    \"\"\"Represents a file attachment in a chat message\"\"\"\n\n    file_name: str = Field(description=\"Original name of the uploaded file\")\n    content: bytes = Field(description=\"Raw binary content of the file\")\n    mime_type: Optional[str] = Field(\n        default=None, description=\"MIME type of the file content\"\n    )"
  },
  {
    "name": "Message",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 74,
      "end_line": 76
    },
    "code_snippet": "class Message(BaseModel):\n    role: str = Field(description=\"Role of the message sender ('user' or 'assistant')\")\n    content: Optional[str] = Field(default=None, description=\"Content of the message\")"
  },
  {
    "name": "UserMessage",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 79,
      "end_line": 85
    },
    "code_snippet": "class UserMessage(Message):\n    role: Literal[\"user\"] = Field(\n        default=\"user\", description=\"Role is always 'user' for user messages\"\n    )\n    artifact_ids: Optional[List[str]] = Field(\n        default=None, description=\"List of artifact ids associated with the message\"\n    )"
  },
  {
    "name": "AssistantMessage",
    "docstring": "",
    "methods": [
      "tool_call_id"
    ],
    "attributes": [],
    "code_location": {
      "file": "schema.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
      "start_line": 88,
      "end_line": 95
    },
    "code_snippet": "class AssistantMessage(Message):\n    role: Literal[\"assistant\"] = Field(\n        default=\"assistant\",\n        description=\"Role is always 'assistant' for assistant messages\",\n    )\n    actions: Optional[List[ActionView]] = Field(\n        default=None, description=\"List of actions performed by the assistant\"\n    )"
  },
  {
    "name": "CodeQASearchTree",
    "docstring": "",
    "methods": [
      "create",
      "run_search",
      "_select",
      "_expand",
      "_simulate",
      "_backpropagate",
      "get_finished_nodes",
      "is_finished",
      "get_leaf_nodes",
      "_generate_unique_id",
      "get_best_trajectory",
      "get_all_trajectory",
      "display_value",
      "display_uct",
      "persist",
      "model_dump"
    ],
    "attributes": [],
    "code_location": {
      "file": "search_tree.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
      "start_line": 20,
      "end_line": 428
    },
    "code_snippet": "class CodeQASearchTree(BaseModel):\n    root: Node = Field(..., description=\"The root node of the search tree.\")\n    selector: Union[\n        BestFirstSelector, SoftmaxSelector, LLMSelector, FeedbackSelector\n    ] = Field(..., description=\"Selector for node selection.\")\n    agent: ActionAgent = Field(..., description=\"Agent for generating actions.\")\n    actions: List[Action] = Field(\n        default_factory=list,\n        description=\"Actions that can be used by the agent in the search tree.\",\n   ..."
  },
  {
    "name": "TextPromptModel",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 7,
      "end_line": 9
    },
    "code_snippet": "class TextPromptModel(BaseModel):\n    type: Literal[\"text\"]\n    text: str"
  },
  {
    "name": "ImageURLPromptModel",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 12,
      "end_line": 14
    },
    "code_snippet": "class ImageURLPromptModel(BaseModel):\n    type: Literal[\"image_url\"]\n    image_url: Dict[str, str]"
  },
  {
    "name": "Artifact",
    "docstring": "",
    "methods": [
      "to_prompt_format"
    ],
    "attributes": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 20,
      "end_line": 27
    },
    "code_snippet": "class Artifact(BaseModel):\n    id: str = Field(description=\"Unique identifier for the artifact\")\n    type: str = Field(description=\"Type of artifact (e.g., 'receipt')\")\n    name: str = Field(description=\"Name of the artifact\")\n\n    @abstractmethod\n    def to_prompt_format(self) -> PromptModel:\n        pass"
  },
  {
    "name": "ArtifactChange",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 30,
      "end_line": 34
    },
    "code_snippet": "class ArtifactChange(BaseModel):\n    artifact_id: str\n    change_type: Literal[\"added\", \"updated\", \"removed\"]\n    diff_details: Optional[str] = None\n    actor: Literal[\"user\", \"assistant\"]"
  },
  {
    "name": "ArtifactHandler",
    "docstring": "Defines how to load, save, update, and delete artifacts of a certain type.\nThe type parameter T specifies which Artifact subclass this handler manages.",
    "methods": [
      "load",
      "save",
      "update",
      "delete"
    ],
    "attributes": [],
    "code_location": {
      "file": "artifact.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 41,
      "end_line": 63
    },
    "code_snippet": "class ArtifactHandler(ABC, BaseModel, Generic[T]):\n    \"\"\"\n    Defines how to load, save, update, and delete artifacts of a certain type.\n    The type parameter T specifies which Artifact subclass this handler manages.\n    \"\"\"\n\n    type: str = Field(description=\"Type of artifact this handler manages\")\n\n    @abstractmethod\n    def load(self, artifact_id: str) -> T:\n        pass\n\n    @abstractmethod\n    def save(self, artifact: T) -> None:\n        pass\n\n    @abstractmethod\n    def update(self, art..."
  },
  {
    "name": "FileArtifact",
    "docstring": "",
    "methods": [
      "to_prompt_format"
    ],
    "attributes": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 17,
      "end_line": 39
    },
    "code_snippet": "class FileArtifact(Artifact):\n    type: str = \"file\"\n    file_path: str = Field(description=\"Path on disk where the artifact is stored\")\n    mime_type: Optional[str] = Field(\n        default=None, description=\"MIME type of the file content\"\n    )\n    content: bytes = Field(exclude=True)\n\n    def to_prompt_format(self) -> PromptModel:\n        if self.mime_type is None:\n            self.mime_type = \"text/plain\"\n\n        if self.mime_type.startswith(\"text/\"):\n            # Return TextPromptModel fo..."
  },
  {
    "name": "FileArtifactHandler",
    "docstring": "",
    "methods": [
      "_detect_mime_type",
      "load",
      "save",
      "update",
      "delete"
    ],
    "attributes": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
      "start_line": 42,
      "end_line": 75
    },
    "code_snippet": "class FileArtifactHandler(ArtifactHandler[FileArtifact]):\n    type: str = \"file\"\n    directory_path: Path = Field(\n        description=\"Base directory path for storing artifacts\"\n    )\n\n    def _detect_mime_type(self, file_path: str) -> str:\n        mime_type, _ = mimetypes.guess_type(file_path)\n        return mime_type or \"application/octet-stream\"\n\n    def load(self, artifact_id: str) -> FileArtifact:\n        file_path = self.directory_path / artifact_id\n        return FileArtifact(\n          ..."
  },
  {
    "name": "SimpleVectorStoreData",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 41,
      "end_line": 44
    },
    "code_snippet": "class SimpleVectorStoreData(DataClassJsonMixin):\n    text_id_to_ref_doc_id: dict[str, str] = field(default_factory=dict)\n    vector_id_to_text_id: dict[int, str] = field(default_factory=dict)\n    metadata_dict: dict[str, Any] = field(default_factory=dict)"
  },
  {
    "name": "SimpleFaissVectorStore",
    "docstring": "Simple Vector Store using Faiss as .\n\nIn this vector store, embeddings are stored within a simple, in-memory dictionary.\n\nArgs:\n    simple_vector_store_data_dict (Optional[dict]): data dict\n        containing the embeddings and doc_ids. See SimpleVectorStoreData\n        for more details.",
    "methods": [
      "__init__",
      "from_defaults",
      "client",
      "add",
      "delete",
      "query",
      "persist",
      "from_persist_dir",
      "from_index",
      "to_dict"
    ],
    "attributes": [],
    "code_location": {
      "file": "simple_faiss.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 47,
      "end_line": 292
    },
    "code_snippet": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n    \"\"\"Simple Vector Store using Faiss as .\n\n    In this vector store, embeddings are stored within a simple, in-memory dictionary.\n\n    Args:\n        simple_vector_store_data_dict (Optional[dict]): data dict\n            containing the embeddings and doc_ids. See SimpleVectorStoreData\n            for more details.\n    \"\"\"\n\n    _data: SimpleVectorStoreData = PrivateAttr()\n    _fs: fsspec.AbstractFileSystem = PrivateAttr()\n    _faiss_index: An..."
  },
  {
    "name": "CodeSnippet",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 8,
      "end_line": 19
    },
    "code_snippet": "class CodeSnippet:\n    id: str\n    file_path: str\n    content: str = None\n    distance: float = 0.0\n    tokens: int = None\n    language: str = \"python\"\n    span_ids: list[str] = None\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    start_block: Optional[str] = None\n    end_block: Optional[str] = None"
  },
  {
    "name": "SpanHit",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 22,
      "end_line": 28
    },
    "code_snippet": "class SpanHit(BaseModel):\n    span_id: str = Field(description=\"The span id of the relevant code in the file\")\n    rank: int = Field(\n        default=0,\n        description=\"The rank of relevance of the span in the file. 0 is highest.\",\n    )\n    tokens: int = Field(default=0, description=\"The number of tokens in the span.\")"
  },
  {
    "name": "SearchCodeHit",
    "docstring": "",
    "methods": [
      "span_ids",
      "add_span",
      "contains_span",
      "add_spans",
      "__str__"
    ],
    "attributes": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 31,
      "end_line": 56
    },
    "code_snippet": "class SearchCodeHit(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    spans: list[SpanHit] = Field(\n        default_factory=list,\n        description=\"The spans of the relevant code in the file\",\n    )\n\n    @property\n    def span_ids(self):\n        return [span.span_id for span in self.spans]\n\n    def add_span(self, span_id: str, rank: int = 0, tokens: int = 0):\n        if span_id not in [span.span_id for span in self.spans]:\n..."
  },
  {
    "name": "SearchCodeResponse",
    "docstring": "",
    "methods": [
      "sum_tokens"
    ],
    "attributes": [],
    "code_location": {
      "file": "types.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 59,
      "end_line": 70
    },
    "code_snippet": "class SearchCodeResponse(BaseModel):\n    message: Optional[str] = Field(\n        default=None, description=\"A message to return to the user.\"\n    )\n\n    hits: list[SearchCodeHit] = Field(\n        default_factory=list,\n        description=\"Search results.\",\n    )\n\n    def sum_tokens(self):\n        return sum([sum([span.tokens for span in hit.spans]) for hit in self.hits])"
  },
  {
    "name": "CodeIndex",
    "docstring": "",
    "methods": [
      "__init__",
      "from_persist_dir",
      "from_url",
      "from_index_name",
      "from_repository",
      "dict",
      "semantic_search",
      "find_class",
      "find_function",
      "find_by_name",
      "find_test_files",
      "_find_by_test_pattern",
      "_create_search_hit",
      "_vector_search",
      "run_ingestion",
      "persist"
    ],
    "attributes": [],
    "code_location": {
      "file": "code_index.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 47,
      "end_line": 1002
    },
    "code_snippet": "class CodeIndex:\n    def __init__(\n        self,\n        file_repo: Repository,\n        index_name: Optional[str] = None,\n        vector_store: \"BasePydanticVectorStore | None\" = None,\n        docstore: \"DocumentStore | None\" = None,\n        embed_model: \"BaseEmbedding | None\" = None,\n        blocks_by_class_name: Optional[dict] = None,\n        blocks_by_function_name: Optional[dict] = None,\n        settings: IndexSettings | None = None,\n        max_results: int = 25,\n        max_hits_without_ex..."
  },
  {
    "name": "CommentStrategy",
    "docstring": "",
    "methods": [],
    "attributes": [
      "INCLUDE",
      "ASSOCIATE",
      "EXCLUDE"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 8,
      "end_line": 16
    },
    "code_snippet": "class CommentStrategy(Enum):\n    # Keep comments\n    INCLUDE = \"include\"\n\n    # Always associate comments before a code block with the code block\n    ASSOCIATE = \"associate\"\n\n    # Exclude comments in parsed chunks\n    EXCLUDE = \"exclude\""
  },
  {
    "name": "IndexSettings",
    "docstring": "",
    "methods": [
      "to_serializable_dict",
      "persist",
      "from_persist_dir"
    ],
    "attributes": [],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 19,
      "end_line": 52
    },
    "code_snippet": "class IndexSettings(BaseModel):\n    embed_model: str = Field(\n        default=\"text-embedding-3-small\", description=\"The embedding model to use.\"\n    )\n    dimensions: int = Field(\n        default=1536, description=\"The number of dimensions of the vectors.\"\n    )\n\n    language: str = Field(default=\"python\", description=\"The language of the code.\")\n    min_chunk_size: int = Field(default=100, description=\"The minimum chunk size.\")\n    chunk_size: int = Field(default=750, description=\"The soft max..."
  },
  {
    "name": "EpicSplitter",
    "docstring": "",
    "methods": [
      "__init__",
      "class_name",
      "_parse_nodes",
      "_chunk_contents",
      "_chunk_block",
      "_merge_chunks",
      "_create_path_tree",
      "_ignore_comment",
      "_to_context_string",
      "_contains_block_paths",
      "_create_node",
      "_count_tokens"
    ],
    "attributes": [],
    "code_location": {
      "file": "epic_split.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 41,
      "end_line": 517
    },
    "code_snippet": "class EpicSplitter(NodeParser):\n    language: str = Field(\n        default=\"python\", description=\"Language of the code blocks to parse.\"\n    )\n\n    text_splitter: TextSplitter = Field(\n        description=\"Text splitter to use for splitting non code documents into nodes.\"\n    )\n\n    include_non_code_files: bool = Field(\n        default=True, description=\"Whether or not to include non code files.\"\n    )\n\n    non_code_file_extensions: list[str] = Field(\n        default=[\"md\", \"txt\"],\n        descr..."
  },
  {
    "name": "CodeNode",
    "docstring": "",
    "methods": [
      "hash",
      "_clean_text"
    ],
    "attributes": [],
    "code_location": {
      "file": "code_node.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 6,
      "end_line": 22
    },
    "code_snippet": "class CodeNode(TextNode):\n    # Skip start and end line in metadata to try to lower the number of changes and triggers of new embeddings.\n    @property\n    def hash(self):\n        metadata = self.metadata.copy()\n        metadata.pop(\"start_line\", None)\n        metadata.pop(\"end_line\", None)\n        metadata.pop(\"tokens\", None)\n        cleaned_text = self._clean_text(self.text)\n        doc_identity = cleaned_text + str(metadata)\n        return str(sha256(doc_identity.encode(\"utf-8\", \"surrogatepas..."
  },
  {
    "name": "VoyageEmbeddingWithRetry",
    "docstring": "",
    "methods": [
      "_get_embedding"
    ],
    "attributes": [],
    "code_location": {
      "file": "retry_voyage_embedding.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
      "start_line": 11,
      "end_line": 40
    },
    "code_snippet": "class VoyageEmbeddingWithRetry(VoyageEmbedding):\n    @retry(\n        wait=wait_random_exponential(multiplier=1, max=60), stop=stop_after_attempt(6)\n    )\n    def _get_embedding(self, texts: List[str], input_type: str) -> List[List[float]]:\n        try:\n            return self._client.embed(\n                texts,\n                model=self.model_name,\n                input_type=input_type,\n                truncation=self.truncation,\n            ).embeddings\n        except InvalidRequestError as ..."
  },
  {
    "name": "FindCodeSnippetArgs",
    "docstring": "Use this when you know the exact code you want to find.\n     It will run the command: grep -n -r \"code_snippet\" \"file_pattern\"\n\nPerfect for:\n- Finding specific constant definitions: code_snippet=\"MAX_RETRIES = 3\"\n- Finding decorator usage: code_snippet=\"@retry(max_attempts=3)\"\n- Finding specific imports: code_snippet=\"from datetime import datetime\"\n- Finding configuration patterns: code_snippet=\"DEBUG = os.getenv('DEBUG', False)\"\n\nNote: You must know the exact code snippet. Use SemanticSearch if you only know\nwhat the code does but not its exact implementation.",
    "methods": [
      "validate_snippet",
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 14,
      "end_line": 53
    },
    "code_snippet": "class FindCodeSnippetArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact code you want to find.\n         It will run the command: grep -n -r \"code_snippet\" \"file_pattern\"\n\n    Perfect for:\n    - Finding specific constant definitions: code_snippet=\"MAX_RETRIES = 3\"\n    - Finding decorator usage: code_snippet=\"@retry(max_attempts=3)\"\n    - Finding specific imports: code_snippet=\"from datetime import datetime\"\n    - Finding configuration patterns: code_snippet=\"DEBUG = os.getenv('DEBUG', ..."
  },
  {
    "name": "FindCodeSnippet",
    "docstring": "",
    "methods": [
      "_search_for_context",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_code_snippet.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 56,
      "end_line": 119
    },
    "code_snippet": "class FindCodeSnippet(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindCodeSnippetArgs\n\n    max_hits: int = Field(\n        10,\n        description=\"The maximum number of search results to return. Default is 10.\",\n    )\n\n    def _search_for_context(\n        self, args: FindCodeSnippetArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.code_snippet} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository...."
  },
  {
    "name": "FindClassArgs",
    "docstring": "Use this when you know the exact name of a class you want to find.\n\nPerfect for:\n- Finding class implementations: class_name=\"UserRepository\"\n- Locating test classes: class_name=\"TestUserAuthentication\"\n- Finding base classes: class_name=\"BaseController\"\n- Finding classes in specific modules: class_name=\"Config\", file_pattern=\"src/config/*.py\"",
    "methods": [
      "validate_names",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 13,
      "end_line": 48
    },
    "code_snippet": "class FindClassArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact name of a class you want to find.\n\n    Perfect for:\n    - Finding class implementations: class_name=\"UserRepository\"\n    - Locating test classes: class_name=\"TestUserAuthentication\"\n    - Finding base classes: class_name=\"BaseController\"\n    - Finding classes in specific modules: class_name=\"Config\", file_pattern=\"src/config/*.py\"\n    \"\"\"\n\n    class_name: str = Field(\n        ...,\n        description=\"Specific class nam..."
  },
  {
    "name": "FindClass",
    "docstring": "",
    "methods": [
      "to_prompt",
      "_search",
      "_select_span_instructions",
      "_search_for_alternative_suggestion",
      "get_evaluation_criteria",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_class.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 51,
      "end_line": 109
    },
    "code_snippet": "class FindClass(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindClassArgs\n\n    def to_prompt(self):\n        prompt = f\"Searching for class: {self.args.class_name}\"\n        if self.args.file_pattern:\n            prompt += f\" in files matching the pattern: {self.args.file_pattern}\"\n        return prompt\n\n    def _search(self, args: FindClassArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.class_name} (file_pattern: {args.file_pattern})\"\n ..."
  },
  {
    "name": "SearchBaseArgs",
    "docstring": "",
    "methods": [
      "validate_file_pattern"
    ],
    "attributes": [],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 47,
      "end_line": 59
    },
    "code_snippet": "class SearchBaseArgs(ActionArguments, ABC):\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific files or directories.\",\n    )\n\n    @field_validator(\"file_pattern\")\n    @classmethod\n    def validate_file_pattern(cls, v):\n        if v:\n            if \",\" in v:\n                raise ValueError(\"File pattern cannot contain commas\")\n        return v"
  },
  {
    "name": "IdentifiedSpans",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 62,
      "end_line": 71
    },
    "code_snippet": "class IdentifiedSpans(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: int = Field(\n        description=\"Starting line number of the relevant code section.\"\n    )\n    end_line: int = Field(\n        description=\"Ending line number of the relevant code section.\"\n    )"
  },
  {
    "name": "Identify",
    "docstring": "Identify if the provided search result is relevant to the reported issue.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 74,
      "end_line": 85
    },
    "code_snippet": "class Identify(StructuredOutput):\n    \"\"\"Identify if the provided search result is relevant to the reported issue.\"\"\"\n\n    thoughts: Optional[str] = Field(\n        None,\n        description=\"Your thoughts and analysis on the search results and how they relate to the reported issue.\",\n    )\n\n    identified_spans: Optional[list[IdentifiedSpans]] = Field(\n        default=None,\n        description=\"Files and code sections in the search results identified as relevant to the reported issue.\",\n    )"
  },
  {
    "name": "SearchBaseAction",
    "docstring": "",
    "methods": [
      "__init__",
      "execute",
      "_search_for_context",
      "_select_span_instructions",
      "_select_span_response_prompt",
      "_search",
      "_search_for_alternative_suggestion",
      "_identify_code",
      "get_evaluation_criteria",
      "get_reward_scale",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "search_base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 88,
      "end_line": 438
    },
    "code_snippet": "class SearchBaseAction(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = SearchBaseArgs\n\n    max_search_tokens: int = Field(\n        2000,\n        description=\"The maximum number of tokens allowed in the search results.\",\n    )\n    max_identify_tokens: int = Field(\n        8000,\n        description=\"The maximum number of tokens allowed in the identified code sections.\",\n    )\n    max_identify_prompt_tokens: int = Field(\n        16000,\n        description=\"The maximum number of tokens a..."
  },
  {
    "name": "FinishArgs",
    "docstring": "Indicate that the generated code answer is accurate and complete for the user's query.",
    "methods": [
      "answer",
      "to_prompt",
      "equals"
    ],
    "attributes": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 15,
      "end_line": 41
    },
    "code_snippet": "class FinishArgs(ActionArguments):\n    \"\"\"Indicate that the generated code answer is accurate and complete for the user's query.\"\"\"\n\n    answer: str = Field(\n        ...,\n        description=\"The generated answer to the user's query.\",\n    )\n\n    thoughts: str = Field(\n        ...,\n        description=\"Your reasoning about why the generated code answer accurately and completely addresses the user's query.\",\n    )\n\n\n    class Config:\n        title = \"Finish\" # Finish providing the answer to the u..."
  },
  {
    "name": "Finish",
    "docstring": "",
    "methods": [
      "execute",
      "get_evaluation_criteria",
      "get_reward_scale",
      "get_value_function_prompt",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "finish.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 44,
      "end_line": 139
    },
    "code_snippet": "class Finish(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = FinishArgs\n\n    def execute(\n        self,\n        args: FinishArgs,\n        file_context: FileContext | None = None, # Keep for potential future context use\n    ):\n        # Return the answer from FinishArgs\n        return Observation(message=args.answer, terminal=True)\n\n    @classmethod\n    def get_evaluation_criteria(cls, trajectory_length: int) -> List[str]:\n        # Adapted criteria for Code QA Answering\n        retur..."
  },
  {
    "name": "RejectArgs",
    "docstring": "Reject the task and explain why.",
    "methods": [
      "to_prompt",
      "equals"
    ],
    "attributes": [],
    "code_location": {
      "file": "reject.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 10,
      "end_line": 22
    },
    "code_snippet": "class RejectArgs(ActionArguments):\n    \"\"\"Reject the task and explain why.\"\"\"\n\n    rejection_reason: str = Field(..., description=\"Explanation for rejection.\")\n\n    class Config:\n        title = \"Reject\"\n\n    def to_prompt(self):\n        return f\"Reject with reason: {self.rejection_reason}\"\n\n    def equals(self, other: \"ActionArguments\") -> bool:\n        return isinstance(other, RejectArgs)"
  },
  {
    "name": "Reject",
    "docstring": "",
    "methods": [
      "execute"
    ],
    "attributes": [],
    "code_location": {
      "file": "reject.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 25,
      "end_line": 33
    },
    "code_snippet": "class Reject(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = RejectArgs\n\n    def execute(\n        self,\n        args: RejectArgs,\n        file_context: FileContext | None = None,\n    ):\n        return Observation(message=args.rejection_reason, terminal=True)"
  },
  {
    "name": "ActionArguments",
    "docstring": "",
    "methods": [
      "get_name",
      "format_for_llm",
      "format_name_for_llm",
      "to_tool_call",
      "from_tool_call",
      "equals",
      "to_prompt",
      "short_summary",
      "fix_thoughts",
      "fix_null_fields",
      "get_action_args",
      "_load_action_args",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 17,
      "end_line": 131
    },
    "code_snippet": "class ActionArguments(StructuredOutput, ABC):\n    thoughts: str = Field(..., description=\"Your reasoning for the action.\")\n\n    class Config:\n        title = \"Action\"\n\n    @classmethod\n    def get_name(cls) -> str:\n        \"\"\"Returns the action name for the class based on Config title.\"\"\"\n        return str(getattr(cls.Config, \"title\", cls.__name__))\n\n    def format_for_llm(self) -> str:\n        \"\"\"Format the action name for LLM consumption\"\"\"\n        return str(self.name)\n\n    @classmethod\n    ..."
  },
  {
    "name": "RewardScaleEntry",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 134,
      "end_line": 137
    },
    "code_snippet": "class RewardScaleEntry(BaseModel):\n    min_value: int\n    max_value: int\n    description: str"
  },
  {
    "name": "Observation",
    "docstring": "",
    "methods": [
      "create"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 140,
      "end_line": 165
    },
    "code_snippet": "class Observation(BaseModel):\n    message: Optional[str] = Field(\n        None,\n        description=\"The message returned to the agent, will be displayed in message history.\",\n    )\n    summary: Optional[str] = Field(\n        None,\n        description=\"Summary of the observation, will be displayed in summarised message history.\",\n    )\n    terminal: bool = Field(\n        False, description=\"Indicates if this action results in a terminal state\"\n    )\n    expect_correction: bool = Field(\n        F..."
  },
  {
    "name": "FewShotExample",
    "docstring": "",
    "methods": [
      "create"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 168,
      "end_line": 176
    },
    "code_snippet": "class FewShotExample(BaseModel):\n    user_input: str = Field(..., description=\"The user's input/question\")\n    action: ActionArguments = Field(\n        ..., description=\"The expected response as ActionArguments\"\n    )\n\n    @classmethod\n    def create(cls, user_input: str, action: ActionArguments) -> \"FewShotExample\":\n        return cls(user_input=user_input, action=action)"
  },
  {
    "name": "ActionError",
    "docstring": "Error",
    "methods": [
      "to_prompt"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 179,
      "end_line": 188
    },
    "code_snippet": "class ActionError(ActionArguments):\n    \"\"\"Error\"\"\"\n\n    error: str = Field(..., description=\"Error.\")\n\n    class Config:\n        title = \"Error\"\n\n    def to_prompt(self):\n        return f\"Error: {self.error}\""
  },
  {
    "name": "RetryException",
    "docstring": "Exception raised when an action needs to be retried with corrected arguments.",
    "methods": [
      "__init__"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 191,
      "end_line": 197
    },
    "code_snippet": "class RetryException(Exception):\n    \"\"\"Exception raised when an action needs to be retried with corrected arguments.\"\"\"\n\n    def __init__(self, message: str, action_args: ActionArguments):\n        super().__init__(message)\n        self.message = message\n        self.action_args = action_args"
  },
  {
    "name": "CodeSpan",
    "docstring": "",
    "methods": [
      "log_name",
      "log_name"
    ],
    "attributes": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 22,
      "end_line": 47
    },
    "code_snippet": "class CodeSpan(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: Optional[int] = Field(\n        None, description=\"The start line of the code to add to context.\"\n    )\n    end_line: Optional[int] = Field(\n        None, description=\"The end line of the code to add to context.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span..."
  },
  {
    "name": "FurtherViewCodeArgs",
    "docstring": "View the code in a file or a specific code span.",
    "methods": [
      "log_name",
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 50,
      "end_line": 86
    },
    "code_snippet": "class FurtherViewCodeArgs(ActionArguments):\n    \"\"\"View the code in a file or a specific code span.\"\"\"\n\n    thoughts: str = Field(..., description=\"Your thoughts on the code change.\")\n    files: List[CodeSpan] = Field(\n        ..., description=\"The code that should be provided in the file context.\"\n    )\n\n    class Config:\n        title = \"FurtherViewCode\"\n\n    @property\n    def log_name(self):\n        if len(self.files) == 1:\n            return f\"FurtherViewCode({self.files[0].log_name})\"\n     ..."
  },
  {
    "name": "FurtherViewCode",
    "docstring": "",
    "methods": [
      "__init__",
      "execute",
      "_search_for_alternative_suggestion",
      "_select_span_instructions",
      "get_few_shot_examples",
      "create_retry_message",
      "create_hint",
      "span_id_list",
      "get_evaluation_criteria",
      "get_reward_scale"
    ],
    "attributes": [
      "args_schema"
    ],
    "code_location": {
      "file": "further_view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 89,
      "end_line": 371
    },
    "code_snippet": "class FurtherViewCode(Action, IdentifyMixin):\n    args_schema = FurtherViewCodeArgs\n\n    _repository: Repository = PrivateAttr()\n\n    def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n\n    max_tokens: int = Field(\n        3000,\n        description=\"The maximum number of tokens in the requested co..."
  },
  {
    "name": "CodeSpan",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 22,
      "end_line": 47
    },
    "code_snippet": "class CodeSpan(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: Optional[int] = Field(\n        None, description=\"The start line of the code to add to context.\"\n    )\n    end_line: Optional[int] = Field(\n        None, description=\"The end line of the code to add to context.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span..."
  },
  {
    "name": "ViewCodeArgs",
    "docstring": "View the code in a file or a specific code span.",
    "methods": [
      "log_name",
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 50,
      "end_line": 86
    },
    "code_snippet": "class ViewCodeArgs(ActionArguments):\n    \"\"\"View the code in a file or a specific code span.\"\"\"\n\n    thoughts: str = Field(..., description=\"Your thoughts on the code change.\")\n    files: List[CodeSpan] = Field(\n        ..., description=\"The code that should be provided in the file context.\"\n    )\n\n    class Config:\n        title = \"ViewCode\"\n\n    @property\n    def log_name(self):\n        if len(self.files) == 1:\n            return f\"ViewCode({self.files[0].log_name})\"\n        else:\n            ..."
  },
  {
    "name": "ViewCode",
    "docstring": "",
    "methods": [
      "__init__",
      "execute",
      "_search_for_alternative_suggestion",
      "_select_span_instructions",
      "get_few_shot_examples",
      "create_retry_message",
      "create_hint",
      "span_id_list",
      "get_evaluation_criteria",
      "get_reward_scale"
    ],
    "attributes": [
      "args_schema"
    ],
    "code_location": {
      "file": "view_code.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 89,
      "end_line": 371
    },
    "code_snippet": "class ViewCode(Action, IdentifyMixin):\n    args_schema = ViewCodeArgs\n\n    _repository: Repository = PrivateAttr()\n\n    def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n\n    max_tokens: int = Field(\n        3000,\n        description=\"The maximum number of tokens in the requested code.\",\n    )\n\n ..."
  },
  {
    "name": "Action",
    "docstring": "",
    "methods": [
      "__init__",
      "execute",
      "_execute",
      "name",
      "get_name",
      "get_evaluation_criteria",
      "get_reward_scale",
      "generate_reward_scale_entries",
      "get_reward_range",
      "get_value_function_prompt",
      "get_few_shot_examples",
      "get_action_by_args_class",
      "get_action_by_name",
      "_load_actions",
      "model_validate",
      "model_dump"
    ],
    "attributes": [
      "model_config"
    ],
    "code_location": {
      "file": "action.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 24,
      "end_line": 255
    },
    "code_snippet": "class Action(BaseModel, ABC):\n    args_schema: ClassVar[Type[ActionArguments]]\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    def execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        \"\"\"\n        Execute the action.\n        \"\"\"\n\n        message = self._execute(args, file_context=file_context)\n        return Observation.create(message)..."
  },
  {
    "name": "FindCalledObjectArgs",
    "docstring": "这个函数就是FindCodeSnippet套了一层壳，输入是模型认为有用的调用对象的名字，会返回一段代码中被调用的对象的具体实现",
    "methods": [
      "validate_snippet",
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 26,
      "end_line": 56
    },
    "code_snippet": "class FindCalledObjectArgs(SearchBaseArgs):\n    \"\"\"\n    这个函数就是FindCodeSnippet套了一层壳，输入是模型认为有用的调用对象的名字，会返回一段代码中被调用的对象的具体实现\n    \"\"\"\n\n    called_object: str = Field(..., description=\"The exact called object to find.\")\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific file types or directories. \",\n    )\n\n    class Config:\n        title = \"FindCalledObject\"\n\n    @model_validator(mode=\"after\")\n    def validate_snippet..."
  },
  {
    "name": "FindCalledObject",
    "docstring": "",
    "methods": [
      "_search_for_context",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_called_objects.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 59,
      "end_line": 130
    },
    "code_snippet": "class FindCalledObject(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindCalledObjectArgs\n\n    max_hits: int = Field(\n        10,\n        description=\"The maximum number of search results to return. Default is 10.\",\n    )\n\n    def _search_for_context(\n        self, args: FindCalledObjectArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.called_object} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._reposit..."
  },
  {
    "name": "ListFilesArgs",
    "docstring": "List files and directories in a specified directory.",
    "methods": [
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 13,
      "end_line": 29
    },
    "code_snippet": "class ListFilesArgs(ActionArguments):\n    \"\"\"List files and directories in a specified directory.\"\"\"\n\n    directory: str = Field(\n        default=\"\",\n        description=\"The directory path to list. Empty string means root directory.\",\n    )\n\n    class Config:\n        title = \"ListFiles\"\n\n    def to_prompt(self):\n        return f\"List contents of directory: {self.directory or '(root)'}\"\n\n    def short_summary(self) -> str:\n        param_str = f\"directory={self.directory}\"\n        return f\"{self...."
  },
  {
    "name": "ListFiles",
    "docstring": "",
    "methods": [
      "execute",
      "get_evaluation_criteria",
      "get_few_shot_examples"
    ],
    "attributes": [
      "args_schema"
    ],
    "code_location": {
      "file": "list_files.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 32,
      "end_line": 100
    },
    "code_snippet": "class ListFiles(Action):\n    args_schema = ListFilesArgs\n\n    def execute(\n        self,\n        args: ListFilesArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if not file_context._repo:\n            raise RuntimeError(\"Repository not available for listing files.\")\n\n        try:\n            result = file_context._repo.list_directory(args.directory)\n\n            message = f\"Contents of directory '{args.directory or '(root)'}'\\n\\n\"\n\n            if result[\"direct..."
  },
  {
    "name": "IdentifyMixin",
    "docstring": "Mixin that provides identify flow functionality for large code sections.",
    "methods": [
      "_identify_code"
    ],
    "attributes": [],
    "code_location": {
      "file": "identify_mixin.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 19,
      "end_line": 123
    },
    "code_snippet": "class IdentifyMixin:\n    \"\"\"Mixin that provides identify flow functionality for large code sections.\"\"\"\n\n    completion_model: Optional[CompletionModel] = Field(\n        None,\n        description=\"The completion model used to identify relevant code sections.\",\n    )\n    max_identify_tokens: int = Field(\n        8000,\n        description=\"The maximum number of tokens allowed in the identified code sections.\",\n    )\n    max_identify_prompt_tokens: int = Field(\n        16000,\n        description=\"T..."
  },
  {
    "name": "SemanticSearchArgs",
    "docstring": "Use this when you don't know exact names or code but want to find related functionality.\n\nPerfect for:\n- Finding functionality by description: query=\"code that handles password hashing\"\n- Finding related test cases: query=\"tests for user registration\", category=\"test\"\n- Finding implementations: query=\"database connection pooling\", category=\"implementation\"\n- Finding patterns: query=\"error handling for API requests\"\n\nThis is the most flexible search when you:\n- Don't know exact function/class names\n- Want to find similar implementations\n- Need to discover related code\n- Want to explore how certain features are implemented",
    "methods": [
      "to_prompt",
      "validate_query",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 10,
      "end_line": 53
    },
    "code_snippet": "class SemanticSearchArgs(SearchBaseArgs):\n    \"\"\"Use this when you don't know exact names or code but want to find related functionality.\n\n    Perfect for:\n    - Finding functionality by description: query=\"code that handles password hashing\"\n    - Finding related test cases: query=\"tests for user registration\", category=\"test\"\n    - Finding implementations: query=\"database connection pooling\", category=\"implementation\"\n    - Finding patterns: query=\"error handling for API requests\"\n\n    This is..."
  },
  {
    "name": "SemanticSearch",
    "docstring": "",
    "methods": [
      "_search",
      "_search_for_alternative_suggestion",
      "get_evaluation_criteria",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "semantic_search.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 56,
      "end_line": 110
    },
    "code_snippet": "class SemanticSearch(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = SemanticSearchArgs\n\n    def _search(self, args: SemanticSearchArgs) -> SearchCodeResponse:\n        return self._code_index.semantic_search(\n            args.query,\n            file_pattern=args.file_pattern,\n            max_results=self.max_hits,\n            category=args.category,\n        )\n\n    def _search_for_alternative_suggestion(\n        self, args: SemanticSearchArgs\n    ) -> SearchCodeResponse:\n   ..."
  },
  {
    "name": "FindFunctionArgs",
    "docstring": "Use this when you know the exact name of a function or method you want to find.\n\nPerfect for:\n- Finding test cases: function_name=\"test_user_login\"\n- Locating specific implementations: function_name=\"process_payment\"\n- Finding all methods with a name: function_name=\"validate\"\n- Finding a specific class method: function_name=\"save\", class_name=\"UserRepository\"",
    "methods": [
      "validate_names",
      "to_prompt",
      "short_summary"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 11,
      "end_line": 55
    },
    "code_snippet": "class FindFunctionArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact name of a function or method you want to find.\n\n    Perfect for:\n    - Finding test cases: function_name=\"test_user_login\"\n    - Locating specific implementations: function_name=\"process_payment\"\n    - Finding all methods with a name: function_name=\"validate\"\n    - Finding a specific class method: function_name=\"save\", class_name=\"UserRepository\"\n    \"\"\"\n\n    function_name: str = Field(\n        ...,\n        descripti..."
  },
  {
    "name": "FindFunction",
    "docstring": "",
    "methods": [
      "_search",
      "_search_for_alternative_suggestion",
      "get_evaluation_criteria",
      "get_few_shot_examples"
    ],
    "attributes": [],
    "code_location": {
      "file": "find_function.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
      "start_line": 58,
      "end_line": 141
    },
    "code_snippet": "class FindFunction(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindFunctionArgs\n\n    def _search(self, args: FindFunctionArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.function_name} (class_name: {args.class_name}, file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_function(\n            args.function_name,\n            class_name=args.class_name,\n            file_pattern=args.file_pattern,\n        )\n\n   ..."
  },
  {
    "name": "CodeQAAgent",
    "docstring": "",
    "methods": [
      "create"
    ],
    "attributes": [],
    "code_location": {
      "file": "code_qa_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 37,
      "end_line": 123
    },
    "code_snippet": "class CodeQAAgent(ActionAgent):\n    @classmethod\n    def create(\n        cls,\n        repository: Repository,\n        completion_model: CompletionModel,\n        preset_actions: List[Action] | None = None,\n        code_index: CodeIndex | None = None,\n        edit_completion_model: CompletionModel | None = None,\n        message_history_type: MessageHistoryType | None = None,\n        thoughts_in_action: bool = False,\n        **kwargs,\n    ):\n        # Clone the completion model to ensure we have ou..."
  },
  {
    "name": "AgentSettings",
    "docstring": "",
    "methods": [
      "__eq__",
      "model_dump",
      "model_validate"
    ],
    "attributes": [
      "model_config"
    ],
    "code_location": {
      "file": "settings.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 9,
      "end_line": 51
    },
    "code_snippet": "class AgentSettings(BaseModel):\n    model_config = {\"frozen\": True}\n\n    completion_model: CompletionModel = Field(\n        ..., description=\"Completion model to be used for generating completions\"\n    )\n    system_prompt: Optional[str] = Field(\n        None, description=\"System prompt to be used for generating completions\"\n    )\n    actions: List[str] = Field(default_factory=list)\n    message_history_type: MessageHistoryType = Field(\n        default=MessageHistoryType.MESSAGES,\n        descript..."
  },
  {
    "name": "ActionAgent",
    "docstring": "",
    "methods": [
      "__init__",
      "from_agent_settings",
      "set_actions",
      "verify_actions",
      "run",
      "_execute",
      "generate_system_prompt",
      "generate_few_shots",
      "model_dump",
      "model_validate",
      "from_dict",
      "completion",
      "completion"
    ],
    "attributes": [],
    "code_location": {
      "file": "agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
      "start_line": 27,
      "end_line": 371
    },
    "code_snippet": "class ActionAgent(BaseModel):\n    system_prompt: str = Field(\n        ..., description=\"System prompt to be used for generating completions\"\n    )\n    use_few_shots: bool = Field(\n        True, description=\"Whether to use few-shot examples for generating completions\"\n    )\n    thoughts_in_action: bool = Field(True, description=\"\")\n    actions: List[Action] = Field(default_factory=list)\n    message_generator: MessageHistoryGenerator = Field(\n        default_factory=lambda: MessageHistoryGenerator..."
  },
  {
    "name": "UCTScore",
    "docstring": "",
    "methods": [
      "__str__"
    ],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 72,
      "end_line": 105
    },
    "code_snippet": "class UCTScore:\n    final_score: float = 0.0\n    exploitation: float = 0.0\n    exploration: float = 0.0\n    depth_bonus: float = 0.0\n    depth_penalty: float = 0.0\n    high_value_leaf_bonus: float = 0.0\n    high_value_bad_children_bonus: float = 0.0\n    high_value_child_penalty: float = 0.0\n    high_value_parent_bonus: float = 0.0\n    finished_trajectory_penalty: float = 0.0\n    expect_correction_bonus: float = 0.0\n    diversity_bonus: float = 0.0\n    duplicate_child_penalty: float = 0.0\n    dup..."
  },
  {
    "name": "Selector",
    "docstring": "",
    "methods": [
      "select",
      "_get_reward",
      "_select_node",
      "uct_score",
      "calculate_exploitation",
      "calculate_exploration",
      "calculate_depth_bonus",
      "calculate_depth_penalty",
      "calculate_high_value_leaf_bonus",
      "calculate_high_value_bad_children_bonus",
      "calculate_high_value_child_penalty",
      "calculate_high_value_parent_bonus",
      "calculate_finished_trajectory_penalty",
      "is_on_finished_trajectory",
      "calculate_expect_correction_bonus",
      "calculate_diversity_bonus",
      "calculate_duplicate_child_penalty",
      "calculate_duplicate_action_penalty",
      "get_similarity",
      "model_validate",
      "model_dump"
    ],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 108,
      "end_line": 581
    },
    "code_snippet": "class Selector(BaseModel):\n    type: Literal[\"BestFirstSelector\", \"SoftmaxSelector\"] = Field(\n        ..., description=\"The type of selector\"\n    )\n    minimum_reward_threshold: float = Field(\n        default=-float(\"inf\"),\n        description=\"Minimum reward threshold for node selection. Nodes below this value will not be considered.\",\n    )\n    exploitation_weight: float = Field(\n        default=1.0,\n        description=\"Weight factor for the exploitation term in the UCT score calculation. Hig..."
  },
  {
    "name": "BestFirstSelector",
    "docstring": "",
    "methods": [
      "_select_node"
    ],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 584,
      "end_line": 610
    },
    "code_snippet": "class BestFirstSelector(Selector):\n    type: Literal[\"BestFirstSelector\"] = \"BestFirstSelector\"\n\n    def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        sorted_nodes = sorted(\n            nodes_with_scores, key=lambda x: x[1].final_score, reverse=True\n        )\n\n        # Log top nodes with detailed score breakdowns\n        top_nodes = sorted_nodes[: min(len(sorted_nod..."
  },
  {
    "name": "SoftmaxSelector",
    "docstring": "",
    "methods": [
      "_select_node"
    ],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 613,
      "end_line": 650
    },
    "code_snippet": "class SoftmaxSelector(Selector):\n    type: Literal[\"SoftmaxSelector\"] = \"SoftmaxSelector\"\n\n    def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        uct_scores = [score.final_score for _, score in nodes_with_scores]\n\n        # Calculate softmax probabilities\n        softmax_scores = np.exp(uct_scores - np.max(uct_scores))\n        probabilities = softmax_scores / softmax_..."
  },
  {
    "name": "NodeSelection",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 657,
      "end_line": 674
    },
    "code_snippet": "class NodeSelection(OpenAISchema):\n    # \"\"\"\n\n    # Scores range from -100 to 100.\n    # Select expandable nodes.\n\n    # OUTPUT FORMAT:\n    # <node_id>: Selected node ID\n    # <explanation>: Adress the agent responsible for generating the next action directly (e.g. \"You should ...\") with the following information:\n    #     ANCESTRY: Parent context, sibling outcomes, path differences.\n    #     CURRENT: Node state/potential, relation to successful paths.\n    #     DESCENDANTS: Child outcomes, pi..."
  },
  {
    "name": "LLMSelector",
    "docstring": "",
    "methods": [
      "__init__",
      "get_action_definitions",
      "build_ascii_tree",
      "select"
    ],
    "attributes": [],
    "code_location": {
      "file": "selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 684,
      "end_line": 904
    },
    "code_snippet": "class LLMSelector(Selector):\n    type: Literal[\"LLMSelector\"] = \"LLMSelector\"\n    completion: Optional[CompletionModel] = Field(\n        default=None, description=\"The completion model used to generate responses\"\n    )\n    max_iterations: Optional[int] = Field(\n        default=None, description=\"Maximum number of iterations for the selector\"\n    )\n\n    def __init__(\n        self, completion: CompletionModel = None, max_iterations: int = None, **kwargs\n    ):\n        # Initialize with all fields,..."
  },
  {
    "name": "FeedbackSelector",
    "docstring": "A selector that uses previously generated feedback to make selection decisions.",
    "methods": [
      "select"
    ],
    "attributes": [],
    "code_location": {
      "file": "feedback_selector.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
      "start_line": 13,
      "end_line": 48
    },
    "code_snippet": "class FeedbackSelector(Selector):\n    \"\"\"A selector that uses previously generated feedback to make selection decisions.\"\"\"\n\n    type: Literal[\"feedback\"] = Field(\"feedback\")\n\n    def select(self, nodes: List[Node]) -> Optional[Node]:\n        \"\"\"Select a node based on existing feedback analysis.\"\"\"\n        if not nodes:\n            return None\n\n        for node in nodes:\n            # Check for existing feedback in node.completions\n            if hasattr(node, \"completions\") and \"feedback\" in no..."
  },
  {
    "name": "Message",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 13,
      "end_line": 15
    },
    "code_snippet": "class Message(BaseModel):\n    role: str = Field(..., description=\"The role of the sender\")\n    content: Optional[str] = Field(None, description=\"The message content\")"
  },
  {
    "name": "ToolCall",
    "docstring": "",
    "methods": [
      "__post_init__"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 18,
      "end_line": 27
    },
    "code_snippet": "class ToolCall(BaseModel):\n    name: str = Field(..., description=\"The name of the tool being called\")\n    type: Optional[str] = Field(None, description=\"The type of tool call\")\n    input: Optional[dict[str, Any]] = Field(\n        None, description=\"The input parameters for the tool\"\n    )\n\n    def __post_init__(self):\n        # Ensure name is always a string\n        self.name = str(self.name)"
  },
  {
    "name": "AssistantMessage",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 30,
      "end_line": 47
    },
    "code_snippet": "class AssistantMessage(Message):\n    role: str = Field(\"assistant\", description=\"The role of the assistant\")\n    content: Optional[str] = Field(None, description=\"The assistant's message content\")\n    tool_call: Optional[ToolCall] = Field(\n        None, description=\"Tool call made by the assistant\"\n    )\n\n    @property\n    def tool_call_id(self) -> Optional[str]:\n        \"\"\"Generate a deterministic tool call ID based on the tool call content\"\"\"\n        if not self.tool_call:\n            return N..."
  },
  {
    "name": "UserMessage",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 50,
      "end_line": 52
    },
    "code_snippet": "class UserMessage(Message):\n    role: str = Field(\"user\", description=\"The role of the user\")\n    content: str = Field(..., description=\"The user's message content\")"
  },
  {
    "name": "Usage",
    "docstring": "",
    "methods": [
      "from_completion_response",
      "__add__",
      "__str__",
      "fix_null_tokens"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 55,
      "end_line": 160
    },
    "code_snippet": "class Usage(BaseModel):\n    completion_cost: float = 0\n    completion_tokens: int = 0\n    prompt_tokens: int = 0\n    cached_tokens: int = 0\n\n    @classmethod\n    def from_completion_response(\n        cls, completion_response: dict | BaseModel, model: str\n    ) -> Union[\"Usage\", None]:\n        if isinstance(completion_response, BaseModel) and hasattr(\n            completion_response, \"usage\"\n        ):\n            usage = completion_response.usage.model_dump()\n        elif isinstance(completion_r..."
  },
  {
    "name": "Completion",
    "docstring": "",
    "methods": [
      "from_llm_completion"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 163,
      "end_line": 204
    },
    "code_snippet": "class Completion(BaseModel):\n    model: str\n    input: list[dict] | None = None\n    response: dict[str, Any] | None = None\n    retries: int | None = None\n    usage: Usage | None = None\n    flags: list[str] = Field(\n        default_factory=list,\n        description=\"List of flags indicating special conditions or states during completion\",\n    )\n\n    @classmethod\n    def from_llm_completion(\n        cls,\n        input_messages: list[dict],\n        completion_response: Any,\n        model: str,\n    ..."
  },
  {
    "name": "NameDescriptor",
    "docstring": "",
    "methods": [
      "__get__"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 207,
      "end_line": 211
    },
    "code_snippet": "class NameDescriptor:\n    def __get__(self, obj, cls=None) -> str:\n        if hasattr(cls, \"Config\") and hasattr(cls.Config, \"title\") and cls.Config.title:\n            return cls.Config.title\n        return cls.__name__"
  },
  {
    "name": "StructuredOutput",
    "docstring": "",
    "methods": [
      "description",
      "openai_schema",
      "anthropic_schema",
      "model_validate_xml",
      "model_validate_json",
      "format_args_for_llm",
      "format_schema_for_llm",
      "format_xml_schema"
    ],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 214,
      "end_line": 496
    },
    "code_snippet": "class StructuredOutput(BaseModel):\n    name: ClassVar[NameDescriptor] = NameDescriptor()\n\n    class Config:\n        ignored_types = (classproperty,)\n\n    @classproperty\n    def description(cls):\n        return cls.model_json_schema().get(\"description\", \"\")\n\n    @classmethod\n    def openai_schema(cls, thoughts_in_action: bool = False) -> dict[str, Any]:\n        \"\"\"\n        Return the schema in the format of OpenAI's schema as jsonschema\n        \"\"\"\n        schema = cls.model_json_schema()\n       ..."
  },
  {
    "name": "LLMResponseFormat",
    "docstring": "",
    "methods": [],
    "attributes": [
      "TOOLS",
      "JSON",
      "ANTHROPIC_TOOLS",
      "REACT"
    ],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 24,
      "end_line": 28
    },
    "code_snippet": "class LLMResponseFormat(str, Enum):\n    TOOLS = \"tool_call\"\n    JSON = \"json\"\n    ANTHROPIC_TOOLS = \"anthropic_tools\"\n    REACT = \"react\""
  },
  {
    "name": "CompletionResponse",
    "docstring": "Container for completion responses that can include multiple structured outputs and text",
    "methods": [
      "create",
      "structured_output"
    ],
    "attributes": [],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 31,
      "end_line": 66
    },
    "code_snippet": "class CompletionResponse(BaseModel):\n    \"\"\"Container for completion responses that can include multiple structured outputs and text\"\"\"\n\n    structured_outputs: List[StructuredOutput] = Field(default_factory=list)\n    text_response: Optional[str] = Field(default=None)\n    completion: Optional[Completion] = Field(default=None)\n\n    @classmethod\n    def create(\n        cls,\n        text: str | None = None,\n        output: List[StructuredOutput] | StructuredOutput | None = None,\n        completion:..."
  },
  {
    "name": "CompletionModel",
    "docstring": "",
    "methods": [
      "clone",
      "create_completion",
      "_litellm_base_completion",
      "model_dump",
      "model_validate",
      "set_api_key"
    ],
    "attributes": [],
    "code_location": {
      "file": "completion.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 69,
      "end_line": 366
    },
    "code_snippet": "class CompletionModel(BaseModel):\n    model: str = Field(..., description=\"The model to use for completion\")\n    temperature: float = Field(0.0, description=\"The temperature to use for completion\")\n    max_tokens: int = Field(\n        2000, description=\"The maximum number of tokens to generate\"\n    )\n    timeout: float = Field(\n        120.0, description=\"The timeout in seconds for completion requests\"\n    )\n    model_base_url: Optional[str] = Field(\n        default=None, description=\"The base U..."
  },
  {
    "name": "AnthtropicCompletionModel",
    "docstring": "",
    "methods": [
      "supports_anthropic_computer_use",
      "create_completion"
    ],
    "attributes": [],
    "code_location": {
      "file": "anthropic.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 24,
      "end_line": 214
    },
    "code_snippet": "class AnthtropicCompletionModel(CompletionModel):\n    response_format: Optional[LLMResponseFormat] = Field(\n        LLMResponseFormat.TOOLS, description=\"The response format expected from the LLM\"\n    )\n\n    @property\n    def supports_anthropic_computer_use(self):\n        return \"claude-3-5-sonnet-20241022\" in self.model\n\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput]..."
  },
  {
    "name": "ReActCompletionModel",
    "docstring": "",
    "methods": [
      "create_completion",
      "_validate_react_format"
    ],
    "attributes": [],
    "code_location": {
      "file": "react.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 17,
      "end_line": 190
    },
    "code_snippet": "class ReActCompletionModel(CompletionModel):\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]],\n    ) -> CompletionResponse:\n        action_input_schemas = []\n\n        total_usage = Usage()\n        retry_count = 0\n\n        for action in response_model:\n            action_input_schemas.append(\n                f\" * {action.name} {action.format_schema_for_llm()}\"\n            )\n\n        system_promp..."
  },
  {
    "name": "ToolCallCompletionModel",
    "docstring": "",
    "methods": [
      "create_completion"
    ],
    "attributes": [],
    "code_location": {
      "file": "tool_call.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
      "start_line": 20,
      "end_line": 159
    },
    "code_snippet": "class ToolCallCompletionModel(CompletionModel):\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        tools = []\n\n        if isinstance(response_model, list):\n            tools.extend(\n                [\n                    r.openai_schema(thoughts_in_action=self.thoughts_in_action)\n                    for r in response_model\n            ..."
  },
  {
    "name": "ProvideReward",
    "docstring": "Provide a reward value and explanation for a finished solution.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 18,
      "end_line": 31
    },
    "code_snippet": "class ProvideReward(StructuredOutput):\n    \"\"\"Provide a reward value and explanation for a finished solution.\"\"\"\n\n    explanation: str = Field(\n        ...,\n        description=\"Provide a detailed analysis of how well the solution solves the original task. Consider functionality, correctness, and completeness. Focus on evaluating the end result rather than the process.\",\n    )\n\n    value: int = Field(\n        ...,\n        description=\"A single integer value based on how well the solution address..."
  },
  {
    "name": "ProvideRewardWithFeedback",
    "docstring": "Provide a reward value, explanation, and feedback for a finished solution.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 34,
      "end_line": 40
    },
    "code_snippet": "class ProvideRewardWithFeedback(ProvideReward):\n    \"\"\"Provide a reward value, explanation, and feedback for a finished solution.\"\"\"\n\n    feedback: str = Field(\n        ...,\n        description=\"Write a direct message to a new AI agent that will attempt to solve this task from scratch. The agent has no knowledge of the current solution. Suggest high-level approaches and strategies they should consider. Focus on conceptual guidance rather than specific implementation details. This feedback will b..."
  },
  {
    "name": "TerminalValueFunction",
    "docstring": "Value function for evaluating finished solutions.\n\nThis class evaluates complete solutions to determine how well they solve the original task.\nIt provides:\n- A numerical reward value (-100 to 100)\n- An explanation analyzing the solution quality\n- Feedback suggesting alternative approaches for future attempts\n\nThe feedback is designed to guide completely new solution attempts from scratch,\nfocusing on high-level strategies rather than specific implementation details.\nThis helps explore different approaches to solving the same task.\n\nNote: This value function can only evaluate nodes with a \"Finish\" action.\nFor evaluating intermediate steps, use the base ValueFunction instead.",
    "methods": [
      "get_reward",
      "_show_existing_solutions",
      "_create_message",
      "_build_system_prompt",
      "_format_evaluation_criteria",
      "_format_reward_scale",
      "model_dump",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "terminal.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 43,
      "end_line": 373
    },
    "code_snippet": "class TerminalValueFunction(BaseModel):\n    \"\"\"Value function for evaluating finished solutions.\n\n    This class evaluates complete solutions to determine how well they solve the original task.\n    It provides:\n    - A numerical reward value (-100 to 100)\n    - An explanation analyzing the solution quality\n    - Feedback suggesting alternative approaches for future attempts\n\n    The feedback is designed to guide completely new solution attempts from scratch,\n    focusing on high-level strategies..."
  },
  {
    "name": "Reward",
    "docstring": "A structured output for providing reward values and feedback for actions.",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "model.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 8,
      "end_line": 26
    },
    "code_snippet": "class Reward(StructuredOutput):\n    \"\"\"A structured output for providing reward values and feedback for actions.\"\"\"\n\n    class Config:\n        title = \"ProvideReward\"\n\n    explanation: Optional[str] = Field(\n        default=None,\n        description=\"An explanation and the reasoning behind your decision.\",\n    )\n    feedback: Optional[str] = Field(\n        None, description=\"Feedback to the alternative branch.\"\n    )\n    value: int = Field(\n        ...,\n        description=\"A single integer valu..."
  },
  {
    "name": "CodingValueFunction",
    "docstring": "",
    "methods": [
      "__init__",
      "get_reward"
    ],
    "attributes": [],
    "code_location": {
      "file": "coding.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 38,
      "end_line": 131
    },
    "code_snippet": "class CodingValueFunction(ValueFunction):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._terminal_function = TerminalValueFunction(\n            completion_model=self.completion_model\n        )\n\n    def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        if node.observation.expect_correction and self.correction_award is not None:\n            # Start with the base correction award\n            correction_penalty = 0\n            current_no..."
  },
  {
    "name": "ValueFunction",
    "docstring": "",
    "methods": [
      "get_reward",
      "_create_system_prompt",
      "_build_system_prompt",
      "_format_evaluation_criteria",
      "_format_reward_scale",
      "model_dump",
      "model_validate",
      "_combine_rewards"
    ],
    "attributes": [],
    "code_location": {
      "file": "base.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
      "start_line": 17,
      "end_line": 287
    },
    "code_snippet": "class ValueFunction(BaseModel):\n    completion_model: CompletionModel = Field(\n        ..., description=\"Completion model to be used for generating completions\"\n    )\n    correction_award: Optional[int] = Field(\n        0,\n        description=\"The reward value to automatically assign when the agent expects a correction.\",\n    )\n    include_search_tree: bool = Field(\n        default=False,\n        description=\"Whether to include the search tree visualization in the value prompt\",\n    )\n    coding..."
  },
  {
    "name": "GitRepository",
    "docstring": "",
    "methods": [
      "__init__",
      "from_repo",
      "from_dict",
      "restore_from_snapshot",
      "clean_untracked_files",
      "dict",
      "snapshot",
      "create_empty_file",
      "save_file",
      "commit",
      "commit_message",
      "diff",
      "model_dump"
    ],
    "attributes": [],
    "code_location": {
      "file": "git.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 16,
      "end_line": 247
    },
    "code_snippet": "class GitRepository(FileRepository):\n    repo_url: Optional[str] = Field(default=None, alias=\"git_repo_url\")\n    generate_commit_message: bool = Field(default=False)\n    completion: Optional[CompletionModel] = None\n    current_commit: str = Field(default=\"\")\n    current_diff: Optional[str] = None\n    initial_commit: str = Field(default=\"\")\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        from git import Repo\n\n        self._repo = Repo(path=self.repo_path)\n\n        if not..."
  },
  {
    "name": "Repository",
    "docstring": "",
    "methods": [
      "get_file_content",
      "file_exists",
      "save_file",
      "is_directory",
      "model_dump",
      "model_validate",
      "list_directory"
    ],
    "attributes": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 8,
      "end_line": 53
    },
    "code_snippet": "class Repository(BaseModel, ABC):\n    @abstractmethod\n    def get_file_content(self, file_path: str) -> Optional[str]:\n        pass\n\n    def file_exists(self, file_path: str) -> bool:\n        return True\n\n    def save_file(self, file_path: str, updated_content: str):\n        pass\n\n    def is_directory(self, file_path: str) -> bool:\n        return False\n\n    def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"repository_class\"] = (\n         ..."
  },
  {
    "name": "InMemRepository",
    "docstring": "",
    "methods": [
      "__init__",
      "get_file_content",
      "file_exists",
      "save_file",
      "is_directory",
      "list_directory",
      "model_dump",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "repository.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 56,
      "end_line": 83
    },
    "code_snippet": "class InMemRepository(Repository):\n    files: Dict[str, str] = Field(default_factory=dict)\n\n    def __init__(self, files: Dict[str, str] = None, **kwargs):\n        files = files or {}\n        super().__init__(files=files, **kwargs)\n\n    def get_file_content(self, file_path: str) -> Optional[str]:\n        return self.files.get(file_path)\n\n    def file_exists(self, file_path: str) -> bool:\n        return file_path in self.files\n\n    def save_file(self, file_path: str, updated_content: str):\n      ..."
  },
  {
    "name": "CodeFile",
    "docstring": "",
    "methods": [
      "__init__",
      "from_file",
      "from_content",
      "get_file_content",
      "has_been_modified",
      "save",
      "supports_codeblocks",
      "content",
      "module"
    ],
    "attributes": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 20,
      "end_line": 98
    },
    "code_snippet": "class CodeFile(BaseModel):\n    file_path: str = Field(..., description=\"The path to the file\")\n\n    _content: str = PrivateAttr(\"\")\n    _repo_path: Optional[str] = PrivateAttr(None)\n    _module: Module | None = PrivateAttr(None)\n    _dirty: bool = PrivateAttr(False)\n    _last_modified: datetime | None = PrivateAttr(None)\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._content = kwargs.get(\"_content\", \"\")\n        self._repo_path = kwargs.get(\"repo_path\", None)\n..."
  },
  {
    "name": "FileRepository",
    "docstring": "",
    "methods": [
      "repo_dir",
      "model_dump",
      "get_full_path",
      "get_relative_path",
      "get_file_content",
      "snapshot",
      "restore_from_snapshot",
      "path",
      "is_directory",
      "get_file",
      "file_exists",
      "create_empty_file",
      "save_file",
      "matching_files",
      "find_files",
      "has_matching_files",
      "file_match",
      "find_by_pattern",
      "model_dump",
      "model_validate",
      "find_exact_matches",
      "list_directory"
    ],
    "attributes": [],
    "code_location": {
      "file": "file.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
      "start_line": 101,
      "end_line": 441
    },
    "code_snippet": "class FileRepository(Repository):\n    repo_path: str = Field(..., description=\"The path to the repository\")\n\n    @property\n    def repo_dir(self):\n        return self.repo_path\n\n    def model_dump(self) -> Dict:\n        return {\"type\": \"file\", \"repo_path\": self.repo_path}\n\n    def get_full_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the full file path by combining repo_path and file_path.\n        All paths are treated as relative to repo_path, even if they start with '/'.\n\n ..."
  },
  {
    "name": "Module",
    "docstring": "",
    "methods": [
      "__post_init__",
      "__getattr__",
      "module",
      "find_span_by_id",
      "sum_tokens",
      "show_spans",
      "find_related_span_ids"
    ],
    "attributes": [],
    "code_location": {
      "file": "module.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 14,
      "end_line": 149
    },
    "code_snippet": "class Module(CodeBlock):\n    file_path: Optional[str] = None\n    content: str = \"\"\n    spans_by_id: Dict[str, BlockSpan] = field(default_factory=dict)\n    language: Optional[str] = None\n    code_block: CodeBlock = field(\n        default_factory=lambda: CodeBlock(content=\"\", type=CodeBlockType.MODULE)\n    )\n    _graph: DiGraph = field(\n        default_factory=DiGraph, init=False\n    )  # TODO: Move to central CodeGraph\n\n    def __post_init__(self):\n        if not self.code_block.type == CodeBlock..."
  },
  {
    "name": "SpanMarker",
    "docstring": "",
    "methods": [],
    "attributes": [
      "TAG",
      "COMMENT"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 14,
      "end_line": 16
    },
    "code_snippet": "class SpanMarker(Enum):\n    TAG = 1\n    COMMENT = 2"
  },
  {
    "name": "CodeBlockTypeGroup",
    "docstring": "",
    "methods": [
      "__str__"
    ],
    "attributes": [
      "STRUCTURE",
      "IMPLEMENTATION",
      "IMPORT",
      "BLOCK_DELIMITER",
      "SPACE",
      "COMMENT",
      "ERROR"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 19,
      "end_line": 32
    },
    "code_snippet": "class CodeBlockTypeGroup(str, Enum):\n    STRUCTURE = \"Structures\"\n    IMPLEMENTATION = \"Implementation\"\n    IMPORT = \"Imports\"\n\n    BLOCK_DELIMITER = \"BlockDelimiter\"\n    SPACE = \"Space\"\n\n    COMMENT = \"Comment\"\n\n    ERROR = \"Error\"\n\n    def __str__(self):\n        return self.value"
  },
  {
    "name": "CodeBlockType",
    "docstring": "",
    "methods": [
      "__init__",
      "display_name",
      "__str__",
      "from_string"
    ],
    "attributes": [
      "MODULE",
      "CLASS",
      "FUNCTION",
      "CONSTRUCTOR",
      "TEST_SUITE",
      "TEST_CASE",
      "IMPORT",
      "EXPORT",
      "COMPOUND",
      "DEPENDENT_CLAUSE",
      "ASSIGNMENT",
      "CALL",
      "STATEMENT",
      "CODE",
      "BLOCK_DELIMITER",
      "SPACE",
      "COMMENT",
      "COMMENTED_OUT_CODE",
      "ERROR"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 35,
      "end_line": 109
    },
    "code_snippet": "class CodeBlockType(Enum):\n    MODULE = (\n        \"Module\",\n        CodeBlockTypeGroup.STRUCTURE,\n    )  # TODO: Module shouldn't be a STRUCTURE\n    CLASS = (\"Class\", CodeBlockTypeGroup.STRUCTURE)\n    FUNCTION = (\"Function\", CodeBlockTypeGroup.STRUCTURE)\n\n    # TODO: Remove and add sub types to functions and classes\n    CONSTRUCTOR = (\"Constructor\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_SUITE = (\"TestSuite\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_CASE = (\"TestCase\", CodeBlockTypeGroup.STRUCTURE..."
  },
  {
    "name": "PathTree",
    "docstring": "",
    "methods": [
      "from_block_paths",
      "child_tree",
      "merge",
      "extend_tree",
      "add_to_tree"
    ],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 132,
      "end_line": 179
    },
    "code_snippet": "class PathTree:\n    show: bool = False\n    tree: dict[str, \"PathTree\"] = field(default_factory=dict)\n\n    @staticmethod\n    def from_block_paths(block_paths: list[BlockPath]) -> \"PathTree\":\n        tree = PathTree()\n        for block_path in block_paths:\n            tree.add_to_tree(block_path)\n\n        return tree\n\n    def child_tree(self, key: str) -> Optional[\"PathTree\"]:\n        return self.tree.get(key, None)\n\n    def merge(self, other: \"PathTree\"):\n        if other.show:\n            self.s..."
  },
  {
    "name": "ReferenceScope",
    "docstring": "",
    "methods": [],
    "attributes": [
      "EXTERNAL",
      "DEPENDENCY",
      "FILE",
      "PROJECT",
      "CLASS",
      "LOCAL",
      "GLOBAL"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 182,
      "end_line": 189
    },
    "code_snippet": "class ReferenceScope(str, Enum):\n    EXTERNAL = \"external\"\n    DEPENDENCY = \"dependency\"  # External dependency\n    FILE = \"file\"  # File in repository\n    PROJECT = \"project\"\n    CLASS = \"class\"\n    LOCAL = \"local\"\n    GLOBAL = \"global\""
  },
  {
    "name": "RelationshipType",
    "docstring": "",
    "methods": [],
    "attributes": [
      "UTILIZES",
      "USES",
      "DEFINED_BY",
      "IS_A",
      "PROVIDES",
      "IMPORTS",
      "CALLS",
      "DEPENDENCY",
      "TYPE"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 192,
      "end_line": 201
    },
    "code_snippet": "class RelationshipType(str, Enum):\n    UTILIZES = \"utilizes\"\n    USES = \"uses\"\n    DEFINED_BY = \"defined_by\"\n    IS_A = \"is_a\"\n    PROVIDES = \"provides\"\n    IMPORTS = \"imports\"\n    CALLS = \"calls\"\n    DEPENDENCY = \"dependency\"\n    TYPE = \"type\""
  },
  {
    "name": "Relationship",
    "docstring": "",
    "methods": [
      "__post_init__",
      "__hash__",
      "__eq__",
      "full_path",
      "__str__"
    ],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 205,
      "end_line": 237
    },
    "code_snippet": "class Relationship:\n    scope: ReferenceScope\n    external_path: list[str] = field(default_factory=list)\n    resolved_path: list[str] = field(default_factory=list)\n    path: list[str] = field(default_factory=list)\n    type: RelationshipType = RelationshipType.USES\n    identifier: Optional[str] = None\n\n    def __post_init__(self):\n        if not self.external_path and not self.path:\n            raise ValueError(\"Cannot create Reference without external_path or path.\")\n\n    def __hash__(self):\n   ..."
  },
  {
    "name": "Parameter",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 241,
      "end_line": 243
    },
    "code_snippet": "class Parameter:\n    identifier: str\n    type: Optional[str] = None"
  },
  {
    "name": "SpanType",
    "docstring": "",
    "methods": [],
    "attributes": [
      "INITATION",
      "DOCUMENTATION",
      "IMPLEMENTATION"
    ],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 246,
      "end_line": 249
    },
    "code_snippet": "class SpanType(str, Enum):\n    INITATION = \"init\"\n    DOCUMENTATION = \"docs\"\n    IMPLEMENTATION = \"impl\""
  },
  {
    "name": "BlockSpan",
    "docstring": "",
    "methods": [
      "block_type",
      "__str__",
      "get_first_child_block_path"
    ],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 253,
      "end_line": 277
    },
    "code_snippet": "class BlockSpan:\n    span_id: str\n    span_type: SpanType\n    start_line: int\n    end_line: int\n    block_paths: list[BlockPath] = field(default_factory=list)\n    initiating_block: Optional[\"CodeBlock\"] = None\n    visible: bool = True\n    index: int = 0\n    parent_block_path: Optional[BlockPath] = None\n    is_partial: bool = False\n    tokens: int = 0\n\n    @property\n    def block_type(self):\n        return self.initiating_block.type if self.initiating_block else None\n\n    def __str__(self):\n     ..."
  },
  {
    "name": "ValidationError",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 281,
      "end_line": 282
    },
    "code_snippet": "class ValidationError:\n    error: str"
  },
  {
    "name": "CodeBlock",
    "docstring": "",
    "methods": [
      "__post_init__",
      "content_lines",
      "validate_pre_code",
      "last",
      "insert_child",
      "insert_children",
      "append_child",
      "append_children",
      "replace_children",
      "replace_child",
      "remove_child",
      "sync_indentation",
      "replace_by_path",
      "__str__",
      "to_string",
      "sum_tokens",
      "get_all_child_blocks",
      "get_children",
      "show_related_spans",
      "has_visible_children",
      "is_visible",
      "_to_string",
      "_build_path_tree",
      "to_tree",
      "_to_prompt_string",
      "to_prompt",
      "__eq__",
      "compare_indentation",
      "find_block_by_type",
      "find_type_in_parents",
      "structure_block",
      "find_type_group_in_parents",
      "find_spans_by_line_numbers",
      "dict",
      "display_name",
      "path_string",
      "full_path",
      "module",
      "root",
      "get_blocks",
      "find_reference",
      "get_all_relationships",
      "is_complete",
      "find_errors",
      "create_commented_out_block",
      "create_comment_block",
      "create_comment",
      "add_indentation",
      "find_by_path",
      "find_blocks_by_span_id",
      "find_last_before_span",
      "find_first_by_span_id",
      "find_last_by_span_id",
      "has_any_block",
      "find_by_identifier",
      "find_blocks_with_identifier",
      "find_incomplete_blocks_with_type",
      "find_incomplete_blocks_with_types",
      "find_blocks_with_types",
      "has_blocks_with_types",
      "has_placeholders",
      "find_blocks_with_type",
      "find_first_by_start_line",
      "find_blocks_by_line_numbers",
      "find_last_by_end_line",
      "line_within_token_context",
      "find_last_previous_block_with_block_group",
      "find_next_block_with_block_group",
      "tokens_from_line",
      "last_block_until_line",
      "get_all_span_ids",
      "get_all_spans",
      "has_span",
      "has_any_span",
      "belongs_to_any_span",
      "has_lines",
      "is_within_lines",
      "has_content"
    ],
    "attributes": [],
    "code_location": {
      "file": "codeblocks.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
      "start_line": 286,
      "end_line": 1335
    },
    "code_snippet": "class CodeBlock:\n    type: CodeBlockType\n    content: str\n    identifier: Optional[str] = None\n    parameters: List[\"Parameter\"] = field(default_factory=list)\n    relationships: List[\"Relationship\"] = field(default_factory=list)\n    span_ids: Set[str] = field(default_factory=set)\n    belongs_to_span: Optional[\"BlockSpan\"] = None\n    has_error: bool = False\n    start_line: int = 0\n    end_line: int = 0\n    properties: Dict = field(default_factory=dict)\n    pre_code: str = \"\"\n    pre_lines: int = ..."
  },
  {
    "name": "JavaParser",
    "docstring": "",
    "methods": [
      "__init__"
    ],
    "attributes": [],
    "code_location": {
      "file": "java.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 7,
      "end_line": 12
    },
    "code_snippet": "class JavaParser(CodeParser):\n    def __init__(self, **kwargs):\n        super().__init__(Language(java.language()), **kwargs)\n        self.queries = []\n        self.queries.extend(self._build_queries(\"java.scm\"))\n        self.gpt_queries = []"
  },
  {
    "name": "PythonParser",
    "docstring": "",
    "methods": [
      "__init__",
      "language",
      "pre_process",
      "post_process",
      "is_outcommented_code"
    ],
    "attributes": [],
    "code_location": {
      "file": "python.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 26,
      "end_line": 135
    },
    "code_snippet": "class PythonParser(CodeParser):\n    def __init__(self, **kwargs):\n        language = Language(tspython.language())\n\n        super().__init__(language, **kwargs)\n\n        self.queries = []\n        self.queries.extend(self._build_queries(\"python.scm\"))\n\n        if self.apply_gpt_tweaks:\n            self.gpt_queries.extend(self._build_queries(\"python_gpt.scm\"))\n\n    @property\n    def language(self):\n        return \"python\"\n\n    def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n   ..."
  },
  {
    "name": "NodeMatch",
    "docstring": "",
    "methods": [],
    "attributes": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 33,
      "end_line": 41
    },
    "code_snippet": "class NodeMatch:\n    block_type: CodeBlockType = None\n    identifier_node: Node = None\n    first_child: Node = None\n    last_child: Node = None\n    check_child: Node = None\n    parameters: list[tuple[Node, Node | None]] = field(default_factory=list)\n    relationships: list[tuple[Node, str]] = field(default_factory=list)\n    query: str = None"
  },
  {
    "name": "CodeParser",
    "docstring": "",
    "methods": [
      "__init__",
      "language",
      "_extract_node_type",
      "_build_queries",
      "parse_code",
      "is_commented_out_code",
      "find_in_tree",
      "find_match_with_gpt_tweaks",
      "find_match",
      "_find_match",
      "create_references",
      "create_parameters",
      "add_to_index",
      "pre_process",
      "post_process",
      "get_previous",
      "get_parent_next",
      "has_error",
      "parse",
      "get_content",
      "_create_new_span",
      "_create_span_id",
      "_count_tokens",
      "debug_log"
    ],
    "attributes": [],
    "code_location": {
      "file": "parser.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
      "start_line": 70,
      "end_line": 925
    },
    "code_snippet": "class CodeParser:\n    def __init__(\n        self,\n        language: Language,\n        encoding: str = \"utf8\",\n        max_tokens_in_span: int = 500,\n        min_tokens_for_docs_span: int = 100,\n        min_lines_to_parse_block: Optional[\n            int\n        ] = None,  # If this is set code will just be parsed if they have more line than this\n        enable_code_graph: bool = True,\n        index_callback: Callable[[CodeBlock], None] | None = None,\n        tokenizer: Callable[[str], list] | No..."
  },
  {
    "name": "FeedbackResponse",
    "docstring": "Schema for feedback response",
    "methods": [
      "anthropic_schema",
      "to_dict"
    ],
    "attributes": [],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 19,
      "end_line": 67
    },
    "code_snippet": "class FeedbackResponse(StructuredOutput):\n    \"\"\"Schema for feedback response\"\"\"\n\n    action_name: str = \"provide_feedback\"\n\n    analysis: str = Field(\n        ...,\n        description=\"Brief analysis of parent state and lessons from alternative attempts\",\n    )\n    feedback: str = Field(\n        ..., description=\"Clear, actionable guidance for your next action\"\n    )\n    suggested_node_id: Optional[int] = Field(\n        None, description=\"ID of the node that should be expanded next (optional)\"\n..."
  },
  {
    "name": "FeedbackAgent",
    "docstring": "",
    "methods": [
      "model_post_init",
      "generate_feedback",
      "_create_analysis_messages",
      "_create_system_prompt",
      "save_feedback"
    ],
    "attributes": [],
    "code_location": {
      "file": "feedback_agent.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 70,
      "end_line": 427
    },
    "code_snippet": "class FeedbackAgent(FeedbackGenerator):\n    completion_model: CompletionModel = Field(\n        ..., description=\"The completion model to use\"\n    )\n    instance_dir: str | None = Field(\n        None, description=\"Base directory for the instance\"\n    )\n    feedback_file: str | None = Field(None, description=\"Path to the feedback file\")\n\n    include_parent_info: bool = Field(True)\n    persist_path: str | None = Field(None)\n    include_tree: bool = Field(True)\n    include_node_suggestion: bool = Fi..."
  },
  {
    "name": "FeedbackGenerator",
    "docstring": "",
    "methods": [
      "generate_feedback",
      "model_dump",
      "model_validate"
    ],
    "attributes": [],
    "code_location": {
      "file": "feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 14,
      "end_line": 49
    },
    "code_snippet": "class FeedbackGenerator(BaseModel, ABC):\n    @abstractmethod\n    def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node.\"\"\"\n        pass\n\n    def model_dump(self, **kwargs) -> dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"feedback_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump\n\n    @classmet..."
  },
  {
    "name": "GroundTruthResponse",
    "docstring": "Schema for ground truth feedback response",
    "methods": [
      "anthropic_schema",
      "to_dict"
    ],
    "attributes": [],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 16,
      "end_line": 71
    },
    "code_snippet": "class GroundTruthResponse(StructuredOutput):\n    \"\"\"Schema for ground truth feedback response\"\"\"\n\n    action_name: str = \"provide_ground_truth_feedback\"\n\n    analysis: str = Field(\n        ...,\n        description=\"Detailed analysis of whether node response is supported by ground truth\",\n    )\n    has_ground_truth: bool = Field(\n        ..., description=\"Whether the response has ground truth support\"\n    )\n    feedback: str = Field(\n        ..., description=\"Detailed feedback on response quality..."
  },
  {
    "name": "GroundTruthFeedbackGenerator",
    "docstring": "Feedback generator that uses LLM to evaluate if responses have ground truth support",
    "methods": [
      "generate_feedback",
      "_create_analysis_messages",
      "_create_system_prompt"
    ],
    "attributes": [],
    "code_location": {
      "file": "ground_truth_feedback.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
      "start_line": 74,
      "end_line": 272
    },
    "code_snippet": "class GroundTruthFeedbackGenerator(FeedbackGenerator):\n    \"\"\"Feedback generator that uses LLM to evaluate if responses have ground truth support\"\"\"\n    \n    completion_model: CompletionModel = Field(\n        ..., description=\"The completion model to use\"\n    )\n    include_tree: bool = Field(True, description=\"Whether to include tree visualization\")\n    include_node_suggestion: bool = Field(True, description=\"Whether to include node suggestions\")\n    \n    class Config:\n        arbitrary_types_al..."
  },
  {
    "name": "Colors",
    "docstring": "",
    "methods": [],
    "attributes": [
      "RED",
      "GREEN",
      "YELLOW",
      "BLUE",
      "MAGENTA",
      "CYAN",
      "WHITE",
      "GRAY",
      "RESET"
    ],
    "code_location": {
      "file": "colors.py",
      "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
      "start_line": 1,
      "end_line": 10
    },
    "code_snippet": "class Colors:\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    GRAY = \"\\033[90m\"\n    RESET = \"\\033[0m\""
  }
]