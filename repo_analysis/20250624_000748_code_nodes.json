[
  {
    "type": "class",
    "name": "MoatlessError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 4,
    "end_line": 9,
    "code": "class MoatlessError(Exception):\n    \"\"\"Base exception class for all Moatless exceptions.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(message)"
  },
  {
    "type": "class",
    "name": "RuntimeError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 12,
    "end_line": 15,
    "code": "class RuntimeError(MoatlessError):\n    \"\"\"Exception raised when an operation encounters a fundamental error that prevents further execution.\"\"\"\n\n    pass"
  },
  {
    "type": "class",
    "name": "RejectError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 18,
    "end_line": 21,
    "code": "class RejectError(MoatlessError):\n    \"\"\"Exception raised when an operation should be rejected but the flow can continue.\"\"\"\n\n    pass"
  },
  {
    "type": "class",
    "name": "CompletionError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 24,
    "end_line": 32,
    "code": "class CompletionError(MoatlessError):\n    \"\"\"Base exception for completion-related errors.\"\"\"\n\n    def __init__(\n        self, message: str, last_completion: Any = None, messages: List[dict] = None\n    ):\n        super().__init__(message)\n        self.last_completion = last_completion\n        self.messages = messages or []"
  },
  {
    "type": "class",
    "name": "CompletionRuntimeError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 35,
    "end_line": 38,
    "code": "class CompletionRuntimeError(RuntimeError, CompletionError):\n    \"\"\"Exception raised when completion encounters an unrecoverable error.\"\"\"\n\n    pass"
  },
  {
    "type": "class",
    "name": "CompletionRejectError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 41,
    "end_line": 44,
    "code": "class CompletionRejectError(RejectError, CompletionError):\n    \"\"\"Exception raised when completion should reject the current node but continue search.\"\"\"\n\n    pass"
  },
  {
    "type": "class",
    "name": "CompletionValidationError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 47,
    "end_line": 50,
    "code": "class CompletionValidationError(MoatlessError):\n    \"\"\"Exception raised when completion encounters a validation error.\"\"\"\n\n    pass"
  },
  {
    "type": "class",
    "name": "Expander",
    "file": "expander.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 13,
    "end_line": 86,
    "code": "class Expander(BaseModel):\n    random_settings: bool = Field(\n        False, description=\"Whether to select agent settings randomly\"\n    )\n    max_expansions: int = Field(\n        1, description=\"The maximum number of children to create for each node\"\n    )\n\n    agent_settings: List[AgentSettings] = Field(\n        [],\n        description=\"The settings for the agent model\",\n    )\n\n    def expand(\n        self, node: Node, search_tree, force_expansion: bool = False\n    ) -> None | Node:\n        \"\"\"Handle all node expansion logic in one place\"\"\"\n        if not force_expansion and node.is_fully_expanded():\n            return None\n\n        # Return the first unexecuted child if one exists\n        for child in node.children:\n            if not child.observation:\n                logger.info(\n                    f\"Found unexecuted child {child.node_id} for node {node.node_id}\"\n                )\n                return child\n\n        num_expansions = node.max_expansions or self.max_expansions\n  ..."
  },
  {
    "type": "class",
    "name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 21,
    "end_line": 463,
    "code": "class MessageHistoryGenerator(BaseModel):\n    message_history_type: MessageHistoryType = Field(\n        default=MessageHistoryType.MESSAGES,\n        description=\"Type of message history to generate\",\n    )\n    include_file_context: bool = Field(\n        default=True, description=\"Whether to include file context in messages\"\n    )\n    include_root_node: bool = Field(default=True)\n    max_tokens: int = Field(\n        default=20000, description=\"Maximum number of tokens allowed in message history\"\n    )\n    thoughts_in_action: bool = Field(\n        default=False,\n        description=\"Whether to include thoughts in the action or in the message\",\n    )\n    enable_index_in_tool_call: bool = Field(\n        default=True, description=\"Whether to include index in the tool call\"\n    )\n\n    model_config = {\n        \"ser_json_timedelta\": \"iso8601\",\n        \"ser_json_bytes\": \"base64\",\n        \"ser_json_inf_nan\": \"null\",\n        \"json_schema_serialization_defaults\": True,\n        \"json_encoders\": Non..."
  },
  {
    "type": "class",
    "name": "ActionStep",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 21,
    "end_line": 45,
    "code": "class ActionStep(BaseModel):\n    action: ActionArguments\n    observation: Optional[Observation] = None\n    completion: Optional[Completion] = None\n\n    def is_executed(self) -> bool:\n        \"\"\"Check if this action step has been executed by verifying if it has observations.\"\"\"\n        return self.observation is not None\n\n    def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n\n        data[\"action\"] = self.action.model_dump(**kwargs)\n        data[\"action\"][\"action_args_class\"] = (\n            f\"{self.action.__class__.__module__}.{self.action.__class__.__name__}\"\n        )\n\n        return data\n\n    @classmethod\n    def model_validate(cls, obj: Any, **kwargs) -> \"ActionArguments\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            obj[\"action\"] = ActionArguments.model_validate(obj[\"action\"])\n        return super().model_validate(obj, **kwargs)"
  },
  {
    "type": "class",
    "name": "FeedbackData",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 48,
    "end_line": 57,
    "code": "class FeedbackData(BaseModel):\n    \"\"\"Structured feedback data model\"\"\"\n\n    feedback: str = Field(..., description=\"Direct feedback to the AI assistant\")\n    analysis: Optional[str] = Field(\n        None, description=\"Analysis of the task and alternative branch attempts\"\n    )\n    suggested_node_id: Optional[int] = Field(\n        None, description=\"ID of the node that should be expanded next (optional)\"\n    )"
  },
  {
    "type": "class",
    "name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 60,
    "end_line": 617,
    "code": "class Node(BaseModel):\n    node_id: int = Field(..., description=\"The unique identifier of the node\")\n\n    parent: Optional[\"Node\"] = Field(None, description=\"The parent node\")\n    children: List[\"Node\"] = Field(default_factory=list, description=\"The child nodes\")\n\n    artifact_changes: List[ArtifactChange] = Field(\n        default_factory=list,\n        description=\"The artifact changes associated with the node\",\n    )\n\n    user_message: Optional[str] = Field(\n        None, description=\"The user message for this node\"\n    )\n    assistant_message: Optional[str] = Field(\n        None, description=\"The assistant response for this node\"\n    )\n\n    action_steps: List[ActionStep] = Field(\n        default_factory=list,\n        description=\"The sequence of actions and observations for this node\",\n    )\n\n    file_context: Optional[FileContext] = Field(\n        None, description=\"The file context state associated with the node\"\n    )\n    # feedback: Optional[str] = Field(None, description=\"Feedb..."
  },
  {
    "type": "class",
    "name": "ContextSpan",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 27,
    "end_line": 35,
    "code": "class ContextSpan(BaseModel):\n    span_id: str\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    tokens: Optional[int] = None\n    pinned: bool = Field(\n        default=False,\n        description=\"Whether the span is pinned and cannot be removed from context\",\n    )"
  },
  {
    "type": "class",
    "name": "CurrentPromptSpan",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 39,
    "end_line": 41,
    "code": "class CurrentPromptSpan:\n    span_id: Optional[str] = None\n    tokens: int = 0"
  },
  {
    "type": "class",
    "name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 44,
    "end_line": 644,
    "code": "class ContextFile(BaseModel):\n    \"\"\"\n    Represents the context of a file, managing patches that reflect changes over time.\n\n    Attributes:\n        file_path (str): The path to the file within the repository.\n        accumulated_patch (Optional[str]): A Git-formatted patch representing all changes from the original content.\n        patch (Optional[str]): A Git-formatted patch representing the latest changes applied in this ContextFile.\n        spans (List[ContextSpan]): A list of spans associated with this file.\n        show_all_spans (bool): A flag to indicate whether to display all spans.\n    \"\"\"\n\n    file_path: str = Field(\n        ..., description=\"The relative path to the file within the repository.\"\n    )\n    patch: Optional[str] = Field(\n        None,\n        description=\"Git-formatted patch representing the latest changes applied in this ContextFile.\",\n    )\n    spans: List[ContextSpan] = Field(\n        default_factory=list,\n        description=\"List of context spans associat..."
  },
  {
    "type": "class",
    "name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 647,
    "end_line": 1141,
    "code": "class FileContext(BaseModel):\n    _repo: Repository | None = PrivateAttr(None)\n    # _runtime: RuntimeEnvironment = PrivateAttr(None)\n\n    _files: Dict[str, ContextFile] = PrivateAttr(default_factory=dict)\n    # _test_files: Dict[str, TestFile] = PrivateAttr(\n    #     default_factory=dict\n    # )  # Changed to Dict\n    _max_tokens: int = PrivateAttr(default=8000)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(\n        self,\n        repo: Repository | None,\n        # runtime: RuntimeEnvironment | None = None,\n        **data,\n    ):\n        super().__init__(**data)\n\n        self._repo = repo\n        # self._runtime = runtime\n\n        if \"_files\" not in self.__dict__:\n            self.__dict__[\"_files\"] = {}\n\n        if \"_test_files\" not in self.__dict__:\n            self.__dict__[\"_test_files\"] = {}\n\n        if \"_max_tokens\" not in self.__dict__:\n            self.__dict__[\"_max_tokens\"] = data.get(\"max_tokens\", 8000)\n\n    @classmethod\n    def from_dir(cls..."
  },
  {
    "type": "class",
    "name": "MoatlessSolve",
    "file": "moatless_solve.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 22,
    "end_line": 69,
    "code": "class MoatlessSolve:\n    def __init__(self, repo_name:str, repo_path: str):\n        # Global variables are used here as defined above the class:\n        # instance, repo_base_dir, index_store_dir, instance_path, persist_path\n    \n        completion_model = CompletionModel(model=\"deepseek/deepseek-chat\", temperature=0.7)\n        completion_model.response_format = LLMResponseFormat.TOOLS\n        repository = create_repository(instance, repo_base_dir=repo_base_dir)\n\n        code_index = CodeIndex.from_index_name(\n            instance[\"instance_id\"], index_store_dir=index_store_dir, file_repo=repository\n        )\n        file_context = FileContext(repo=repository)\n        selector = BestFirstSelector()\n        value_function = ValueFunction(completion_model=completion_model)\n        actions = [\n            FindClass(completion_model=completion_model, code_index=code_index, repository=repository),\n            FindFunction(completion_model=completion_model, code_index=code_index, repository=..."
  },
  {
    "type": "class",
    "name": "MessageHistoryType",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 10,
    "end_line": 29,
    "code": "class MessageHistoryType(Enum):\n    MESSAGES = \"messages\"  # Provides all messages in sequence\n    SUMMARY = \"summary\"  # Generates one message with summarized history\n    REACT = \"react\"\n    MESSAGES_COMPACT = \"messages_compact\"\n\n    @classmethod\n    def _missing_(cls, value: str):\n        \"\"\"Handle case-insensitive enum lookup\"\"\"\n        for member in cls:\n            if member.value.lower() == value.lower():\n                return member\n        return None\n\n    def __str__(self):\n        return self.value\n\n    def json(self):\n        \"\"\"Custom JSON serialization\"\"\"\n        return self.value"
  },
  {
    "type": "class",
    "name": "FileWithSpans",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 32,
    "end_line": 50,
    "code": "class FileWithSpans(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span id is a unique identifier for a code sippet. It can be a class name or function name. For functions in classes separete with a dot like 'class.function'.\",\n    )\n\n    def add_span_id(self, span_id):\n        if span_id not in self.span_ids:\n            self.span_ids.append(span_id)\n\n    def add_span_ids(self, span_ids: list[str]):\n        for span_id in span_ids:\n            self.add_span_id(span_id)\n\n    def __eq__(self, other: \"FileWithSpans\"):\n        return self.file_path == other.file_path and self.span_ids == other.span_ids"
  },
  {
    "type": "class",
    "name": "RankedFileSpan",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 53,
    "end_line": 57,
    "code": "class RankedFileSpan(BaseModel):\n    file_path: str\n    span_id: str\n    rank: int = 0\n    tokens: int = 0"
  },
  {
    "type": "class",
    "name": "ActionView",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 60,
    "end_line": 61,
    "code": "class ActionView(BaseModel):\n    name: str"
  },
  {
    "type": "class",
    "name": "Attachment",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 64,
    "end_line": 71,
    "code": "class Attachment(BaseModel):\n    \"\"\"Represents a file attachment in a chat message\"\"\"\n\n    file_name: str = Field(description=\"Original name of the uploaded file\")\n    content: bytes = Field(description=\"Raw binary content of the file\")\n    mime_type: Optional[str] = Field(\n        default=None, description=\"MIME type of the file content\"\n    )"
  },
  {
    "type": "class",
    "name": "Message",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 74,
    "end_line": 76,
    "code": "class Message(BaseModel):\n    role: str = Field(description=\"Role of the message sender ('user' or 'assistant')\")\n    content: Optional[str] = Field(default=None, description=\"Content of the message\")"
  },
  {
    "type": "class",
    "name": "UserMessage",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 79,
    "end_line": 85,
    "code": "class UserMessage(Message):\n    role: Literal[\"user\"] = Field(\n        default=\"user\", description=\"Role is always 'user' for user messages\"\n    )\n    artifact_ids: Optional[List[str]] = Field(\n        default=None, description=\"List of artifact ids associated with the message\"\n    )"
  },
  {
    "type": "class",
    "name": "AssistantMessage",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 88,
    "end_line": 95,
    "code": "class AssistantMessage(Message):\n    role: Literal[\"assistant\"] = Field(\n        default=\"assistant\",\n        description=\"Role is always 'assistant' for assistant messages\",\n    )\n    actions: Optional[List[ActionView]] = Field(\n        default=None, description=\"List of actions performed by the assistant\"\n    )"
  },
  {
    "type": "class",
    "name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 20,
    "end_line": 428,
    "code": "class CodeQASearchTree(BaseModel):\n    root: Node = Field(..., description=\"The root node of the search tree.\")\n    selector: Union[\n        BestFirstSelector, SoftmaxSelector, LLMSelector, FeedbackSelector\n    ] = Field(..., description=\"Selector for node selection.\")\n    agent: ActionAgent = Field(..., description=\"Agent for generating actions.\")\n    actions: List[Action] = Field(\n        default_factory=list,\n        description=\"Actions that can be used by the agent in the search tree.\",\n    )\n    repository: Optional[Repository] = Field(\n        None, description=\"Repository for the search tree.\"\n    )\n    expander: Optional[Expander] = Field(\n        None, description=\"Expander for expanding nodes.\"\n    )\n    value_function: Optional[ValueFunction] = Field(\n        None, description=\"Value function for reward calculation.\"\n    )\n    feedback_generator: Optional[FeedbackGenerator] = Field(\n        None, description=\"Feedback generator.\"\n    )\n    persist_path: Optional[str] = Fiel..."
  },
  {
    "type": "class",
    "name": "TextPromptModel",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 7,
    "end_line": 9,
    "code": "class TextPromptModel(BaseModel):\n    type: Literal[\"text\"]\n    text: str"
  },
  {
    "type": "class",
    "name": "ImageURLPromptModel",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 12,
    "end_line": 14,
    "code": "class ImageURLPromptModel(BaseModel):\n    type: Literal[\"image_url\"]\n    image_url: Dict[str, str]"
  },
  {
    "type": "class",
    "name": "Artifact",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 20,
    "end_line": 27,
    "code": "class Artifact(BaseModel):\n    id: str = Field(description=\"Unique identifier for the artifact\")\n    type: str = Field(description=\"Type of artifact (e.g., 'receipt')\")\n    name: str = Field(description=\"Name of the artifact\")\n\n    @abstractmethod\n    def to_prompt_format(self) -> PromptModel:\n        pass"
  },
  {
    "type": "class",
    "name": "ArtifactChange",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 30,
    "end_line": 34,
    "code": "class ArtifactChange(BaseModel):\n    artifact_id: str\n    change_type: Literal[\"added\", \"updated\", \"removed\"]\n    diff_details: Optional[str] = None\n    actor: Literal[\"user\", \"assistant\"]"
  },
  {
    "type": "class",
    "name": "ArtifactHandler",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 41,
    "end_line": 63,
    "code": "class ArtifactHandler(ABC, BaseModel, Generic[T]):\n    \"\"\"\n    Defines how to load, save, update, and delete artifacts of a certain type.\n    The type parameter T specifies which Artifact subclass this handler manages.\n    \"\"\"\n\n    type: str = Field(description=\"Type of artifact this handler manages\")\n\n    @abstractmethod\n    def load(self, artifact_id: str) -> T:\n        pass\n\n    @abstractmethod\n    def save(self, artifact: T) -> None:\n        pass\n\n    @abstractmethod\n    def update(self, artifact: T) -> None:\n        pass\n\n    @abstractmethod\n    def delete(self, artifact_id: str) -> None:\n        pass"
  },
  {
    "type": "class",
    "name": "FileArtifact",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 17,
    "end_line": 39,
    "code": "class FileArtifact(Artifact):\n    type: str = \"file\"\n    file_path: str = Field(description=\"Path on disk where the artifact is stored\")\n    mime_type: Optional[str] = Field(\n        default=None, description=\"MIME type of the file content\"\n    )\n    content: bytes = Field(exclude=True)\n\n    def to_prompt_format(self) -> PromptModel:\n        if self.mime_type is None:\n            self.mime_type = \"text/plain\"\n\n        if self.mime_type.startswith(\"text/\"):\n            # Return TextPromptModel for text content\n            text_str = self.content.decode(\"utf-8\", errors=\"replace\")\n            return TextPromptModel(type=\"text\", text=text_str)\n        else:\n            # Return ImageURLPromptModel for binary content\n            encoded = base64.b64encode(self.content).decode(\"utf-8\")\n            return ImageURLPromptModel(\n                type=\"image_url\",\n                image_url={\"url\": f\"data:{self.mime_type};base64,{encoded}\"},\n            )"
  },
  {
    "type": "class",
    "name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 42,
    "end_line": 75,
    "code": "class FileArtifactHandler(ArtifactHandler[FileArtifact]):\n    type: str = \"file\"\n    directory_path: Path = Field(\n        description=\"Base directory path for storing artifacts\"\n    )\n\n    def _detect_mime_type(self, file_path: str) -> str:\n        mime_type, _ = mimetypes.guess_type(file_path)\n        return mime_type or \"application/octet-stream\"\n\n    def load(self, artifact_id: str) -> FileArtifact:\n        file_path = self.directory_path / artifact_id\n        return FileArtifact(\n            id=artifact_id,\n            type=self.type,\n            name=file_path.name,\n            file_path=str(file_path),\n            mime_type=self._detect_mime_type(str(file_path)),\n            content=file_path.read_bytes() if file_path.exists() else None,\n        )\n\n    def save(self, artifact: FileArtifact) -> None:\n        file_path = self.directory_path / artifact.file_path\n        if artifact.content:\n            file_path.parent.mkdir(parents=True, exist_ok=True)\n            file_path.write_..."
  },
  {
    "type": "class",
    "name": "SimpleVectorStoreData",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 41,
    "end_line": 44,
    "code": "class SimpleVectorStoreData(DataClassJsonMixin):\n    text_id_to_ref_doc_id: dict[str, str] = field(default_factory=dict)\n    vector_id_to_text_id: dict[int, str] = field(default_factory=dict)\n    metadata_dict: dict[str, Any] = field(default_factory=dict)"
  },
  {
    "type": "class",
    "name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 47,
    "end_line": 292,
    "code": "class SimpleFaissVectorStore(BasePydanticVectorStore):\n    \"\"\"Simple Vector Store using Faiss as .\n\n    In this vector store, embeddings are stored within a simple, in-memory dictionary.\n\n    Args:\n        simple_vector_store_data_dict (Optional[dict]): data dict\n            containing the embeddings and doc_ids. See SimpleVectorStoreData\n            for more details.\n    \"\"\"\n\n    _data: SimpleVectorStoreData = PrivateAttr()\n    _fs: fsspec.AbstractFileSystem = PrivateAttr()\n    _faiss_index: Any = PrivateAttr()\n    _d: int = PrivateAttr()\n\n    _vector_ids_to_delete: list[int] = PrivateAttr(default_factory=list)\n    _text_ids_to_delete: set[str] = PrivateAttr(default_factory=set)\n\n    stores_text: bool = False\n\n    def __init__(\n        self,\n        faiss_index: Any,\n        d: int = 1536,\n        data: SimpleVectorStoreData | None = None,\n        fs: fsspec.AbstractFileSystem | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n\n        import_err_msg..."
  },
  {
    "type": "class",
    "name": "CodeSnippet",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 8,
    "end_line": 19,
    "code": "class CodeSnippet:\n    id: str\n    file_path: str\n    content: str = None\n    distance: float = 0.0\n    tokens: int = None\n    language: str = \"python\"\n    span_ids: list[str] = None\n    start_line: Optional[int] = None\n    end_line: Optional[int] = None\n    start_block: Optional[str] = None\n    end_block: Optional[str] = None"
  },
  {
    "type": "class",
    "name": "SpanHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 22,
    "end_line": 28,
    "code": "class SpanHit(BaseModel):\n    span_id: str = Field(description=\"The span id of the relevant code in the file\")\n    rank: int = Field(\n        default=0,\n        description=\"The rank of relevance of the span in the file. 0 is highest.\",\n    )\n    tokens: int = Field(default=0, description=\"The number of tokens in the span.\")"
  },
  {
    "type": "class",
    "name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 31,
    "end_line": 56,
    "code": "class SearchCodeHit(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    spans: list[SpanHit] = Field(\n        default_factory=list,\n        description=\"The spans of the relevant code in the file\",\n    )\n\n    @property\n    def span_ids(self):\n        return [span.span_id for span in self.spans]\n\n    def add_span(self, span_id: str, rank: int = 0, tokens: int = 0):\n        if span_id not in [span.span_id for span in self.spans]:\n            self.spans.append(SpanHit(span_id=span_id, rank=rank, tokens=tokens))\n\n    def contains_span(self, span_id: str) -> bool:\n        return span_id in [span.span_id for span in self.spans]\n\n    def add_spans(self, span_ids: list[str], rank: int = 0):\n        for span_id in span_ids:\n            self.add_span(span_id, rank)\n\n    def __str__(self):\n        return f\"{self.file_path}: {', '.join([span.span_id for span in self.spans])}\""
  },
  {
    "type": "class",
    "name": "SearchCodeResponse",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 59,
    "end_line": 70,
    "code": "class SearchCodeResponse(BaseModel):\n    message: Optional[str] = Field(\n        default=None, description=\"A message to return to the user.\"\n    )\n\n    hits: list[SearchCodeHit] = Field(\n        default_factory=list,\n        description=\"Search results.\",\n    )\n\n    def sum_tokens(self):\n        return sum([sum([span.tokens for span in hit.spans]) for hit in self.hits])"
  },
  {
    "type": "class",
    "name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 47,
    "end_line": 1002,
    "code": "class CodeIndex:\n    def __init__(\n        self,\n        file_repo: Repository,\n        index_name: Optional[str] = None,\n        vector_store: \"BasePydanticVectorStore | None\" = None,\n        docstore: \"DocumentStore | None\" = None,\n        embed_model: \"BaseEmbedding | None\" = None,\n        blocks_by_class_name: Optional[dict] = None,\n        blocks_by_function_name: Optional[dict] = None,\n        settings: IndexSettings | None = None,\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n    ):\n        self._index_name = index_name\n        self._settings = settings or IndexSettings()\n\n        self.max_results = max_results\n        self.max_hits_without_exact_match = max_hits_without_exact_match\n        self.max_exact_results = max_exact_results\n\n        self._file_repo = file_repo\n\n        self._blocks_by_class_name = blocks_by_class_name or {}\n        self._blocks_by_function_name = blocks_by_function_name or {}\n\n       ..."
  },
  {
    "type": "class",
    "name": "CommentStrategy",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 8,
    "end_line": 16,
    "code": "class CommentStrategy(Enum):\n    # Keep comments\n    INCLUDE = \"include\"\n\n    # Always associate comments before a code block with the code block\n    ASSOCIATE = \"associate\"\n\n    # Exclude comments in parsed chunks\n    EXCLUDE = \"exclude\""
  },
  {
    "type": "class",
    "name": "IndexSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 19,
    "end_line": 52,
    "code": "class IndexSettings(BaseModel):\n    embed_model: str = Field(\n        default=\"text-embedding-3-small\", description=\"The embedding model to use.\"\n    )\n    dimensions: int = Field(\n        default=1536, description=\"The number of dimensions of the vectors.\"\n    )\n\n    language: str = Field(default=\"python\", description=\"The language of the code.\")\n    min_chunk_size: int = Field(default=100, description=\"The minimum chunk size.\")\n    chunk_size: int = Field(default=750, description=\"The soft max chunk size.\")\n    hard_token_limit: int = Field(default=2000, description=\"The hard token limit.\")\n    max_chunks: int = Field(\n        default=200, description=\"The maximum number of chunks for one file.\"\n    )\n    comment_strategy: CommentStrategy = Field(\n        default=CommentStrategy.ASSOCIATE,\n        description=\"Strategy on how comments will be indexed.\",\n    )\n\n    def to_serializable_dict(self):\n        data = self.dict()\n        data[\"comment_strategy\"] = data[\"comment_strategy\"].va..."
  },
  {
    "type": "class",
    "name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 41,
    "end_line": 517,
    "code": "class EpicSplitter(NodeParser):\n    language: str = Field(\n        default=\"python\", description=\"Language of the code blocks to parse.\"\n    )\n\n    text_splitter: TextSplitter = Field(\n        description=\"Text splitter to use for splitting non code documents into nodes.\"\n    )\n\n    include_non_code_files: bool = Field(\n        default=True, description=\"Whether or not to include non code files.\"\n    )\n\n    non_code_file_extensions: list[str] = Field(\n        default=[\"md\", \"txt\"],\n        description=\"File extensions to consider as non code files.\",\n    )\n\n    comment_strategy: CommentStrategy = Field(\n        default=CommentStrategy.INCLUDE, description=\"Comment strategy to use.\"\n    )\n\n    chunk_size: int = Field(\n        default=1500, description=\"Chunk size to use for splitting code documents.\"\n    )\n\n    max_chunks: int = Field(\n        default=100, description=\"Max number of chunks to split a document into.\"\n    )\n\n    min_chunk_size: int = Field(default=256, description=\"Min to..."
  },
  {
    "type": "class",
    "name": "CodeNode",
    "file": "code_node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 6,
    "end_line": 22,
    "code": "class CodeNode(TextNode):\n    # Skip start and end line in metadata to try to lower the number of changes and triggers of new embeddings.\n    @property\n    def hash(self):\n        metadata = self.metadata.copy()\n        metadata.pop(\"start_line\", None)\n        metadata.pop(\"end_line\", None)\n        metadata.pop(\"tokens\", None)\n        cleaned_text = self._clean_text(self.text)\n        doc_identity = cleaned_text + str(metadata)\n        return str(sha256(doc_identity.encode(\"utf-8\", \"surrogatepass\")).hexdigest())\n\n    def _clean_text(self, text):\n        \"\"\"\n        Remove all whitespace and convert to lowercase to reduce the number of changes in hashes.\n        \"\"\"\n        return \"\".join(text.split()).lower()"
  },
  {
    "type": "class",
    "name": "VoyageEmbeddingWithRetry",
    "file": "retry_voyage_embedding.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 11,
    "end_line": 40,
    "code": "class VoyageEmbeddingWithRetry(VoyageEmbedding):\n    @retry(\n        wait=wait_random_exponential(multiplier=1, max=60), stop=stop_after_attempt(6)\n    )\n    def _get_embedding(self, texts: List[str], input_type: str) -> List[List[float]]:\n        try:\n            return self._client.embed(\n                texts,\n                model=self.model_name,\n                input_type=input_type,\n                truncation=self.truncation,\n            ).embeddings\n        except InvalidRequestError as e:\n            if \"Please lower the number of tokens in the batch\" in str(e):\n                if len(texts) < 10:\n                    raise  # If batch size is already less than 10 we expect batchs to be abnormaly large and raise the error\n\n                mid = len(texts) // 2\n                first_half = texts[:mid]\n                second_half = texts[mid:]\n\n                logger.info(\n                    f\"Splitting batch of {len(texts)} texts into two halves of {len(first_half)} and {len(se..."
  },
  {
    "type": "class",
    "name": "FindCodeSnippetArgs",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 14,
    "end_line": 53,
    "code": "class FindCodeSnippetArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact code you want to find.\n         It will run the command: grep -n -r \"code_snippet\" \"file_pattern\"\n\n    Perfect for:\n    - Finding specific constant definitions: code_snippet=\"MAX_RETRIES = 3\"\n    - Finding decorator usage: code_snippet=\"@retry(max_attempts=3)\"\n    - Finding specific imports: code_snippet=\"from datetime import datetime\"\n    - Finding configuration patterns: code_snippet=\"DEBUG = os.getenv('DEBUG', False)\"\n\n    Note: You must know the exact code snippet. Use SemanticSearch if you only know\n    what the code does but not its exact implementation.\n    \"\"\"\n\n    code_snippet: str = Field(..., description=\"The exact code snippet to find.\")\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific file types or directories. \",\n    )\n\n    class Config:\n        title = \"FindCodeSnippet\"\n\n    @model_validator(mode=\"after\"..."
  },
  {
    "type": "class",
    "name": "FindCodeSnippet",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 56,
    "end_line": 119,
    "code": "class FindCodeSnippet(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindCodeSnippetArgs\n\n    max_hits: int = Field(\n        10,\n        description=\"The maximum number of search results to return. Default is 10.\",\n    )\n\n    def _search_for_context(\n        self, args: FindCodeSnippetArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.code_snippet} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.code_snippet, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_path, line_num in matches\n                if fnmatch(file_path, args.file_pattern)\n            ]\n\n        search_result_context = FileContext(repo=self._repository)\n        for file_path, start_line in matches[: self.max_hits]:\n            num_lines = len(a..."
  },
  {
    "type": "class",
    "name": "FindClassArgs",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 13,
    "end_line": 48,
    "code": "class FindClassArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact name of a class you want to find.\n\n    Perfect for:\n    - Finding class implementations: class_name=\"UserRepository\"\n    - Locating test classes: class_name=\"TestUserAuthentication\"\n    - Finding base classes: class_name=\"BaseController\"\n    - Finding classes in specific modules: class_name=\"Config\", file_pattern=\"src/config/*.py\"\n    \"\"\"\n\n    class_name: str = Field(\n        ...,\n        description=\"Specific class name to search for (e.g., 'UserRepository', not 'app.models.UserRepository').\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_names(self) -> \"FindClassArgs\":\n        if not self.class_name.strip():\n            raise ValueError(\"class_name cannot be empty\")\n        # Extract just the class name if a fully qualified name is provided\n        if \".\" in self.class_name:\n            original_name = self.class_name\n            self.class_name = self.class_name.split(\".\")[-1]\n            logge..."
  },
  {
    "type": "class",
    "name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 51,
    "end_line": 109,
    "code": "class FindClass(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindClassArgs\n\n    def to_prompt(self):\n        prompt = f\"Searching for class: {self.args.class_name}\"\n        if self.args.file_pattern:\n            prompt += f\" in files matching the pattern: {self.args.file_pattern}\"\n        return prompt\n\n    def _search(self, args: FindClassArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.class_name} (file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_class(\n            args.class_name, file_pattern=args.file_pattern\n        )\n\n    def _select_span_instructions(self, search_result: SearchCodeResponse) -> str:\n        return (\n            f\"Here's the class structure.\"\n            f\"Use the function ViewCode and specify the SpanIDs of the relevant functions to view them.\\n\"\n        )\n\n    def _search_for_alternative_suggestion(\n        self, args: FindClassArgs\n    ) -> SearchCodeResponse:\n        ..."
  },
  {
    "type": "class",
    "name": "SearchBaseArgs",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 47,
    "end_line": 59,
    "code": "class SearchBaseArgs(ActionArguments, ABC):\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific files or directories.\",\n    )\n\n    @field_validator(\"file_pattern\")\n    @classmethod\n    def validate_file_pattern(cls, v):\n        if v:\n            if \",\" in v:\n                raise ValueError(\"File pattern cannot contain commas\")\n        return v"
  },
  {
    "type": "class",
    "name": "IdentifiedSpans",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 62,
    "end_line": 71,
    "code": "class IdentifiedSpans(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: int = Field(\n        description=\"Starting line number of the relevant code section.\"\n    )\n    end_line: int = Field(\n        description=\"Ending line number of the relevant code section.\"\n    )"
  },
  {
    "type": "class",
    "name": "Identify",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 74,
    "end_line": 85,
    "code": "class Identify(StructuredOutput):\n    \"\"\"Identify if the provided search result is relevant to the reported issue.\"\"\"\n\n    thoughts: Optional[str] = Field(\n        None,\n        description=\"Your thoughts and analysis on the search results and how they relate to the reported issue.\",\n    )\n\n    identified_spans: Optional[list[IdentifiedSpans]] = Field(\n        default=None,\n        description=\"Files and code sections in the search results identified as relevant to the reported issue.\",\n    )"
  },
  {
    "type": "class",
    "name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 88,
    "end_line": 438,
    "code": "class SearchBaseAction(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = SearchBaseArgs\n\n    max_search_tokens: int = Field(\n        2000,\n        description=\"The maximum number of tokens allowed in the search results.\",\n    )\n    max_identify_tokens: int = Field(\n        8000,\n        description=\"The maximum number of tokens allowed in the identified code sections.\",\n    )\n    max_identify_prompt_tokens: int = Field(\n        16000,\n        description=\"The maximum number of tokens allowed in the identify prompt.\",\n    )\n    max_hits: int = Field(\n        10,\n        description=\"The maximum number of search hits to display.\",\n    )\n    completion_model: CompletionModel = Field(\n        ...,\n        description=\"The completion model used to identify relevant code sections in search results.\",\n    )\n\n    _repository: Repository = PrivateAttr()\n    _code_index: CodeIndex = PrivateAttr()\n\n    def __init__(\n        self,\n        repository: Repository = None,\n        code_index..."
  },
  {
    "type": "class",
    "name": "FinishArgs",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 15,
    "end_line": 41,
    "code": "class FinishArgs(ActionArguments):\n    \"\"\"Indicate that the generated code answer is accurate and complete for the user's query.\"\"\"\n\n    answer: str = Field(\n        ...,\n        description=\"The generated answer to the user's query.\",\n    )\n\n    thoughts: str = Field(\n        ...,\n        description=\"Your reasoning about why the generated code answer accurately and completely addresses the user's query.\",\n    )\n\n\n    class Config:\n        title = \"Finish\" # Finish providing the answer to the user's query\n    \n    @property\n    def answer(self):\n        return self.answer\n        \n    def to_prompt(self):\n        return f\"Provide Answer: {self.finish_reason}\"\n\n    def equals(self, other: \"ActionArguments\") -> bool:\n        # Keep comparison simple for now, might need adjustment based on usage\n        return isinstance(other, FinishArgs) and self.finish_reason == other.finish_reason"
  },
  {
    "type": "class",
    "name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 44,
    "end_line": 139,
    "code": "class Finish(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = FinishArgs\n\n    def execute(\n        self,\n        args: FinishArgs,\n        file_context: FileContext | None = None, # Keep for potential future context use\n    ):\n        # Return the answer from FinishArgs\n        return Observation(message=args.answer, terminal=True)\n\n    @classmethod\n    def get_evaluation_criteria(cls, trajectory_length: int) -> List[str]:\n        # Adapted criteria for Code QA Answering\n        return [\n            \"**Answer Accuracy:** Evaluate the correctness of the provided code snippet or explanation. Does it accurately answer the user's query?\",\n            \"**Answer Completeness:** Assess if the answer provides all necessary information or code components required by the user's query. Are there missing imports, configurations, or steps?\",\n            \"**Relevance:** Verify that the answer directly addresses the user's specific question or request. Is the provided code/explanation rele..."
  },
  {
    "type": "class",
    "name": "RejectArgs",
    "file": "reject.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 10,
    "end_line": 22,
    "code": "class RejectArgs(ActionArguments):\n    \"\"\"Reject the task and explain why.\"\"\"\n\n    rejection_reason: str = Field(..., description=\"Explanation for rejection.\")\n\n    class Config:\n        title = \"Reject\"\n\n    def to_prompt(self):\n        return f\"Reject with reason: {self.rejection_reason}\"\n\n    def equals(self, other: \"ActionArguments\") -> bool:\n        return isinstance(other, RejectArgs)"
  },
  {
    "type": "class",
    "name": "Reject",
    "file": "reject.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 25,
    "end_line": 33,
    "code": "class Reject(Action):\n    args_schema: ClassVar[Type[ActionArguments]] = RejectArgs\n\n    def execute(\n        self,\n        args: RejectArgs,\n        file_context: FileContext | None = None,\n    ):\n        return Observation(message=args.rejection_reason, terminal=True)"
  },
  {
    "type": "class",
    "name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 17,
    "end_line": 131,
    "code": "class ActionArguments(StructuredOutput, ABC):\n    thoughts: str = Field(..., description=\"Your reasoning for the action.\")\n\n    class Config:\n        title = \"Action\"\n\n    @classmethod\n    def get_name(cls) -> str:\n        \"\"\"Returns the action name for the class based on Config title.\"\"\"\n        return str(getattr(cls.Config, \"title\", cls.__name__))\n\n    def format_for_llm(self) -> str:\n        \"\"\"Format the action name for LLM consumption\"\"\"\n        return str(self.name)\n\n    @classmethod\n    def format_name_for_llm(cls) -> str:\n        \"\"\"Format the class name for LLM consumption\"\"\"\n        return str(cls.get_name())\n\n    def to_tool_call(self) -> ToolCall:\n        tool_input = self.model_dump()\n\n        return ToolCall(name=self.name, input=tool_input)\n\n    @classmethod\n    def from_tool_call(cls, tool_args: dict[str, Any], tool_name: str | None = None):\n        return cls(**tool_args)\n\n    def equals(self, other: \"ActionArguments\") -> bool:\n        return self.model_dump(exclude={..."
  },
  {
    "type": "class",
    "name": "RewardScaleEntry",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 134,
    "end_line": 137,
    "code": "class RewardScaleEntry(BaseModel):\n    min_value: int\n    max_value: int\n    description: str"
  },
  {
    "type": "class",
    "name": "Observation",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 140,
    "end_line": 165,
    "code": "class Observation(BaseModel):\n    message: Optional[str] = Field(\n        None,\n        description=\"The message returned to the agent, will be displayed in message history.\",\n    )\n    summary: Optional[str] = Field(\n        None,\n        description=\"Summary of the observation, will be displayed in summarised message history.\",\n    )\n    terminal: bool = Field(\n        False, description=\"Indicates if this action results in a terminal state\"\n    )\n    expect_correction: bool = Field(\n        False,\n        description=\"Indicates that a the action arguments was inccorect and we expect a correction\",\n    )\n    properties: Optional[Dict[str, Any]] = Field(\n        default_factory=dict, description=\"Additional properties\"\n    )\n    execution_completion: Optional[Completion] = Field(\n        None, description=\"Completion created when executing the action\"\n    )\n\n    @classmethod\n    def create(cls, message: str, terminal: bool = False):\n        return cls(message=message, terminal=termina..."
  },
  {
    "type": "class",
    "name": "FewShotExample",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 168,
    "end_line": 176,
    "code": "class FewShotExample(BaseModel):\n    user_input: str = Field(..., description=\"The user's input/question\")\n    action: ActionArguments = Field(\n        ..., description=\"The expected response as ActionArguments\"\n    )\n\n    @classmethod\n    def create(cls, user_input: str, action: ActionArguments) -> \"FewShotExample\":\n        return cls(user_input=user_input, action=action)"
  },
  {
    "type": "class",
    "name": "ActionError",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 179,
    "end_line": 188,
    "code": "class ActionError(ActionArguments):\n    \"\"\"Error\"\"\"\n\n    error: str = Field(..., description=\"Error.\")\n\n    class Config:\n        title = \"Error\"\n\n    def to_prompt(self):\n        return f\"Error: {self.error}\""
  },
  {
    "type": "class",
    "name": "RetryException",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 191,
    "end_line": 197,
    "code": "class RetryException(Exception):\n    \"\"\"Exception raised when an action needs to be retried with corrected arguments.\"\"\"\n\n    def __init__(self, message: str, action_args: ActionArguments):\n        super().__init__(message)\n        self.message = message\n        self.action_args = action_args"
  },
  {
    "type": "class",
    "name": "CodeSpan",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 22,
    "end_line": 47,
    "code": "class CodeSpan(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: Optional[int] = Field(\n        None, description=\"The start line of the code to add to context.\"\n    )\n    end_line: Optional[int] = Field(\n        None, description=\"The end line of the code to add to context.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span id is a unique identifier for a code sippet. It can be a class name or function name. For functions in classes separete with a dot like 'class.function'.\",\n    )\n\n    @property\n    def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "type": "class",
    "name": "FurtherViewCodeArgs",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 50,
    "end_line": 86,
    "code": "class FurtherViewCodeArgs(ActionArguments):\n    \"\"\"View the code in a file or a specific code span.\"\"\"\n\n    thoughts: str = Field(..., description=\"Your thoughts on the code change.\")\n    files: List[CodeSpan] = Field(\n        ..., description=\"The code that should be provided in the file context.\"\n    )\n\n    class Config:\n        title = \"FurtherViewCode\"\n\n    @property\n    def log_name(self):\n        if len(self.files) == 1:\n            return f\"FurtherViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"FurtherViewCode(\" + \", \".join(logs) + \")\"\n\n    def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids..."
  },
  {
    "type": "class",
    "name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 89,
    "end_line": 371,
    "code": "class FurtherViewCode(Action, IdentifyMixin):\n    args_schema = FurtherViewCodeArgs\n\n    _repository: Repository = PrivateAttr()\n\n    def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n\n    max_tokens: int = Field(\n        3000,\n        description=\"The maximum number of tokens in the requested code.\",\n    )\n\n    def execute(\n        self,\n        args: FurtherViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file..."
  },
  {
    "type": "class",
    "name": "CodeSpan",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 22,
    "end_line": 47,
    "code": "class CodeSpan(BaseModel):\n    file_path: str = Field(\n        description=\"The file path where the relevant code is found.\"\n    )\n    start_line: Optional[int] = Field(\n        None, description=\"The start line of the code to add to context.\"\n    )\n    end_line: Optional[int] = Field(\n        None, description=\"The end line of the code to add to context.\"\n    )\n    span_ids: list[str] = Field(\n        default_factory=list,\n        description=\"Span IDs identiying the relevant code spans. A span id is a unique identifier for a code sippet. It can be a class name or function name. For functions in classes separete with a dot like 'class.function'.\",\n    )\n\n    @property\n    def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "type": "class",
    "name": "ViewCodeArgs",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 50,
    "end_line": 86,
    "code": "class ViewCodeArgs(ActionArguments):\n    \"\"\"View the code in a file or a specific code span.\"\"\"\n\n    thoughts: str = Field(..., description=\"Your thoughts on the code change.\")\n    files: List[CodeSpan] = Field(\n        ..., description=\"The code that should be provided in the file context.\"\n    )\n\n    class Config:\n        title = \"ViewCode\"\n\n    @property\n    def log_name(self):\n        if len(self.files) == 1:\n            return f\"ViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"ViewCode(\" + \", \".join(logs) + \")\"\n\n    def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids:\n                prompt += ..."
  },
  {
    "type": "class",
    "name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 89,
    "end_line": 371,
    "code": "class ViewCode(Action, IdentifyMixin):\n    args_schema = ViewCodeArgs\n\n    _repository: Repository = PrivateAttr()\n\n    def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n\n    max_tokens: int = Field(\n        3000,\n        description=\"The maximum number of tokens in the requested code.\",\n    )\n\n    def execute(\n        self,\n        args: ViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file_path not in grouped_..."
  },
  {
    "type": "class",
    "name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 24,
    "end_line": 255,
    "code": "class Action(BaseModel, ABC):\n    args_schema: ClassVar[Type[ActionArguments]]\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n\n    def execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        \"\"\"\n        Execute the action.\n        \"\"\"\n\n        message = self._execute(args, file_context=file_context)\n        return Observation.create(message)\n\n    def _execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> str | None:\n        \"\"\"\n        Execute the action and return the updated FileContext.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @property\n    def name(self) -> str:\n        \"\"\"Returns the name of the action class as a st ring.\"\"\"\n        return self.__class__.__name__\n\n    @classmethod\n    def get_name(cls) -> str:\n        ..."
  },
  {
    "type": "class",
    "name": "FindCalledObjectArgs",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 26,
    "end_line": 56,
    "code": "class FindCalledObjectArgs(SearchBaseArgs):\n    \"\"\"\n    这个函数就是FindCodeSnippet套了一层壳，输入是模型认为有用的调用对象的名字，会返回一段代码中被调用的对象的具体实现\n    \"\"\"\n\n    called_object: str = Field(..., description=\"The exact called object to find.\")\n    file_pattern: Optional[str] = Field(\n        default=None,\n        description=\"A glob pattern to filter search results to specific file types or directories. \",\n    )\n\n    class Config:\n        title = \"FindCalledObject\"\n\n    @model_validator(mode=\"after\")\n    def validate_snippet(self) -> \"FindCalledObjectArgs\":\n        if not self.called_object.strip():\n            raise ValueError(\"called object cannot be empty\")\n        return self\n\n    def to_prompt(self):\n        prompt = f\"Searching for called object: {self.called_object}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt\n\n    def short_summary(self) -> str:\n        param_str = f\"called_object={self.called_object}\"\n        if self.file_..."
  },
  {
    "type": "class",
    "name": "FindCalledObject",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 59,
    "end_line": 130,
    "code": "class FindCalledObject(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindCalledObjectArgs\n\n    max_hits: int = Field(\n        10,\n        description=\"The maximum number of search results to return. Default is 10.\",\n    )\n\n    def _search_for_context(\n        self, args: FindCalledObjectArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.called_object} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.called_object, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_path, line_num in matches\n                if fnmatch(file_path, args.file_pattern)\n            ]\n\n        search_result_context = FileContext(repo=self._repository)\n        for file_path, start_line in matches[: self.max_hits]:\n            num_lines = ..."
  },
  {
    "type": "class",
    "name": "ListFilesArgs",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 13,
    "end_line": 29,
    "code": "class ListFilesArgs(ActionArguments):\n    \"\"\"List files and directories in a specified directory.\"\"\"\n\n    directory: str = Field(\n        default=\"\",\n        description=\"The directory path to list. Empty string means root directory.\",\n    )\n\n    class Config:\n        title = \"ListFiles\"\n\n    def to_prompt(self):\n        return f\"List contents of directory: {self.directory or '(root)'}\"\n\n    def short_summary(self) -> str:\n        param_str = f\"directory={self.directory}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "class",
    "name": "ListFiles",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 32,
    "end_line": 100,
    "code": "class ListFiles(Action):\n    args_schema = ListFilesArgs\n\n    def execute(\n        self,\n        args: ListFilesArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if not file_context._repo:\n            raise RuntimeError(\"Repository not available for listing files.\")\n\n        try:\n            result = file_context._repo.list_directory(args.directory)\n\n            message = f\"Contents of directory '{args.directory or '(root)'}'\\n\\n\"\n\n            if result[\"directories\"]:\n                message += \"Directories:\\n\"\n                for directory in result[\"directories\"]:\n                    message += f\"📁 {directory}\\n\"\n                message += \"\\n\"\n\n            if result[\"files\"]:\n                message += \"Files:\\n\"\n                for file in result[\"files\"]:\n                    message += f\"📄 {file}\\n\"\n\n            if not result[\"directories\"] and not result[\"files\"]:\n                message += \"Directory is empty or does not exist.\"\n\n            r..."
  },
  {
    "type": "class",
    "name": "IdentifyMixin",
    "file": "identify_mixin.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 19,
    "end_line": 123,
    "code": "class IdentifyMixin:\n    \"\"\"Mixin that provides identify flow functionality for large code sections.\"\"\"\n\n    completion_model: Optional[CompletionModel] = Field(\n        None,\n        description=\"The completion model used to identify relevant code sections.\",\n    )\n    max_identify_tokens: int = Field(\n        8000,\n        description=\"The maximum number of tokens allowed in the identified code sections.\",\n    )\n    max_identify_prompt_tokens: int = Field(\n        16000,\n        description=\"The maximum number of tokens allowed in the identify prompt.\",\n    )\n\n    def _identify_code(\n        self, args, view_context: FileContext, max_tokens: int\n    ) -> Tuple[FileContext, Completion]:\n        \"\"\"Identify relevant code sections in a large context.\n\n        Args:\n            args: The arguments containing the request information\n            view_context: The context containing the code to identify from\n            max_tokens: The maximum number of tokens allowed in the result\n\n       ..."
  },
  {
    "type": "class",
    "name": "SemanticSearchArgs",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 10,
    "end_line": 53,
    "code": "class SemanticSearchArgs(SearchBaseArgs):\n    \"\"\"Use this when you don't know exact names or code but want to find related functionality.\n\n    Perfect for:\n    - Finding functionality by description: query=\"code that handles password hashing\"\n    - Finding related test cases: query=\"tests for user registration\", category=\"test\"\n    - Finding implementations: query=\"database connection pooling\", category=\"implementation\"\n    - Finding patterns: query=\"error handling for API requests\"\n\n    This is the most flexible search when you:\n    - Don't know exact function/class names\n    - Want to find similar implementations\n    - Need to discover related code\n    - Want to explore how certain features are implemented\n    \"\"\"\n\n    query: str = Field(\n        ..., description=\"Natural language description of what you're looking for.\"\n    )\n    category: Optional[str] = Field(\n        \"implementation\",\n        description=\"The category of files to search for. This can be 'implementation' for core ..."
  },
  {
    "type": "class",
    "name": "SemanticSearch",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 56,
    "end_line": 110,
    "code": "class SemanticSearch(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = SemanticSearchArgs\n\n    def _search(self, args: SemanticSearchArgs) -> SearchCodeResponse:\n        return self._code_index.semantic_search(\n            args.query,\n            file_pattern=args.file_pattern,\n            max_results=self.max_hits,\n            category=args.category,\n        )\n\n    def _search_for_alternative_suggestion(\n        self, args: SemanticSearchArgs\n    ) -> SearchCodeResponse:\n        if args.file_pattern:\n            return self._code_index.semantic_search(\n                args.query,\n                max_results=self.max_hits,\n                category=args.category,\n            )\n\n        return SearchCodeResponse()\n\n    @classmethod\n    def get_evaluation_criteria(cls, trajectory_length: int | None = None) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Query Relevance: Evaluate..."
  },
  {
    "type": "class",
    "name": "FindFunctionArgs",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 11,
    "end_line": 55,
    "code": "class FindFunctionArgs(SearchBaseArgs):\n    \"\"\"Use this when you know the exact name of a function or method you want to find.\n\n    Perfect for:\n    - Finding test cases: function_name=\"test_user_login\"\n    - Locating specific implementations: function_name=\"process_payment\"\n    - Finding all methods with a name: function_name=\"validate\"\n    - Finding a specific class method: function_name=\"save\", class_name=\"UserRepository\"\n    \"\"\"\n\n    function_name: str = Field(\n        ...,\n        description=\"The exact name of the function or method you want to find. Must match the function definition in code.\",\n    )\n    class_name: Optional[str] = Field(\n        default=None,\n        description=\"Optional class name if searching for a specific class method. Leave empty for standalone functions.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_names(self) -> \"FindFunctionArgs\":\n        if not self.function_name.strip():\n            raise ValueError(\"function_name cannot be empty\")\n  ..."
  },
  {
    "type": "class",
    "name": "FindFunction",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 58,
    "end_line": 141,
    "code": "class FindFunction(SearchBaseAction):\n    args_schema: ClassVar[Type[ActionArguments]] = FindFunctionArgs\n\n    def _search(self, args: FindFunctionArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.function_name} (class_name: {args.class_name}, file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_function(\n            args.function_name,\n            class_name=args.class_name,\n            file_pattern=args.file_pattern,\n        )\n\n    def _search_for_alternative_suggestion(\n        self, args: FindFunctionArgs\n    ) -> SearchCodeResponse:\n        \"\"\"Return methods in the same class or other methods in same file with the method name the method in class is not found.\"\"\"\n\n        if args.class_name and args.file_pattern:\n            file = self._repository.get_file(args.file_pattern)\n\n            span_ids = []\n            if file and file.module:\n                class_block = file.module.find_by_identifier(args.class_name)\n    ..."
  },
  {
    "type": "class",
    "name": "CodeQAAgent",
    "file": "code_qa_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 37,
    "end_line": 123,
    "code": "class CodeQAAgent(ActionAgent):\n    @classmethod\n    def create(\n        cls,\n        repository: Repository,\n        completion_model: CompletionModel,\n        preset_actions: List[Action] | None = None,\n        code_index: CodeIndex | None = None,\n        edit_completion_model: CompletionModel | None = None,\n        message_history_type: MessageHistoryType | None = None,\n        thoughts_in_action: bool = False,\n        **kwargs,\n    ):\n        # Clone the completion model to ensure we have our own instance\n        completion_model = completion_model.clone()\n\n        if message_history_type is None:\n            if completion_model.response_format == LLMResponseFormat.TOOLS:\n                message_history_type = MessageHistoryType.MESSAGES\n            else:\n                message_history_type = MessageHistoryType.REACT\n\n        action_completion_format = completion_model.response_format\n        if action_completion_format != LLMResponseFormat.TOOLS:\n            logger.info(\n        ..."
  },
  {
    "type": "class",
    "name": "AgentSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 9,
    "end_line": 51,
    "code": "class AgentSettings(BaseModel):\n    model_config = {\"frozen\": True}\n\n    completion_model: CompletionModel = Field(\n        ..., description=\"Completion model to be used for generating completions\"\n    )\n    system_prompt: Optional[str] = Field(\n        None, description=\"System prompt to be used for generating completions\"\n    )\n    actions: List[str] = Field(default_factory=list)\n    message_history_type: MessageHistoryType = Field(\n        default=MessageHistoryType.MESSAGES,\n        description=\"Determines how message history is generated\",\n    )\n    thoughts_in_action: bool = Field(\n        default=False,\n        description=\"Whether to include thoughts in the action or in the message\",\n    )\n\n    def __eq__(self, other):\n        if not isinstance(other, AgentSettings):\n            return False\n        return (\n            self.completion_model == other.completion_model\n            and self.system_prompt == other.system_prompt\n            and self.actions == other.actions\n        ..."
  },
  {
    "type": "class",
    "name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 27,
    "end_line": 371,
    "code": "class ActionAgent(BaseModel):\n    system_prompt: str = Field(\n        ..., description=\"System prompt to be used for generating completions\"\n    )\n    use_few_shots: bool = Field(\n        True, description=\"Whether to use few-shot examples for generating completions\"\n    )\n    thoughts_in_action: bool = Field(True, description=\"\")\n    actions: List[Action] = Field(default_factory=list)\n    message_generator: MessageHistoryGenerator = Field(\n        default_factory=lambda: MessageHistoryGenerator(),\n        description=\"Generator for message history\",\n    )\n\n    _completion: CompletionModel = PrivateAttr()\n    _action_map: dict[Type[ActionArguments], Action] = PrivateAttr(default_factory=dict)\n\n    def __init__(\n        self,\n        completion: CompletionModel,\n        system_prompt: str | None = None,\n        actions: List[Action] | None = None,\n        message_generator: MessageHistoryGenerator | None = None,\n        **data,\n    ):\n        actions = actions or []\n        message_gene..."
  },
  {
    "type": "class",
    "name": "UCTScore",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 72,
    "end_line": 105,
    "code": "class UCTScore:\n    final_score: float = 0.0\n    exploitation: float = 0.0\n    exploration: float = 0.0\n    depth_bonus: float = 0.0\n    depth_penalty: float = 0.0\n    high_value_leaf_bonus: float = 0.0\n    high_value_bad_children_bonus: float = 0.0\n    high_value_child_penalty: float = 0.0\n    high_value_parent_bonus: float = 0.0\n    finished_trajectory_penalty: float = 0.0\n    expect_correction_bonus: float = 0.0\n    diversity_bonus: float = 0.0\n    duplicate_child_penalty: float = 0.0\n    duplicate_action_penalty: float = 0.0\n\n    def __str__(self):\n        components = [\n            f\"Final Score: {self.final_score:.2f}\",\n            f\"Exploitation: {self.exploitation:.2f}\",\n            f\"Exploration: {self.exploration:.2f}\",\n            f\"Depth Bonus: {self.depth_bonus:.2f}\",\n            f\"Depth Penalty: {self.depth_penalty:.2f}\",\n            f\"High Value Leaf Bonus: {self.high_value_leaf_bonus:.2f}\",\n            f\"High Value Bad Children Bonus: {self.high_value_bad_children_bonus..."
  },
  {
    "type": "class",
    "name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 108,
    "end_line": 581,
    "code": "class Selector(BaseModel):\n    type: Literal[\"BestFirstSelector\", \"SoftmaxSelector\"] = Field(\n        ..., description=\"The type of selector\"\n    )\n    minimum_reward_threshold: float = Field(\n        default=-float(\"inf\"),\n        description=\"Minimum reward threshold for node selection. Nodes below this value will not be considered.\",\n    )\n    exploitation_weight: float = Field(\n        default=1.0,\n        description=\"Weight factor for the exploitation term in the UCT score calculation. Higher values favor exploitation over exploration.\",\n    )\n    use_average_reward: bool = Field(\n        default=False,\n        description=\"If True, uses average reward across the trajectory for exploitation calculation instead of node reward.\",\n    )\n    exploration_weight: float = Field(\n        default=1.0,\n        description=\"Weight factor for the exploration term in the UCT score calculation. Higher values encourage more exploration of less-visited nodes.\",\n    )\n    depth_weight: float = Fi..."
  },
  {
    "type": "class",
    "name": "BestFirstSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 584,
    "end_line": 610,
    "code": "class BestFirstSelector(Selector):\n    type: Literal[\"BestFirstSelector\"] = \"BestFirstSelector\"\n\n    def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        sorted_nodes = sorted(\n            nodes_with_scores, key=lambda x: x[1].final_score, reverse=True\n        )\n\n        # Log top nodes with detailed score breakdowns\n        top_nodes = sorted_nodes[: min(len(sorted_nodes), 10)]\n        logger.info(\"Comparing top nodes:\")\n        for i, (node, score) in enumerate(top_nodes):\n            logger.info(\n                f\"Node {node.node_id} - Visits: {node.visits} - \"\n                f\"Reward: {node.reward.value if node.reward else '-'} - \"\n                f\"\\nScore components: {score}\"\n            )\n\n        selected_node = sorted_nodes[0][0]\n        selected_score = sorted_nodes[0][1].final_score\n\n        logger.info(\n            f\"Selected Node {selected_node.n..."
  },
  {
    "type": "class",
    "name": "SoftmaxSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 613,
    "end_line": 650,
    "code": "class SoftmaxSelector(Selector):\n    type: Literal[\"SoftmaxSelector\"] = \"SoftmaxSelector\"\n\n    def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        uct_scores = [score.final_score for _, score in nodes_with_scores]\n\n        # Calculate softmax probabilities\n        softmax_scores = np.exp(uct_scores - np.max(uct_scores))\n        probabilities = softmax_scores / softmax_scores.sum()\n\n        # Log summary for top nodes\n        top_nodes = sorted(\n            zip(nodes, uct_scores, probabilities),\n            key=lambda x: x[1],\n            reverse=True,\n        )[:10]\n\n        logger.info(\"Softmax selection summary (top 10 nodes):\")\n        for node, score, prob in top_nodes:\n            logger.info(\n                f\"Node {node.node_id}: Visits={node.visits}, \"\n                f\"Reward={node.reward.value if node.reward else '-'}, \"\n                f\"UCTScore={..."
  },
  {
    "type": "class",
    "name": "NodeSelection",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 657,
    "end_line": 674,
    "code": "class NodeSelection(OpenAISchema):\n    # \"\"\"\n\n    # Scores range from -100 to 100.\n    # Select expandable nodes.\n\n    # OUTPUT FORMAT:\n    # <node_id>: Selected node ID\n    # <explanation>: Adress the agent responsible for generating the next action directly (e.g. \"You should ...\") with the following information:\n    #     ANCESTRY: Parent context, sibling outcomes, path differences.\n    #     CURRENT: Node state/potential, relation to successful paths.\n    #     DESCENDANTS: Child outcomes, pitfalls, unexplored directions.\n    #     GUIDANCE: Specific recommendations for the next action based on the information gathered from the tree.\n    # \"\"\"\n    node_id: int = Field(description=\"The ID of the selected node\")\n    explanation: str = Field(\n        description=\"Actionable guidance to the software engineer agent responsible for generating the next action.\"\n    )"
  },
  {
    "type": "class",
    "name": "LLMSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 684,
    "end_line": 904,
    "code": "class LLMSelector(Selector):\n    type: Literal[\"LLMSelector\"] = \"LLMSelector\"\n    completion: Optional[CompletionModel] = Field(\n        default=None, description=\"The completion model used to generate responses\"\n    )\n    max_iterations: Optional[int] = Field(\n        default=None, description=\"Maximum number of iterations for the selector\"\n    )\n\n    def __init__(\n        self, completion: CompletionModel = None, max_iterations: int = None, **kwargs\n    ):\n        # Initialize with all fields, including those from base class\n        all_kwargs = {\n            \"type\": \"LLMSelector\",\n            \"completion\": completion,\n            \"max_iterations\": max_iterations,\n            **kwargs,\n        }\n        super().__init__(**all_kwargs)\n\n    def get_action_definitions(self) -> str:\n        \"\"\"\n        Build a formatted string containing descriptions of all available actions.\n        \"\"\"\n        try:\n            from moatless_qa.actions import (\n                SemanticSearch,\n          ..."
  },
  {
    "type": "class",
    "name": "FeedbackSelector",
    "file": "feedback_selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 13,
    "end_line": 48,
    "code": "class FeedbackSelector(Selector):\n    \"\"\"A selector that uses previously generated feedback to make selection decisions.\"\"\"\n\n    type: Literal[\"feedback\"] = Field(\"feedback\")\n\n    def select(self, nodes: List[Node]) -> Optional[Node]:\n        \"\"\"Select a node based on existing feedback analysis.\"\"\"\n        if not nodes:\n            return None\n\n        for node in nodes:\n            # Check for existing feedback in node.completions\n            if hasattr(node, \"completions\") and \"feedback\" in node.completions:\n                feedback_completion: Completion = node.completions[\"feedback\"]\n                if feedback_completion and feedback_completion.response:\n                    try:\n                        # Extract feedback response data\n                        response_data = feedback_completion.response\n\n                        # If there's a suggested node ID, use it\n                        if \"suggested_node_id\" in response_data:\n                            suggested_node_id = re..."
  },
  {
    "type": "class",
    "name": "Message",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 13,
    "end_line": 15,
    "code": "class Message(BaseModel):\n    role: str = Field(..., description=\"The role of the sender\")\n    content: Optional[str] = Field(None, description=\"The message content\")"
  },
  {
    "type": "class",
    "name": "ToolCall",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 18,
    "end_line": 27,
    "code": "class ToolCall(BaseModel):\n    name: str = Field(..., description=\"The name of the tool being called\")\n    type: Optional[str] = Field(None, description=\"The type of tool call\")\n    input: Optional[dict[str, Any]] = Field(\n        None, description=\"The input parameters for the tool\"\n    )\n\n    def __post_init__(self):\n        # Ensure name is always a string\n        self.name = str(self.name)"
  },
  {
    "type": "class",
    "name": "AssistantMessage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 30,
    "end_line": 47,
    "code": "class AssistantMessage(Message):\n    role: str = Field(\"assistant\", description=\"The role of the assistant\")\n    content: Optional[str] = Field(None, description=\"The assistant's message content\")\n    tool_call: Optional[ToolCall] = Field(\n        None, description=\"Tool call made by the assistant\"\n    )\n\n    @property\n    def tool_call_id(self) -> Optional[str]:\n        \"\"\"Generate a deterministic tool call ID based on the tool call content\"\"\"\n        if not self.tool_call:\n            return None\n\n        # Create a string combining name and input for hashing\n        tool_str = f\"{str(self.tool_call.name)}:{json.dumps(self.tool_call.input, sort_keys=True)}\"\n        # Generate SHA-256 hash and take first 8 characters\n        hash_id = hashlib.sha256(tool_str.encode()).hexdigest()[:8]\n        return f\"call_{hash_id}\""
  },
  {
    "type": "class",
    "name": "UserMessage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 50,
    "end_line": 52,
    "code": "class UserMessage(Message):\n    role: str = Field(\"user\", description=\"The role of the user\")\n    content: str = Field(..., description=\"The user's message content\")"
  },
  {
    "type": "class",
    "name": "Usage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 55,
    "end_line": 160,
    "code": "class Usage(BaseModel):\n    completion_cost: float = 0\n    completion_tokens: int = 0\n    prompt_tokens: int = 0\n    cached_tokens: int = 0\n\n    @classmethod\n    def from_completion_response(\n        cls, completion_response: dict | BaseModel, model: str\n    ) -> Union[\"Usage\", None]:\n        if isinstance(completion_response, BaseModel) and hasattr(\n            completion_response, \"usage\"\n        ):\n            usage = completion_response.usage.model_dump()\n        elif isinstance(completion_response, dict) and \"usage\" in completion_response:\n            usage = completion_response[\"usage\"]\n        else:\n            logger.warning(\n                f\"No usage info available in completion response: {completion_response}\"\n            )\n            return None\n\n        logger.debug(f\"Usage: {json.dumps(usage, indent=2)}\")\n\n        prompt_tokens = usage.get(\"prompt_tokens\") or usage.get(\"input_tokens\", 0)\n\n        if usage.get(\"cache_creation_input_tokens\"):\n            prompt_tokens += u..."
  },
  {
    "type": "class",
    "name": "Completion",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 163,
    "end_line": 204,
    "code": "class Completion(BaseModel):\n    model: str\n    input: list[dict] | None = None\n    response: dict[str, Any] | None = None\n    retries: int | None = None\n    usage: Usage | None = None\n    flags: list[str] = Field(\n        default_factory=list,\n        description=\"List of flags indicating special conditions or states during completion\",\n    )\n\n    @classmethod\n    def from_llm_completion(\n        cls,\n        input_messages: list[dict],\n        completion_response: Any,\n        model: str,\n        usage: Usage | None = None,\n        retries: int | None = None,\n        flags: list[str] | None = None,\n    ) -> Optional[\"Completion\"]:\n        if isinstance(completion_response, BaseModel):\n            response = completion_response.model_dump()\n        elif isinstance(completion_response, dict):\n            response = completion_response\n        else:\n            logger.error(\n                f\"Unexpected completion response type: {type(completion_response)}\"\n            )\n            ret..."
  },
  {
    "type": "class",
    "name": "NameDescriptor",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 207,
    "end_line": 211,
    "code": "class NameDescriptor:\n    def __get__(self, obj, cls=None) -> str:\n        if hasattr(cls, \"Config\") and hasattr(cls.Config, \"title\") and cls.Config.title:\n            return cls.Config.title\n        return cls.__name__"
  },
  {
    "type": "class",
    "name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 214,
    "end_line": 496,
    "code": "class StructuredOutput(BaseModel):\n    name: ClassVar[NameDescriptor] = NameDescriptor()\n\n    class Config:\n        ignored_types = (classproperty,)\n\n    @classproperty\n    def description(cls):\n        return cls.model_json_schema().get(\"description\", \"\")\n\n    @classmethod\n    def openai_schema(cls, thoughts_in_action: bool = False) -> dict[str, Any]:\n        \"\"\"\n        Return the schema in the format of OpenAI's schema as jsonschema\n        \"\"\"\n        schema = cls.model_json_schema()\n        docstring = parse(cls.__doc__ or \"\")\n        parameters = {\n            k: v\n            for k, v in schema.items()\n            if k not in (\"title\", \"description\")\n            and (thoughts_in_action or k != \"thoughts\")\n        }\n\n        if not thoughts_in_action and parameters[\"properties\"].get(\"thoughts\"):\n            del parameters[\"properties\"][\"thoughts\"]\n\n        def remove_defaults(obj: dict) -> None:\n            \"\"\"Recursively remove default fields from a schema object\"\"\"\n            ..."
  },
  {
    "type": "class",
    "name": "LLMResponseFormat",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 24,
    "end_line": 28,
    "code": "class LLMResponseFormat(str, Enum):\n    TOOLS = \"tool_call\"\n    JSON = \"json\"\n    ANTHROPIC_TOOLS = \"anthropic_tools\"\n    REACT = \"react\""
  },
  {
    "type": "class",
    "name": "CompletionResponse",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 31,
    "end_line": 66,
    "code": "class CompletionResponse(BaseModel):\n    \"\"\"Container for completion responses that can include multiple structured outputs and text\"\"\"\n\n    structured_outputs: List[StructuredOutput] = Field(default_factory=list)\n    text_response: Optional[str] = Field(default=None)\n    completion: Optional[Completion] = Field(default=None)\n\n    @classmethod\n    def create(\n        cls,\n        text: str | None = None,\n        output: List[StructuredOutput] | StructuredOutput | None = None,\n        completion: Completion | None = None,\n    ) -> \"CompletionResponse\":\n        if isinstance(output, StructuredOutput):\n            outputs = [output]\n        elif isinstance(output, list):\n            outputs = output\n        else:\n            outputs = None\n\n        return cls(\n            text_response=text, structured_outputs=outputs, completion=completion\n        )\n\n    @property\n    def structured_output(self) -> Optional[StructuredOutput]:\n        \"\"\"Get the first structured output\"\"\"\n        if len(s..."
  },
  {
    "type": "class",
    "name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 69,
    "end_line": 366,
    "code": "class CompletionModel(BaseModel):\n    model: str = Field(..., description=\"The model to use for completion\")\n    temperature: float = Field(0.0, description=\"The temperature to use for completion\")\n    max_tokens: int = Field(\n        2000, description=\"The maximum number of tokens to generate\"\n    )\n    timeout: float = Field(\n        120.0, description=\"The timeout in seconds for completion requests\"\n    )\n    model_base_url: Optional[str] = Field(\n        default=None, description=\"The base URL for the model API\"\n    )\n    api_version: Optional[str] = Field(\n        default=None, description=\"The API version for the model\"\n    )\n    model_api_key: Optional[str] = Field(\n        default=None, description=\"The API key for the model\", exclude=True\n    )\n    response_format: Optional[LLMResponseFormat] = Field(\n        None, description=\"The response format expected from the LLM\"\n    )\n    stop_words: Optional[list[str]] = Field(\n        default=None, description=\"The stop words to use ..."
  },
  {
    "type": "class",
    "name": "AnthtropicCompletionModel",
    "file": "anthropic.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 24,
    "end_line": 214,
    "code": "class AnthtropicCompletionModel(CompletionModel):\n    response_format: Optional[LLMResponseFormat] = Field(\n        LLMResponseFormat.TOOLS, description=\"The response format expected from the LLM\"\n    )\n\n    @property\n    def supports_anthropic_computer_use(self):\n        return \"claude-3-5-sonnet-20241022\" in self.model\n\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        # Convert Message objects to dictionaries if needed\n        messages = [\n            msg.model_dump() if hasattr(msg, \"model_dump\") else msg for msg in messages\n        ]\n\n        total_usage = Usage()\n        retry_count = 0\n\n        tools = []\n        tool_choice = {\"type\": \"any\"}\n\n        actions = []\n        if not response_model:\n            tools = NOT_GIVEN\n            tool_choice = NOT_GIVEN\n        else:\n            if isinstance(response_model, li..."
  },
  {
    "type": "class",
    "name": "ReActCompletionModel",
    "file": "react.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 17,
    "end_line": 190,
    "code": "class ReActCompletionModel(CompletionModel):\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]],\n    ) -> CompletionResponse:\n        action_input_schemas = []\n\n        total_usage = Usage()\n        retry_count = 0\n\n        for action in response_model:\n            action_input_schemas.append(\n                f\" * {action.name} {action.format_schema_for_llm()}\"\n            )\n\n        system_prompt += dedent(f\"\"\"\\n# Response format\n\nUse the following format:\n\nThought: You should always think about what to do\nAction: The action to take followed by the input arguments based on the schema below\n\nUse one of the following actions and provide input arguments matching the schema.\n                            \n{'\\n\\n'.join(action_input_schemas)}\n\nImportant: Do not include multiple Thought-Action blocks. Do not include code blocks or additional text outside of this format.\n\"\"\")\n\n        messages.i..."
  },
  {
    "type": "class",
    "name": "ToolCallCompletionModel",
    "file": "tool_call.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 20,
    "end_line": 159,
    "code": "class ToolCallCompletionModel(CompletionModel):\n    def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        tools = []\n\n        if isinstance(response_model, list):\n            tools.extend(\n                [\n                    r.openai_schema(thoughts_in_action=self.thoughts_in_action)\n                    for r in response_model\n                ]\n            )\n        elif response_model:\n            tools.append(response_model.openai_schema())\n        else:\n            tools = None\n\n        total_usage = Usage()\n        retry_count = 0\n\n        messages.insert(0, {\"role\": \"system\", \"content\": system_prompt})\n\n        retries = tenacity.Retrying(\n            retry=tenacity.retry_if_not_exception_type(\n                (APIError, BadRequestError, NotFoundError, AuthenticationError)\n            ),\n            stop=tenacity.stop_after_..."
  },
  {
    "type": "class",
    "name": "ProvideReward",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 18,
    "end_line": 31,
    "code": "class ProvideReward(StructuredOutput):\n    \"\"\"Provide a reward value and explanation for a finished solution.\"\"\"\n\n    explanation: str = Field(\n        ...,\n        description=\"Provide a detailed analysis of how well the solution solves the original task. Consider functionality, correctness, and completeness. Focus on evaluating the end result rather than the process.\",\n    )\n\n    value: int = Field(\n        ...,\n        description=\"A single integer value based on how well the solution addresses the original requirements\",\n        ge=-100,\n        le=100,\n    )"
  },
  {
    "type": "class",
    "name": "ProvideRewardWithFeedback",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 34,
    "end_line": 40,
    "code": "class ProvideRewardWithFeedback(ProvideReward):\n    \"\"\"Provide a reward value, explanation, and feedback for a finished solution.\"\"\"\n\n    feedback: str = Field(\n        ...,\n        description=\"Write a direct message to a new AI agent that will attempt to solve this task from scratch. The agent has no knowledge of the current solution. Suggest high-level approaches and strategies they should consider. Focus on conceptual guidance rather than specific implementation details. This feedback will be used as initial strategic guidance for their completely fresh attempt.\",\n    )"
  },
  {
    "type": "class",
    "name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 43,
    "end_line": 373,
    "code": "class TerminalValueFunction(BaseModel):\n    \"\"\"Value function for evaluating finished solutions.\n\n    This class evaluates complete solutions to determine how well they solve the original task.\n    It provides:\n    - A numerical reward value (-100 to 100)\n    - An explanation analyzing the solution quality\n    - Feedback suggesting alternative approaches for future attempts\n\n    The feedback is designed to guide completely new solution attempts from scratch,\n    focusing on high-level strategies rather than specific implementation details.\n    This helps explore different approaches to solving the same task.\n\n    Note: This value function can only evaluate nodes with a \"Finish\" action.\n    For evaluating intermediate steps, use the base ValueFunction instead.\n    \"\"\"\n\n    completion_model: CompletionModel = Field(\n        ..., description=\"Completion model to be used for generating completions\"\n    )\n\n    include_node_suggestions: bool = Field(\n        False, description=\"Whether to in..."
  },
  {
    "type": "class",
    "name": "Reward",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 8,
    "end_line": 26,
    "code": "class Reward(StructuredOutput):\n    \"\"\"A structured output for providing reward values and feedback for actions.\"\"\"\n\n    class Config:\n        title = \"ProvideReward\"\n\n    explanation: Optional[str] = Field(\n        default=None,\n        description=\"An explanation and the reasoning behind your decision.\",\n    )\n    feedback: Optional[str] = Field(\n        None, description=\"Feedback to the alternative branch.\"\n    )\n    value: int = Field(\n        ...,\n        description=\"A single integer value between -100 and 100 based on your confidence in the correctness of the action and its likelihood of resolving the issue\",\n        ge=-100,\n        le=100,\n    )"
  },
  {
    "type": "class",
    "name": "CodingValueFunction",
    "file": "coding.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 38,
    "end_line": 131,
    "code": "class CodingValueFunction(ValueFunction):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._terminal_function = TerminalValueFunction(\n            completion_model=self.completion_model\n        )\n\n    def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        if node.observation.expect_correction and self.correction_award is not None:\n            # Start with the base correction award\n            correction_penalty = 0\n            current_node = node.parent\n\n            # Check parent nodes for expect_correction\n            while (\n                current_node\n                and current_node.observation\n                and current_node.observation.expect_correction\n            ):\n                if (\n                    current_node.observation\n                    and current_node.observation.expect_correction\n                ):\n                    correction_penalty += 25\n                current_node = current_node.parent\n\n      ..."
  },
  {
    "type": "class",
    "name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 17,
    "end_line": 287,
    "code": "class ValueFunction(BaseModel):\n    completion_model: CompletionModel = Field(\n        ..., description=\"Completion model to be used for generating completions\"\n    )\n    correction_award: Optional[int] = Field(\n        0,\n        description=\"The reward value to automatically assign when the agent expects a correction.\",\n    )\n    include_search_tree: bool = Field(\n        default=False,\n        description=\"Whether to include the search tree visualization in the value prompt\",\n    )\n    coding_value_function: Optional[\"ValueFunction\"] = Field(\n        default=None,\n        description=\"Optional CodingValueFunction to provide additional context for value decisions\",\n    )\n    message_generator: MessageHistoryGenerator = Field(\n        default_factory=lambda: MessageHistoryGenerator(),\n        description=\"Generator for message history\",\n    )\n\n    def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        # First get coding value function result if enabled\n      ..."
  },
  {
    "type": "class",
    "name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 16,
    "end_line": 247,
    "code": "class GitRepository(FileRepository):\n    repo_url: Optional[str] = Field(default=None, alias=\"git_repo_url\")\n    generate_commit_message: bool = Field(default=False)\n    completion: Optional[CompletionModel] = None\n    current_commit: str = Field(default=\"\")\n    current_diff: Optional[str] = None\n    initial_commit: str = Field(default=\"\")\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        from git import Repo\n\n        self._repo = Repo(path=self.repo_path)\n\n        if not self._repo.heads:\n            logger.error(f\"Repo at {self.repo_path} has no branches\")\n\n        if data.get(\"commit\"):\n            checkout_commit(self.repo_path, data[\"commit\"])\n\n        self.current_commit = self._repo.head.commit.hexsha\n        self.initial_commit = self.current_commit\n\n    @classmethod\n    def from_repo(cls, git_repo_url: str, repo_path: str, commit: Optional[str] = None):\n        logger.info(\n            f\"Create GitRepository for {git_repo_url} with commit {commit} on pa..."
  },
  {
    "type": "class",
    "name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 8,
    "end_line": 53,
    "code": "class Repository(BaseModel, ABC):\n    @abstractmethod\n    def get_file_content(self, file_path: str) -> Optional[str]:\n        pass\n\n    def file_exists(self, file_path: str) -> bool:\n        return True\n\n    def save_file(self, file_path: str, updated_content: str):\n        pass\n\n    def is_directory(self, file_path: str) -> bool:\n        return False\n\n    def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"repository_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump\n\n    @classmethod\n    def model_validate(cls, obj: Any) -> \"Repository\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            repository_class_path = obj.pop(\"repository_class\", None)\n\n            if repository_class_path:\n                module_name, class_name = repository_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                reposito..."
  },
  {
    "type": "class",
    "name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 56,
    "end_line": 83,
    "code": "class InMemRepository(Repository):\n    files: Dict[str, str] = Field(default_factory=dict)\n\n    def __init__(self, files: Dict[str, str] = None, **kwargs):\n        files = files or {}\n        super().__init__(files=files, **kwargs)\n\n    def get_file_content(self, file_path: str) -> Optional[str]:\n        return self.files.get(file_path)\n\n    def file_exists(self, file_path: str) -> bool:\n        return file_path in self.files\n\n    def save_file(self, file_path: str, updated_content: str):\n        self.files[file_path] = updated_content\n\n    def is_directory(self, file_path: str) -> bool:\n        return False\n\n    def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        return {\"files\": [], \"directories\": []}\n\n    def model_dump(self) -> Dict:\n        return {\"files\": self.files}\n\n    @classmethod\n    def model_validate(cls, obj: Dict):\n        return cls(files=obj.get(\"files\", {}))"
  },
  {
    "type": "class",
    "name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 20,
    "end_line": 98,
    "code": "class CodeFile(BaseModel):\n    file_path: str = Field(..., description=\"The path to the file\")\n\n    _content: str = PrivateAttr(\"\")\n    _repo_path: Optional[str] = PrivateAttr(None)\n    _module: Module | None = PrivateAttr(None)\n    _dirty: bool = PrivateAttr(False)\n    _last_modified: datetime | None = PrivateAttr(None)\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._content = kwargs.get(\"_content\", \"\")\n        self._repo_path = kwargs.get(\"repo_path\", None)\n        self._module = kwargs.get(\"_module\", None)\n        self._last_modified = kwargs.get(\"_last_modified\", None)\n\n    @classmethod\n    def from_file(cls, repo_path: str, file_path: str):\n        return cls(file_path=file_path, repo_path=repo_path)\n\n    @classmethod\n    def from_content(cls, file_path: str, content: str):\n        return cls(file_path=file_path, _content=content)\n\n    def get_file_content(self, file_path: str) -> Optional[str]:\n        return\n\n    def has_been_modified(self) ->..."
  },
  {
    "type": "class",
    "name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 101,
    "end_line": 441,
    "code": "class FileRepository(Repository):\n    repo_path: str = Field(..., description=\"The path to the repository\")\n\n    @property\n    def repo_dir(self):\n        return self.repo_path\n\n    def model_dump(self) -> Dict:\n        return {\"type\": \"file\", \"repo_path\": self.repo_path}\n\n    def get_full_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the full file path by combining repo_path and file_path.\n        All paths are treated as relative to repo_path, even if they start with '/'.\n\n        Args:\n            file_path: The file path to process (e.g., 'file.py' or '/src/file.py')\n\n        Returns:\n            str: The full path relative to repo_path\n        \"\"\"\n        # Strip leading slash if present\n        file_path = file_path.lstrip(\"/\")\n\n        # If file_path starts with repo_dir, make it relative\n        if file_path.startswith(self.repo_dir):\n            file_path = file_path.replace(self.repo_dir, \"\").lstrip(\"/\")\n\n        # Claude sets /repo/, remove it\n        if f..."
  },
  {
    "type": "class",
    "name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 14,
    "end_line": 149,
    "code": "class Module(CodeBlock):\n    file_path: Optional[str] = None\n    content: str = \"\"\n    spans_by_id: Dict[str, BlockSpan] = field(default_factory=dict)\n    language: Optional[str] = None\n    code_block: CodeBlock = field(\n        default_factory=lambda: CodeBlock(content=\"\", type=CodeBlockType.MODULE)\n    )\n    _graph: DiGraph = field(\n        default_factory=DiGraph, init=False\n    )  # TODO: Move to central CodeGraph\n\n    def __post_init__(self):\n        if not self.code_block.type == CodeBlockType.MODULE:\n            self.code_block.type = CodeBlockType.MODULE\n\n    # Delegate other methods to self.code_block as needed\n    def __getattr__(self, name):\n        return getattr(self.code_block, name)\n\n    @property\n    def module(self) -> \"Module\":  # noqa: F821\n        return self\n\n    def find_span_by_id(self, span_id: str) -> BlockSpan | None:\n        return self.spans_by_id.get(span_id)\n\n    def sum_tokens(self, span_ids: set[str] | None = None):\n        tokens = self.tokens\n        i..."
  },
  {
    "type": "class",
    "name": "SpanMarker",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 14,
    "end_line": 16,
    "code": "class SpanMarker(Enum):\n    TAG = 1\n    COMMENT = 2"
  },
  {
    "type": "class",
    "name": "CodeBlockTypeGroup",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 19,
    "end_line": 32,
    "code": "class CodeBlockTypeGroup(str, Enum):\n    STRUCTURE = \"Structures\"\n    IMPLEMENTATION = \"Implementation\"\n    IMPORT = \"Imports\"\n\n    BLOCK_DELIMITER = \"BlockDelimiter\"\n    SPACE = \"Space\"\n\n    COMMENT = \"Comment\"\n\n    ERROR = \"Error\"\n\n    def __str__(self):\n        return self.value"
  },
  {
    "type": "class",
    "name": "CodeBlockType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 35,
    "end_line": 109,
    "code": "class CodeBlockType(Enum):\n    MODULE = (\n        \"Module\",\n        CodeBlockTypeGroup.STRUCTURE,\n    )  # TODO: Module shouldn't be a STRUCTURE\n    CLASS = (\"Class\", CodeBlockTypeGroup.STRUCTURE)\n    FUNCTION = (\"Function\", CodeBlockTypeGroup.STRUCTURE)\n\n    # TODO: Remove and add sub types to functions and classes\n    CONSTRUCTOR = (\"Constructor\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_SUITE = (\"TestSuite\", CodeBlockTypeGroup.STRUCTURE)\n    TEST_CASE = (\"TestCase\", CodeBlockTypeGroup.STRUCTURE)\n\n    IMPORT = (\"Import\", CodeBlockTypeGroup.IMPORT)\n\n    EXPORT = (\"Export\", CodeBlockTypeGroup.IMPLEMENTATION)\n    COMPOUND = (\"Compound\", CodeBlockTypeGroup.IMPLEMENTATION)\n    # Dependent clauses are clauses that are dependent on another compound statement and can't be shown on their own\n    DEPENDENT_CLAUSE = (\"DependentClause\", CodeBlockTypeGroup.IMPLEMENTATION)\n    ASSIGNMENT = (\"Assignment\", CodeBlockTypeGroup.IMPLEMENTATION)\n    CALL = (\"Call\", CodeBlockTypeGroup.IMPLEMENTATION)\n    ST..."
  },
  {
    "type": "class",
    "name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 132,
    "end_line": 179,
    "code": "class PathTree:\n    show: bool = False\n    tree: dict[str, \"PathTree\"] = field(default_factory=dict)\n\n    @staticmethod\n    def from_block_paths(block_paths: list[BlockPath]) -> \"PathTree\":\n        tree = PathTree()\n        for block_path in block_paths:\n            tree.add_to_tree(block_path)\n\n        return tree\n\n    def child_tree(self, key: str) -> Optional[\"PathTree\"]:\n        return self.tree.get(key, None)\n\n    def merge(self, other: \"PathTree\"):\n        if other.show:\n            self.show = True\n\n        for key, value in other.tree.items():\n            if key not in self.tree:\n                self.tree[key] = PathTree()\n            self.tree[key].merge(value)\n\n    def extend_tree(self, paths: list[list[str]]):\n        for path in paths:\n            self.add_to_tree(path)\n\n    def add_to_tree(self, path: list[str]):\n        if path is None:\n            return\n\n        if len(path) == 0:\n            self.show = True\n            return\n\n        if len(path) == 1:\n            if..."
  },
  {
    "type": "class",
    "name": "ReferenceScope",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 182,
    "end_line": 189,
    "code": "class ReferenceScope(str, Enum):\n    EXTERNAL = \"external\"\n    DEPENDENCY = \"dependency\"  # External dependency\n    FILE = \"file\"  # File in repository\n    PROJECT = \"project\"\n    CLASS = \"class\"\n    LOCAL = \"local\"\n    GLOBAL = \"global\""
  },
  {
    "type": "class",
    "name": "RelationshipType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 192,
    "end_line": 201,
    "code": "class RelationshipType(str, Enum):\n    UTILIZES = \"utilizes\"\n    USES = \"uses\"\n    DEFINED_BY = \"defined_by\"\n    IS_A = \"is_a\"\n    PROVIDES = \"provides\"\n    IMPORTS = \"imports\"\n    CALLS = \"calls\"\n    DEPENDENCY = \"dependency\"\n    TYPE = \"type\""
  },
  {
    "type": "class",
    "name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 205,
    "end_line": 237,
    "code": "class Relationship:\n    scope: ReferenceScope\n    external_path: list[str] = field(default_factory=list)\n    resolved_path: list[str] = field(default_factory=list)\n    path: list[str] = field(default_factory=list)\n    type: RelationshipType = RelationshipType.USES\n    identifier: Optional[str] = None\n\n    def __post_init__(self):\n        if not self.external_path and not self.path:\n            raise ValueError(\"Cannot create Reference without external_path or path.\")\n\n    def __hash__(self):\n        return hash((self.scope, tuple(self.path)))\n\n    def __eq__(self, other):\n        return (self.scope, self.path) == (other.scope, other.path)\n\n    def full_path(self):\n        return self.external_path + self.path\n\n    def __str__(self):\n        start_node = self.identifier if self.identifier else \"\"\n\n        end_node = \"\"\n        if self.external_path:\n            end_node = \"/\".join(self.external_path)\n        if self.path:\n            if self.external_path:\n                end_node += \"/..."
  },
  {
    "type": "class",
    "name": "Parameter",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 241,
    "end_line": 243,
    "code": "class Parameter:\n    identifier: str\n    type: Optional[str] = None"
  },
  {
    "type": "class",
    "name": "SpanType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 246,
    "end_line": 249,
    "code": "class SpanType(str, Enum):\n    INITATION = \"init\"\n    DOCUMENTATION = \"docs\"\n    IMPLEMENTATION = \"impl\""
  },
  {
    "type": "class",
    "name": "BlockSpan",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 253,
    "end_line": 277,
    "code": "class BlockSpan:\n    span_id: str\n    span_type: SpanType\n    start_line: int\n    end_line: int\n    block_paths: list[BlockPath] = field(default_factory=list)\n    initiating_block: Optional[\"CodeBlock\"] = None\n    visible: bool = True\n    index: int = 0\n    parent_block_path: Optional[BlockPath] = None\n    is_partial: bool = False\n    tokens: int = 0\n\n    @property\n    def block_type(self):\n        return self.initiating_block.type if self.initiating_block else None\n\n    def __str__(self):\n        return f\"{self.span_id} ({self.span_type.value}, {self.tokens} tokens)\"\n\n    def get_first_child_block_path(self):\n        for block_path in self.block_paths:\n            if len(block_path) == len(self.parent_block_path):\n                continue\n            return block_path"
  },
  {
    "type": "class",
    "name": "ValidationError",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 281,
    "end_line": 282,
    "code": "class ValidationError:\n    error: str"
  },
  {
    "type": "class",
    "name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 286,
    "end_line": 1335,
    "code": "class CodeBlock:\n    type: CodeBlockType\n    content: str\n    identifier: Optional[str] = None\n    parameters: List[\"Parameter\"] = field(default_factory=list)\n    relationships: List[\"Relationship\"] = field(default_factory=list)\n    span_ids: Set[str] = field(default_factory=set)\n    belongs_to_span: Optional[\"BlockSpan\"] = None\n    has_error: bool = False\n    start_line: int = 0\n    end_line: int = 0\n    properties: Dict = field(default_factory=dict)\n    pre_code: str = \"\"\n    pre_lines: int = 0\n    indentation: str = \"\"\n    tokens: int = 0\n    children: List[\"CodeBlock\"] = field(default_factory=list)\n    validation_errors: List[str] = field(default_factory=list)\n    parent: Optional[\"CodeBlock\"] = None\n    previous: Optional[\"CodeBlock\"] = None\n    next: Optional[\"CodeBlock\"] = None\n\n    _content_lines: Optional[List[str]] = field(default=None, init=False)\n\n    def __post_init__(self):\n        self._content_lines = None\n\n        if self.children:\n            for child in self.childre..."
  },
  {
    "type": "class",
    "name": "JavaParser",
    "file": "java.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 7,
    "end_line": 12,
    "code": "class JavaParser(CodeParser):\n    def __init__(self, **kwargs):\n        super().__init__(Language(java.language()), **kwargs)\n        self.queries = []\n        self.queries.extend(self._build_queries(\"java.scm\"))\n        self.gpt_queries = []"
  },
  {
    "type": "class",
    "name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 26,
    "end_line": 135,
    "code": "class PythonParser(CodeParser):\n    def __init__(self, **kwargs):\n        language = Language(tspython.language())\n\n        super().__init__(language, **kwargs)\n\n        self.queries = []\n        self.queries.extend(self._build_queries(\"python.scm\"))\n\n        if self.apply_gpt_tweaks:\n            self.gpt_queries.extend(self._build_queries(\"python_gpt.scm\"))\n\n    @property\n    def language(self):\n        return \"python\"\n\n    def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        if (\n            codeblock.type == CodeBlockType.FUNCTION\n            and codeblock.identifier == \"__init__\"\n        ):\n            codeblock.type = CodeBlockType.CONSTRUCTOR\n\n        # Handle line breaks after assignment without \\\n        if (\n            codeblock.type == CodeBlockType.ASSIGNMENT\n            and codeblock.content_lines[0].strip().endswith(\"=\")\n            and node_match.check_child\n            and node_match.first_child\n            and node_match.check_child.start_point[0..."
  },
  {
    "type": "class",
    "name": "NodeMatch",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 33,
    "end_line": 41,
    "code": "class NodeMatch:\n    block_type: CodeBlockType = None\n    identifier_node: Node = None\n    first_child: Node = None\n    last_child: Node = None\n    check_child: Node = None\n    parameters: list[tuple[Node, Node | None]] = field(default_factory=list)\n    relationships: list[tuple[Node, str]] = field(default_factory=list)\n    query: str = None"
  },
  {
    "type": "class",
    "name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 70,
    "end_line": 925,
    "code": "class CodeParser:\n    def __init__(\n        self,\n        language: Language,\n        encoding: str = \"utf8\",\n        max_tokens_in_span: int = 500,\n        min_tokens_for_docs_span: int = 100,\n        min_lines_to_parse_block: Optional[\n            int\n        ] = None,  # If this is set code will just be parsed if they have more line than this\n        enable_code_graph: bool = True,\n        index_callback: Callable[[CodeBlock], None] | None = None,\n        tokenizer: Callable[[str], list] | None = None,\n        apply_gpt_tweaks: bool = False,\n        debug: bool = False,\n    ):\n        try:\n            self.tree_parser = Parser()\n            self.tree_parser.language = language\n            self.tree_language = language\n        except Exception as e:\n            logger.warning(f\"Could not get parser for language {language}.\")\n            raise e\n        self.apply_gpt_tweaks = apply_gpt_tweaks\n        self.index_callback = index_callback\n        self.debug = debug\n        self.encodin..."
  },
  {
    "type": "class",
    "name": "FeedbackResponse",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 19,
    "end_line": 67,
    "code": "class FeedbackResponse(StructuredOutput):\n    \"\"\"Schema for feedback response\"\"\"\n\n    action_name: str = \"provide_feedback\"\n\n    analysis: str = Field(\n        ...,\n        description=\"Brief analysis of parent state and lessons from alternative attempts\",\n    )\n    feedback: str = Field(\n        ..., description=\"Clear, actionable guidance for your next action\"\n    )\n    suggested_node_id: Optional[int] = Field(\n        None, description=\"ID of the node that should be expanded next (optional)\"\n    )\n\n    @classmethod\n    def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_feedback\",\n            \"description\": \"Provide feedback on the current state\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"analysis\": {\n                        \"type\": \"string\",\n                        ..."
  },
  {
    "type": "class",
    "name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 70,
    "end_line": 427,
    "code": "class FeedbackAgent(FeedbackGenerator):\n    completion_model: CompletionModel = Field(\n        ..., description=\"The completion model to use\"\n    )\n    instance_dir: str | None = Field(\n        None, description=\"Base directory for the instance\"\n    )\n    feedback_file: str | None = Field(None, description=\"Path to the feedback file\")\n\n    include_parent_info: bool = Field(True)\n    persist_path: str | None = Field(None)\n    include_tree: bool = Field(True)\n    include_node_suggestion: bool = Field(True)\n\n    def model_post_init(self, __context) -> None:\n        \"\"\"Initialize feedback file after model initialization\"\"\"\n        super().model_post_init(__context)\n\n        # Set instance directory if not provided\n        if not self.instance_dir:\n            self.instance_dir = os.getcwd()\n\n        # Set feedback file path\n        if not self.feedback_file:\n            # Create instance directory if it doesn't exist\n            os.makedirs(self.instance_dir, exist_ok=True)\n            sel..."
  },
  {
    "type": "class",
    "name": "FeedbackGenerator",
    "file": "feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 14,
    "end_line": 49,
    "code": "class FeedbackGenerator(BaseModel, ABC):\n    @abstractmethod\n    def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node.\"\"\"\n        pass\n\n    def model_dump(self, **kwargs) -> dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"feedback_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump\n\n    @classmethod\n    def model_validate(cls, obj: Any) -> \"FeedbackGenerator\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            feedback_class_path = obj.pop(\n                \"feedback_class\",\n                \"moatless_qa.feedback.ground_truth_feedback.GroundTruthFeedbackGenerator\",\n            )\n\n            try:\n                module_name, class_name = feedback_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                feedback_class =..."
  },
  {
    "type": "class",
    "name": "GroundTruthResponse",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 16,
    "end_line": 71,
    "code": "class GroundTruthResponse(StructuredOutput):\n    \"\"\"Schema for ground truth feedback response\"\"\"\n\n    action_name: str = \"provide_ground_truth_feedback\"\n\n    analysis: str = Field(\n        ...,\n        description=\"Detailed analysis of whether node response is supported by ground truth\",\n    )\n    has_ground_truth: bool = Field(\n        ..., description=\"Whether the response has ground truth support\"\n    )\n    feedback: str = Field(\n        ..., description=\"Detailed feedback on response quality\"\n    )\n    suggested_node_id: Optional[int] = Field(\n        None, description=\"ID of the node that should be expanded next (optional)\"\n    )\n    \n    @classmethod\n    def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_ground_truth_feedback\",\n            \"description\": \"Provide feedback on ground truth support\",\n            \"input_schema\": {\n         ..."
  },
  {
    "type": "class",
    "name": "GroundTruthFeedbackGenerator",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 74,
    "end_line": 272,
    "code": "class GroundTruthFeedbackGenerator(FeedbackGenerator):\n    \"\"\"Feedback generator that uses LLM to evaluate if responses have ground truth support\"\"\"\n    \n    completion_model: CompletionModel = Field(\n        ..., description=\"The completion model to use\"\n    )\n    include_tree: bool = Field(True, description=\"Whether to include tree visualization\")\n    include_node_suggestion: bool = Field(True, description=\"Whether to include node suggestions\")\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node\"\"\"\n        if not node.parent:\n            logger.info(\n                f\"Node {node.node_id} has no parent node, skipping feedback generation\"\n            )\n            return None\n        \n        messages = self._create_analysis_messages(node)\n        system_prompt = self._create_system_prompt()\n       ..."
  },
  {
    "type": "class",
    "name": "Colors",
    "file": "colors.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 1,
    "end_line": 10,
    "code": "class Colors:\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    GRAY = \"\\033[90m\"\n    RESET = \"\\033[0m\""
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "MoatlessError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 7,
    "end_line": 9,
    "code": "def __init__(self, message: str):\n        self.message = message\n        super().__init__(message)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CompletionError",
    "file": "exceptions.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 27,
    "end_line": 32,
    "code": "def __init__(\n        self, message: str, last_completion: Any = None, messages: List[dict] = None\n    ):\n        super().__init__(message)\n        self.last_completion = last_completion\n        self.messages = messages or []"
  },
  {
    "type": "function",
    "name": "expand",
    "class_name": "Expander",
    "file": "expander.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 26,
    "end_line": 59,
    "code": "def expand(\n        self, node: Node, search_tree, force_expansion: bool = False\n    ) -> None | Node:\n        \"\"\"Handle all node expansion logic in one place\"\"\"\n        if not force_expansion and node.is_fully_expanded():\n            return None\n\n        # Return the first unexecuted child if one exists\n        for child in node.children:\n            if not child.observation:\n                logger.info(\n                    f\"Found unexecuted child {child.node_id} for node {node.node_id}\"\n                )\n                return child\n\n        num_expansions = node.max_expansions or self.max_expansions\n        if not force_expansion and len(node.children) >= num_expansions:\n            logger.info(f\"Max expansions reached for node {node.node_id}\")\n            return None\n\n        settings_to_use = self._get_agent_settings(node)\n\n        child_node = Node(\n            node_id=search_tree._generate_unique_id(),\n            parent=node,\n            file_context=node.file_context.clone() ..."
  },
  {
    "type": "function",
    "name": "_get_agent_settings",
    "class_name": "Expander",
    "file": "expander.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 61,
    "end_line": 83,
    "code": "def _get_agent_settings(self, node: Node) -> List[AgentSettings]:\n        \"\"\"Get agent settings for a single expansion.\"\"\"\n        if not self.agent_settings:\n            return []\n\n        if self.random_settings:\n            used_settings = {\n                child.agent_settings\n                for child in node.children\n                if child.agent_settings is not None\n            }\n\n            available_settings = [\n                setting\n                for setting in self.agent_settings\n                if setting not in used_settings\n            ]\n\n            settings_pool = available_settings or self.agent_settings\n            return [random.choice(settings_pool)]\n        else:\n            num_children = len(node.children)\n            return [self.agent_settings[num_children % len(self.agent_settings)]]"
  },
  {
    "type": "function",
    "name": "_generate_unique_id",
    "class_name": "Expander",
    "file": "expander.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 85,
    "end_line": 86,
    "code": "def _generate_unique_id(self, node: Node):\n        return len(node.get_root().get_all_nodes())"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 49,
    "end_line": 50,
    "code": "def __init__(self, **data: Any):\n        super().__init__(**data)"
  },
  {
    "type": "function",
    "name": "serialize_message_history_type",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 53,
    "end_line": 56,
    "code": "def serialize_message_history_type(\n        self, message_history_type: MessageHistoryType\n    ) -> str:\n        return message_history_type.value"
  },
  {
    "type": "function",
    "name": "generate",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 58,
    "end_line": 70,
    "code": "def generate(self, node: \"Node\") -> List[AllMessageValues]:  # type: ignore\n        logger.debug(\n            f\"Generating message history for Node{node.node_id}: {self.message_history_type}\"\n        )\n        generators = {\n            MessageHistoryType.SUMMARY: self._generate_summary_history,\n            MessageHistoryType.REACT: self._generate_react_history,\n            MessageHistoryType.MESSAGES: self._generate_message_history,\n            MessageHistoryType.MESSAGES_COMPACT: self._generate_compact_message_history,\n        }\n        start_idx = 0 if self.include_root_node else 1\n        previous_nodes = node.get_trajectory()[start_idx:]\n        return generators[self.message_history_type](node, previous_nodes)"
  },
  {
    "type": "function",
    "name": "_generate_message_history",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 72,
    "end_line": 161,
    "code": "def _generate_message_history(\n        self, node: Node, previous_nodes: List[\"Node\"]\n    ) -> List[dict[str, Any]]:\n        messages = []\n        tool_idx = 0\n        tokens = 0\n\n        for i, previous_node in enumerate(previous_nodes):\n            # Handle user message\n            if previous_node.user_message:\n                message_content = [{\"type\": \"text\", \"text\": previous_node.user_message}]\n\n                # if previous_node.artifact_changes:\n                #     for change in previous_node.artifact_changes:\n                #         artifact = previous_node.workspace.get_artifact_by_id(\n                #             change.artifact_id\n                #         )\n                #         if artifact:\n                #             message = f\"{artifact.type} artifact: {artifact.id}\"\n                #             message_content.append({\"type\": \"text\", \"text\": message})\n                #             message_content.append(artifact.to_prompt_format())\n\n                messag..."
  },
  {
    "type": "function",
    "name": "_generate_compact_message_history",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 163,
    "end_line": 220,
    "code": "def _generate_compact_message_history(\n        self, node: Node, previous_nodes: List[\"Node\"]\n    ) -> List[dict[str, Any]]:\n        messages = [\n            ChatCompletionUserMessage(role=\"user\", content=node.get_root().message)\n        ]\n\n        if len(previous_nodes) <= 1:\n            return messages\n\n        node_messages = self.get_node_messages(node)\n\n        tool_idx = 0\n        tokens = 0\n\n        for action, observation in node_messages:\n            tool_calls = []\n            tool_idx += 1\n            tool_call_id = f\"tool_{tool_idx}\"\n\n            exclude = None\n            content = None\n\n            if not self.thoughts_in_action:\n                exclude = {\"thoughts\"}\n                content = action.thoughts\n\n            tool_call = {\n                \"id\": tool_call_id,\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": action.name,\n                    \"arguments\": action.model_dump_json(exclude=exclude),\n                },\n    ..."
  },
  {
    "type": "function",
    "name": "_generate_react_history",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 222,
    "end_line": 262,
    "code": "def _generate_react_history(\n        self, node: \"Node\", previous_nodes: List[\"Node\"]\n    ) -> List[AllMessageValues]:\n        messages = [\n            ChatCompletionUserMessage(role=\"user\", content=node.get_root().message)\n        ]\n\n        if len(previous_nodes) <= 1:\n            return messages\n\n        node_messages = self.get_node_messages(node)\n\n        # Convert node messages to react format\n        for action, observation in node_messages:\n            # Add thought and action message\n            thought = (\n                f\"Thought: {action.thoughts}\" if hasattr(action, \"thoughts\") else \"\"\n            )\n            action_str = f\"Action: {action.name}\"\n            action_input = action.format_args_for_llm()\n\n            assistant_content = f\"{thought}\\n{action_str}\"\n            if action_input:\n                assistant_content += f\"\\n{action_input}\"\n\n            messages.append(\n                ChatCompletionAssistantMessage(\n                    role=\"assistant\", content=ass..."
  },
  {
    "type": "function",
    "name": "_generate_summary_history",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 264,
    "end_line": 322,
    "code": "def _generate_summary_history(\n        self, node: Node, previous_nodes: List[Node]\n    ) -> List[AllMessageValues]:\n        formatted_history: List[str] = []\n        counter = 0\n\n        if self.include_root_node:\n            content = node.get_root().message\n            if not previous_nodes:\n                return [ChatCompletionUserMessage(role=\"user\", content=content)]\n        else:\n            content = \"\"\n            if not previous_nodes:\n                return []\n\n        for i, previous_node in enumerate(previous_nodes):\n            if previous_node.action:\n                counter += 1\n                formatted_state = f\"\\n\\n## Step {counter}\\n\"\n                if previous_node.action.thoughts:\n                    formatted_state += f\"Thoughts: {previous_node.action.thoughts}\\n\"\n                formatted_state += f\"Action: {previous_node.action.name}\\n\"\n                formatted_state += previous_node.action.to_prompt()\n\n                if previous_node.observation:\n         ..."
  },
  {
    "type": "function",
    "name": "get_node_messages",
    "class_name": "MessageHistoryGenerator",
    "file": "message_history.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 324,
    "end_line": 463,
    "code": "def get_node_messages(self, node: \"Node\") -> List[tuple[ActionArguments, str]]:\n        \"\"\"\n        Creates a list of (action, observation) tuples from the node's trajectory.\n        Respects token limits while preserving ViewCode context.\n\n        Returns:\n            List of tuples where each tuple contains:\n            - ActionArguments object\n            - Observation summary string\n        \"\"\"\n        previous_nodes = node.get_trajectory()[:-1]\n        if not previous_nodes:\n            return []\n\n        # Calculate initial token count\n        total_tokens = node.file_context.context_size()\n        total_tokens += count_tokens(node.get_root().message)\n\n        node_messages = []\n        shown_files = set()\n        shown_diff = False  # Track if we've shown the first diff\n\n        for i, previous_node in enumerate(reversed(previous_nodes)):\n            current_messages = []\n\n            if previous_node.action_steps:\n                for i, action_step in enumerate(previous_node.ac..."
  },
  {
    "type": "function",
    "name": "is_executed",
    "class_name": "ActionStep",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 26,
    "end_line": 28,
    "code": "def is_executed(self) -> bool:\n        \"\"\"Check if this action step has been executed by verifying if it has observations.\"\"\"\n        return self.observation is not None"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "ActionStep",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 30,
    "end_line": 38,
    "code": "def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n\n        data[\"action\"] = self.action.model_dump(**kwargs)\n        data[\"action\"][\"action_args_class\"] = (\n            f\"{self.action.__class__.__module__}.{self.action.__class__.__name__}\"\n        )\n\n        return data"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "ActionStep",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 41,
    "end_line": 45,
    "code": "def model_validate(cls, obj: Any, **kwargs) -> \"ActionArguments\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            obj[\"action\"] = ActionArguments.model_validate(obj[\"action\"])\n        return super().model_validate(obj, **kwargs)"
  },
  {
    "type": "function",
    "name": "action",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 116,
    "end_line": 120,
    "code": "def action(self) -> Optional[ActionArguments]:\n        \"\"\"Backward compatibility: Get action from the latest action step\"\"\"\n        if not self.action_steps:\n            return None\n        return self.action_steps[-1].action if self.action_steps else None"
  },
  {
    "type": "function",
    "name": "action",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 123,
    "end_line": 129,
    "code": "def action(self, value: Optional[ActionArguments]):\n        \"\"\"Backward compatibility: Set action on the current/new action step\"\"\"\n\n        if not self.action_steps:\n            self.action_steps = [ActionStep(action=value)]\n        else:\n            self.action_steps[-1].action = value"
  },
  {
    "type": "function",
    "name": "observation",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 132,
    "end_line": 136,
    "code": "def observation(self) -> Optional[Observation]:\n        \"\"\"Backward compatibility: Get observation from the latest action step\"\"\"\n        if not self.action_steps:\n            return None\n        return self.action_steps[-1].observation if self.action_steps else None"
  },
  {
    "type": "function",
    "name": "observation",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 139,
    "end_line": 148,
    "code": "def observation(self, value: Optional[Observation]):\n        \"\"\"Backward compatibility: Set observation on the current/new action step\"\"\"\n        if value is None:\n            return\n\n        if not self.action_steps:\n            # Create new action step if setting observation on empty node\n            self.action_steps.append(ActionStep(action=self.action, observation=value))\n        else:\n            self.action_steps[-1].observation = value"
  },
  {
    "type": "function",
    "name": "message",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 151,
    "end_line": 153,
    "code": "def message(self) -> Optional[str]:\n        \"\"\"Backward compatibility: Get message maps to user_message\"\"\"\n        return self.user_message"
  },
  {
    "type": "function",
    "name": "message",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 156,
    "end_line": 158,
    "code": "def message(self, value: Optional[str]):\n        \"\"\"Backward compatibility: Set message maps to user_message\"\"\"\n        self.user_message = value"
  },
  {
    "type": "function",
    "name": "stub",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 161,
    "end_line": 169,
    "code": "def stub(cls, **kwargs):\n        \"\"\"Create a stub node with a unique ID.\"\"\"\n        # Get the highest existing node ID from the kwargs or use 0\n        existing_nodes = kwargs.get(\"children\", [])\n        highest_id = (\n            max([n.node_id for n in existing_nodes] + [kwargs.get(\"node_id\", -1), -1])\n            + 1\n        )\n        return cls(node_id=highest_id, **kwargs)"
  },
  {
    "type": "function",
    "name": "is_leaf",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 171,
    "end_line": 173,
    "code": "def is_leaf(self) -> bool:\n        \"\"\"Check if the node is a leaf node (no children).\"\"\"\n        return len(self.children) == 0"
  },
  {
    "type": "function",
    "name": "expanded_count",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 175,
    "end_line": 177,
    "code": "def expanded_count(self) -> int:\n        \"\"\"Get the number of expanded children.\"\"\"\n        return len([child for child in self.children])"
  },
  {
    "type": "function",
    "name": "is_fully_expanded",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 179,
    "end_line": 181,
    "code": "def is_fully_expanded(self) -> bool:\n        \"\"\"Check if all possible actions have been tried and executed from this node.\"\"\"\n        return self.expanded_count() >= (self.max_expansions or 1)"
  },
  {
    "type": "function",
    "name": "is_terminal",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 183,
    "end_line": 186,
    "code": "def is_terminal(self) -> bool:\n        \"\"\"Determine if the current state is a terminal state.\"\"\"\n\n        return self.terminal"
  },
  {
    "type": "function",
    "name": "is_finished",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 188,
    "end_line": 193,
    "code": "def is_finished(self) -> bool:\n        \"\"\"Determine if the node is succesfully finished\"\"\"\n        if self.action and self.action.name == \"Finish\":\n            return True\n\n        return False"
  },
  {
    "type": "function",
    "name": "add_child",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 195,
    "end_line": 198,
    "code": "def add_child(self, child_node: \"Node\"):\n        \"\"\"Add a child node to this node.\"\"\"\n        child_node.parent = self\n        self.children.append(child_node)"
  },
  {
    "type": "function",
    "name": "set_parent",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 200,
    "end_line": 204,
    "code": "def set_parent(self, parent: \"Node\"):\n        if self.node_id == parent.node_id:\n            raise ValueError(f\"Node can't have same id {self.node_id} parent\")\n        self.parent = parent\n        parent.add_child(self)"
  },
  {
    "type": "function",
    "name": "get_depth",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 206,
    "end_line": 212,
    "code": "def get_depth(self) -> int:\n        depth = 0\n        node = self\n        while node.parent:\n            depth += 1\n            node = node.parent\n        return depth"
  },
  {
    "type": "function",
    "name": "is_expandable",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 214,
    "end_line": 220,
    "code": "def is_expandable(self) -> bool:\n        \"\"\"Check if the node can be expanded further.\"\"\"\n        return (\n            not self.is_terminal()\n            and not self.is_fully_expanded()\n            and not self.is_duplicate\n        )"
  },
  {
    "type": "function",
    "name": "find_duplicate",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 222,
    "end_line": 230,
    "code": "def find_duplicate(self) -> Optional[\"Node\"]:\n        if not self.parent:\n            return None\n\n        for child in self.parent.children:\n            if child.node_id != self.node_id and child.equals(self):\n                return child\n\n        return None"
  },
  {
    "type": "function",
    "name": "get_sibling_nodes",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 232,
    "end_line": 238,
    "code": "def get_sibling_nodes(self) -> List[\"Node\"]:\n        if not self.parent:\n            return []\n\n        return [\n            child for child in self.parent.children if child.node_id != self.node_id\n        ]"
  },
  {
    "type": "function",
    "name": "get_trajectory",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 240,
    "end_line": 247,
    "code": "def get_trajectory(self) -> List[\"Node\"]:\n        nodes = []\n        current_node = self\n        while current_node is not None:\n            nodes.insert(0, current_node)\n            current_node = current_node.parent\n\n        return nodes"
  },
  {
    "type": "function",
    "name": "get_expandable_descendants",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 249,
    "end_line": 256,
    "code": "def get_expandable_descendants(self) -> List[\"Node\"]:\n        \"\"\"Get all expandable descendants of this node, including self if expandable.\"\"\"\n        expandable_nodes = []\n        if self.is_expandable():\n            expandable_nodes.append(self)\n        for child in self.children:\n            expandable_nodes.extend(child.get_expandable_descendants())\n        return expandable_nodes"
  },
  {
    "type": "function",
    "name": "get_expanded_descendants",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 258,
    "end_line": 265,
    "code": "def get_expanded_descendants(self) -> List[\"Node\"]:\n        \"\"\"Get all expanded descendants of this node, including self if expanded.\"\"\"\n        expanded_nodes = []\n        if self.expanded_count() > 0:\n            expanded_nodes.append(self)\n        for child in self.children:\n            expanded_nodes.extend(child.get_expanded_descendants())\n        return expanded_nodes"
  },
  {
    "type": "function",
    "name": "get_all_nodes",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 267,
    "end_line": 273,
    "code": "def get_all_nodes(self) -> List[\"Node\"]:\n        if self.parent:\n            node = self.get_root()\n        else:\n            node = self\n\n        return node._get_all_nodes()"
  },
  {
    "type": "function",
    "name": "get_leaf_nodes",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 275,
    "end_line": 277,
    "code": "def get_leaf_nodes(self) -> List[\"Node\"]:\n        \"\"\"Get all leaf nodes .\"\"\"\n        return [node for node in self.get_root().get_all_nodes() if node.is_leaf()]"
  },
  {
    "type": "function",
    "name": "_get_all_nodes",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 279,
    "end_line": 284,
    "code": "def _get_all_nodes(self) -> List[\"Node\"]:\n        nodes = []\n        nodes.append(self)\n        for child in self.children:\n            nodes.extend(child._get_all_nodes())\n        return nodes"
  },
  {
    "type": "function",
    "name": "get_root",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 286,
    "end_line": 290,
    "code": "def get_root(self) -> \"Node\":\n        node = self\n        while node.parent:\n            node = node.parent\n        return node"
  },
  {
    "type": "function",
    "name": "calculate_mean_reward",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 292,
    "end_line": 305,
    "code": "def calculate_mean_reward(self) -> float:\n        \"\"\"\n        Calculate the mean trajectory reward for this node.\n\n        Returns:\n            float: The mean reward.\n        \"\"\"\n        rewards = []\n        node = self\n        while node is not None:\n            rewards.append(node.value / node.visits if node.visits > 0 else 0)\n            node = node.parent\n\n        return sum(rewards) / len(rewards) if rewards else 0"
  },
  {
    "type": "function",
    "name": "total_usage",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 307,
    "end_line": 319,
    "code": "def total_usage(self) -> Usage:\n        total_usage = Usage()\n\n        # Sum usage across all action steps\n        for step in self.action_steps:\n            if step.completion:\n                total_usage += step.completion.usage\n\n        for completion in self.completions.values():\n            if completion:\n                total_usage += completion.usage\n\n        return total_usage"
  },
  {
    "type": "function",
    "name": "equals",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 321,
    "end_line": 331,
    "code": "def equals(self, other: \"Node\"):\n        if self.action and not other.action:\n            return False\n\n        if not self.action and other.action:\n            return False\n\n        if self.action.name != other.action.name:\n            return False\n\n        return self.action.equals(other.action)"
  },
  {
    "type": "function",
    "name": "reset",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 333,
    "end_line": 343,
    "code": "def reset(self):\n        \"\"\"Reset the node state to be able to execute it again.\"\"\"\n        self.action_steps = []\n        self.user_message = None\n        self.assistant_message = None\n        self.visits = 0\n        self.value = 0.0\n        self.is_duplicate = False\n        if self.parent and self.parent.file_context:\n            self.file_context = self.parent.file_context.clone()\n        self.children = []"
  },
  {
    "type": "function",
    "name": "clone_and_reset",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 345,
    "end_line": 373,
    "code": "def clone_and_reset(self) -> \"Node\":\n        \"\"\"\n        Creates a copy of the node and resets its observation and file context.\n\n        Returns:\n            Node: A new node instance with reset state\n        \"\"\"\n        # Find highest node ID in the tree to ensure uniqueness\n        root = self.get_root()\n        all_nodes = root.get_all_nodes()\n        highest_id = max(node.node_id for node in all_nodes) + 1\n\n        # Create a new node with same base attributes but new ID\n        new_node = Node(\n            node_id=highest_id,  # Use new unique ID\n            parent=self.parent,\n            visits=self.visits,\n            value=self.value,\n            max_expansions=self.max_expansions,\n            user_message=self.user_message,\n            is_duplicate=self.is_duplicate,\n            action=self.action,\n            possible_actions=self.possible_actions.copy()\n            if self.possible_actions\n            else [],\n        )\n\n        new_node.reset()\n        return new_node"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 375,
    "end_line": 418,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Generate a dictionary representation of the node and its descendants.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the node tree.\n        \"\"\"\n\n        exclude_set = {\"parent\", \"children\"}\n        if \"exclude\" in kwargs:\n            if isinstance(kwargs[\"exclude\"], set):\n                exclude_set.update(kwargs[\"exclude\"])\n            elif isinstance(kwargs[\"exclude\"], dict):\n                exclude_set.update(kwargs[\"exclude\"].keys())\n\n        new_kwargs = {k: v for k, v in kwargs.items() if k != \"exclude\"}\n        node_dict = super().model_dump(exclude=exclude_set, **new_kwargs)\n\n        if self.completions and \"completions\" not in exclude_set:\n            node_dict[\"completions\"] = {\n                key: completion.model_dump(**kwargs)\n                for key, completion in self.completions.items()\n                if completion\n            }\n\n        if self.reward and \"reward\" not ..."
  },
  {
    "type": "function",
    "name": "_reconstruct_node",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 421,
    "end_line": 487,
    "code": "def _reconstruct_node(\n        cls,\n        node_data: Dict[str, Any],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"Update reconstruction to handle both old and new formats\"\"\"\n\n        # Handle legacy format conversion\n        if \"action\" in node_data and not \"action_steps\" in node_data:\n            action = node_data.get(\"action\")\n            observation = node_data.get(\"output\")\n            completions = node_data.get(\"completions\", {})\n\n            if action or observation or completions:\n                node_data[\"action_steps\"] = [\n                    {\n                        \"action\": action,\n                        \"observation\": observation,\n                        \"completions\": completions,\n                    }\n                ]\n\n        if \"message\" in node_data and not \"user_message\" in node_data:\n            node_data[\"user_message\"] = node_data.pop(\"message\")\n\n        if node_data.get(\"action_st..."
  },
  {
    "type": "function",
    "name": "reconstruct",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 490,
    "end_line": 512,
    "code": "def reconstruct(\n        cls,\n        data: Union[Dict[str, Any], List[Dict[str, Any]]],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"\n        Reconstruct a node tree from either dict (tree) or list format.\n\n        Args:\n            data: Either a dict (tree format) or list of dicts (list format)\n            parent: Optional parent node (used internally)\n            repo: Optional repository reference\n\n        Returns:\n            Node: Root node of reconstructed tree\n        \"\"\"\n        # Handle list format\n        if isinstance(data, list):\n            return cls._reconstruct_from_list(data, repo=repo)\n\n        # Handle single node reconstruction (dict format)\n        return cls._reconstruct_node(data, repo=repo)"
  },
  {
    "type": "function",
    "name": "_reconstruct_from_list",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 515,
    "end_line": 550,
    "code": "def _reconstruct_from_list(\n        cls,\n        node_list: List[Dict],\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ) -> \"Node\":\n        \"\"\"\n        Reconstruct tree from a flat list of nodes.\n\n        Args:\n            node_list: List of serialized nodes\n            repo: Optional repository reference\n\n        Returns:\n            Node: Root node of reconstructed tree\n        \"\"\"\n        # Create nodes without relationships first\n        nodes_by_id = {}\n\n        for node_data in node_list:\n            parent_id = node_data.pop(\"parent_id\", None)\n            # Use the core reconstruct method for each node\n            node = cls._reconstruct_node(node_data, repo=repo)\n            nodes_by_id[node.node_id] = (node, parent_id)\n\n        # Connect parent-child relationships\n        for node, parent_id in nodes_by_id.values():\n            if parent_id is not None:\n                parent_node = nodes_by_id[parent_id][0]\n                par..."
  },
  {
    "type": "function",
    "name": "dump_as_list",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 552,
    "end_line": 566,
    "code": "def dump_as_list(self, **kwargs) -> List[Dict[str, Any]]:\n        \"\"\"\n        Dump all nodes as a flat list structure.\n        \"\"\"\n        nodes = self.get_all_nodes()\n        node_list = []\n\n        for node in nodes:\n            node_data = node.model_dump(exclude={\"parent\", \"children\"}, **kwargs)\n            node_data[\"parent_id\"] = (\n                node.parent.node_id if node.parent is not None else None\n            )\n            node_list.append(node_data)\n\n        return node_list"
  },
  {
    "type": "function",
    "name": "load_from_file",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 569,
    "end_line": 587,
    "code": "def load_from_file(cls, file_path: str, repo: Repository | None = None) -> \"Node\":\n        \"\"\"\n        Load node tree from file, supporting both old tree format and new list format.\n\n        Args:\n            file_path (str): Path to the saved node data\n            repo (Repository): Optional repository reference\n\n        Returns:\n            Node: Root node of the tree\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n\n        if isinstance(data, list):\n            return cls.reconstruct_from_list(data, repo=repo)\n        else:\n            # Old tree format\n            return cls.reconstruct(data, repo=repo)"
  },
  {
    "type": "function",
    "name": "persist",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 589,
    "end_line": 602,
    "code": "def persist(self, file_path: str, format: str = \"list\"):\n        \"\"\"\n        Persist the node tree to file.\n\n        Args:\n            file_path (str): The path to save to\n            format (str): Either \"list\" (new) or \"tree\" (legacy)\n        \"\"\"\n        if format == \"list\":\n            self.persist_as_list(file_path)\n        elif format == \"tree\":\n            self.persist_tree(file_path)\n        else:\n            raise ValueError(\"Format must be either 'list' or 'tree'\")"
  },
  {
    "type": "function",
    "name": "truncate_children_by_id",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 604,
    "end_line": 613,
    "code": "def truncate_children_by_id(self, max_id: int):\n        \"\"\"Truncate children to only include nodes with IDs less than or equal to the specified value.\n\n        Args:\n            max_id (int): Maximum node ID to keep (inclusive)\n        \"\"\"\n        self.children = [child for child in self.children if child.node_id <= max_id]\n        # Recursively truncate remaining children\n        for child in self.children:\n            child.truncate_children_by_id(max_id)"
  },
  {
    "type": "function",
    "name": "has_unexecuted_actions",
    "class_name": "Node",
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 615,
    "end_line": 617,
    "code": "def has_unexecuted_actions(self) -> bool:\n        \"\"\"Check if any action step in this node has not been executed.\"\"\"\n        return any(not step.is_executed() for step in self.action_steps)"
  },
  {
    "type": "function",
    "name": "generate_ascii_tree",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 620,
    "end_line": 651,
    "code": "def generate_ascii_tree(\n    root: Node,\n    current: Optional[Node] = None,\n    include_explanation: bool = False,\n    include_diffs: bool = False,\n    include_feedback: bool = False,\n    include_action_details: bool = False,\n    include_file_context: bool = False,\n    use_color: bool = True,\n    show_trajectory: bool = False,\n) -> str:\n    \"\"\"Create an ASCII representation of the tree.\"\"\"\n    tree_lines = [\"MCTS Tree\"]\n    # Make sure we're starting from the actual root node\n    if root.parent:\n        root = root.get_root()\n\n    _append_ascii_node(\n        root,\n        \"\",\n        True,\n        tree_lines,\n        current,\n        include_explanation,\n        include_diffs,\n        include_feedback,\n        include_action_details,\n        include_file_context,\n        use_color,\n        show_trajectory,\n    )\n    return \"\\n\".join(tree_lines)"
  },
  {
    "type": "function",
    "name": "_append_ascii_node",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 654,
    "end_line": 807,
    "code": "def _append_ascii_node(\n    node: Node,\n    prefix: str,\n    is_last: bool,\n    tree_lines: list[str],\n    current: Node | None,\n    include_explanation: bool = False,\n    include_diffs: bool = False,\n    include_feedback: bool = False,\n    include_action_details: bool = False,\n    include_file_context: bool = False,\n    use_color: bool = True,\n    show_trajectory: bool = False,\n) -> None:\n    # Get current trajectory nodes if we have a current node and trajectory marking is enabled\n    current_trajectory_nodes = []\n    if current and show_trajectory:\n        current_trajectory_nodes = current.get_trajectory()\n\n    # Build node information\n    state_params = []\n    if node.action_steps:\n        # Include all action names from action steps\n        action_names = [step.action.name for step in node.action_steps if step.action]\n        state_params.extend(action_names)\n        # Check if any action step expects correction\n        if any(\n            step.observation and step.observation.ex..."
  },
  {
    "type": "function",
    "name": "_append_wrapped_text",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 810,
    "end_line": 835,
    "code": "def _append_wrapped_text(\n    tree_lines: list[str], text: str, prefix: str, header_prefix: str = \"│ \"\n):\n    \"\"\"Helper function to wrap and append text with proper prefixes.\"\"\"\n    words = text.split()\n    current_line = []\n    current_length = 0\n    max_line_length = 100 - len(prefix) - len(header_prefix)\n\n    # First line gets the header prefix\n    is_first_line = True\n\n    for word in words:\n        if current_length + len(word) + 1 <= max_line_length:\n            current_line.append(word)\n            current_length += len(word) + 1\n        else:\n            line_prefix = header_prefix if is_first_line else \"│   \"\n            tree_lines.append(f\"{prefix}{line_prefix}{' '.join(current_line)}\")\n            current_line = [word]\n            current_length = len(word)\n            is_first_line = False\n\n    if current_line:\n        line_prefix = header_prefix if is_first_line else \"│   \"\n        tree_lines.append(f\"{prefix}{line_prefix}{' '.join(current_line)}\")"
  },
  {
    "type": "function",
    "name": "color_red",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 838,
    "end_line": 839,
    "code": "def color_red(text: Any) -> str:\n    return f\"\\033[91m{text}\\033[0m\""
  },
  {
    "type": "function",
    "name": "color_green",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 842,
    "end_line": 843,
    "code": "def color_green(text: Any) -> str:\n    return f\"\\033[92m{text}\\033[0m\""
  },
  {
    "type": "function",
    "name": "color_yellow",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 846,
    "end_line": 847,
    "code": "def color_yellow(text: Any) -> str:\n    return f\"\\033[93m{text}\\033[0m\""
  },
  {
    "type": "function",
    "name": "color_white",
    "class_name": null,
    "file": "node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 850,
    "end_line": 851,
    "code": "def color_white(text: Any) -> str:\n    return f\"\\033[97m{text}\\033[0m\""
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 85,
    "end_line": 104,
    "code": "def __init__(\n        self,\n        repo: Optional[Repository],\n        file_path: str,\n        initial_patch: Optional[str] = None,\n        **data,\n    ):\n        \"\"\"\n        Initializes the ContextFile instance.\n\n        Args:\n            repo (Optional[Repository]): The repository instance, can be None when reconstructing from dict\n            file_path (str): The path to the file within the repository\n            initial_patch (Optional[str]): A Git-formatted patch representing accumulated changes\n            **data: Additional keyword arguments\n        \"\"\"\n        super().__init__(file_path=file_path, **data)\n        self._repo = repo\n        self._initial_patch = initial_patch\n        self._is_new = False if repo is None else not repo.file_exists(file_path)"
  },
  {
    "type": "function",
    "name": "_add_import_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 106,
    "end_line": 114,
    "code": "def _add_import_span(self):\n        # TODO: Initiate module or add this lazily?\n        if self.module:\n            # Always include init spans like 'imports' to context file\n            for child in self.module.children:\n                if (\n                    child.type == CodeBlockType.IMPORT\n                ) and child.belongs_to_span.span_id:\n                    self.add_span(child.belongs_to_span.span_id, pinned=True)"
  },
  {
    "type": "function",
    "name": "get_base_content",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 116,
    "end_line": 148,
    "code": "def get_base_content(self) -> str:\n        \"\"\"\n        Retrieves the base content of the file by applying the initial_patch to the original content.\n\n        Returns:\n            str: The base content of the file.\n\n        Raises:\n            FileNotFoundError: If the file does not exist in the repository.\n            Exception: If applying the initial_patch fails.\n        \"\"\"\n        if not self._repo:\n            return None\n\n        if self._cached_base_content is not None:\n            return self._cached_base_content\n\n        if not self._repo.file_exists(self.file_path):\n            original_content = \"\"\n        else:\n            original_content = self._repo.get_file_content(self.file_path)\n\n        if self._initial_patch:\n            try:\n                self._cached_base_content = self.apply_patch_to_content(\n                    original_content, self._initial_patch\n                )\n            except Exception as e:\n                raise Exception(f\"Failed to apply initial pa..."
  },
  {
    "type": "function",
    "name": "module",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 151,
    "end_line": 162,
    "code": "def module(self) -> Module | None:\n        if not self._repo:\n            return None\n\n        if self._cached_module is not None:\n            return self._cached_module\n\n        parser = get_parser_by_path(self.file_path)\n        if parser:\n            self._cached_module = parser.parse(self.content)\n\n        return self._cached_module"
  },
  {
    "type": "function",
    "name": "content",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 165,
    "end_line": 187,
    "code": "def content(self) -> str:\n        \"\"\"\n        Retrieves the current content of the file by applying the latest patch to the base content.\n\n        Returns:\n            str: The current content of the file.\n        \"\"\"\n        if self._cached_content is not None:\n            return self._cached_content\n\n        base_content = self.get_base_content()\n        if self.patch:\n            try:\n                self._cached_content = self.apply_patch_to_content(\n                    base_content, self.patch\n                )\n            except Exception as e:\n                logger.error(f\"Failed to apply patch: {self.patch}\")\n                raise e\n        else:\n            self._cached_content = base_content\n\n        return self._cached_content"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 189,
    "end_line": 197,
    "code": "def model_dump(self, **kwargs):\n        data = super().model_dump(**kwargs)\n        # Ensure these fields are excluded even if exclude=True is not in kwargs\n        data.pop(\"was_edited\", None)\n        data.pop(\"was_viewed\", None)\n        # Ensure 'patch' is always included, even if it's None\n        if \"patch\" not in data:\n            data[\"patch\"] = None\n        return data"
  },
  {
    "type": "function",
    "name": "span_ids",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 200,
    "end_line": 201,
    "code": "def span_ids(self):\n        return {span.span_id for span in self.spans}"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 203,
    "end_line": 248,
    "code": "def to_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n        show_all_spans: bool = False,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n    ):\n        if self.module:\n            if (\n                not self.show_all_spans\n                and self.span_ids is not None\n                and len(self.span_ids) == 0\n            ):\n                logger.warning(\n                    f\"No span ids provided for {self.file_path}, return empty\"\n                )\n                return \"\"\n\n            code = self._to_prompt(\n                code_block=self.module,\n                show_span_id=show_span_ids,\n                show_line_numbers=show_line_numbers,\n                outcomment_code_comment=outcomment_code_comment,\n                show_outcommented_code=show_outcommented_code,\n                exclude_..."
  },
  {
    "type": "function",
    "name": "_find_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 250,
    "end_line": 258,
    "code": "def _find_span(self, codeblock: CodeBlock) -> Optional[ContextSpan]:\n        if not codeblock.belongs_to_span:\n            return None\n\n        for span in self.spans:\n            if codeblock.belongs_to_span.span_id == span.span_id:\n                return span\n\n        return None"
  },
  {
    "type": "function",
    "name": "_within_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 260,
    "end_line": 268,
    "code": "def _within_span(self, line_no: int) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if (\n                span.start_line\n                and span.end_line\n                and span.start_line <= line_no <= span.end_line\n            ):\n                return span\n        return None"
  },
  {
    "type": "function",
    "name": "_to_prompt_with_line_spans",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 270,
    "end_line": 292,
    "code": "def _to_prompt_with_line_spans(self, show_span_id: bool = False) -> str:\n        content_lines = self.content.split(\"\\n\")\n\n        if not self.span_ids:\n            return self.content\n\n        prompt_content = \"\"\n        outcommented = True\n        for i, line in enumerate(content_lines):\n            line_no = i + 1\n\n            span = self._within_span(line_no)\n            if span:\n                if outcommented and show_span_id:\n                    prompt_content += f\"<span id={span.span_id}>\\n\"\n\n                prompt_content += line + \"\\n\"\n                outcommented = False\n            elif not outcommented:\n                prompt_content += \"... other code\\n\"\n                outcommented = True\n\n        return prompt_content"
  },
  {
    "type": "function",
    "name": "_to_prompt",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 294,
    "end_line": 428,
    "code": "def _to_prompt(\n        self,\n        code_block: CodeBlock,\n        current_span: Optional[CurrentPromptSpan] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        show_line_numbers: bool = False,\n        exclude_comments: bool = False,\n        show_all_spans: bool = False,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n        current_tokens: int = 0,\n    ):\n        if current_span is None:\n            current_span = CurrentPromptSpan()\n\n        contents = \"\"\n        if not code_block.children:\n            return contents\n\n        outcommented_block = None\n        for _i, child in enumerate(code_block.children):\n            if exclude_comments and child.type.group == CodeBlockTypeGroup.COMMENT:\n                continue\n\n            # Check if adding this block would exceed max_tokens\n            if max_tokens:\n                if current_tokens + child.tokens > ma..."
  },
  {
    "type": "function",
    "name": "set_patch",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 430,
    "end_line": 433,
    "code": "def set_patch(self, patch: str):\n        self.patch = patch\n        self._cached_content = None\n        self._cached_module = None"
  },
  {
    "type": "function",
    "name": "context_size",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 436,
    "end_line": 448,
    "code": "def context_size(self):\n        if self.module:\n            if self.span_ids is None:\n                return self.module.sum_tokens()\n            else:\n                tokens = 0\n                for span_id in self.span_ids:\n                    span = self.module.find_span_by_id(span_id)\n                    if span:\n                        tokens += span.tokens\n                return tokens\n        else:\n            return 0"
  },
  {
    "type": "function",
    "name": "has_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 450,
    "end_line": 451,
    "code": "def has_span(self, span_id: str):\n        return span_id in self.span_ids"
  },
  {
    "type": "function",
    "name": "add_spans",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 453,
    "end_line": 461,
    "code": "def add_spans(\n        self,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ):\n        for span_id in span_ids:\n            self.add_span(span_id, tokens=tokens, pinned=pinned, add_extra=add_extra)"
  },
  {
    "type": "function",
    "name": "add_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 463,
    "end_line": 500,
    "code": "def add_span(\n        self,\n        span_id: str,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ) -> bool:\n        self.was_viewed = True\n        existing_span = next(\n            (span for span in self.spans if span.span_id == span_id), None\n        )\n\n        if existing_span:\n            existing_span.tokens = tokens\n            existing_span.pinned = pinned\n            return False\n        else:\n            span = self.module.find_span_by_id(span_id)\n            if span:\n                self.spans.append(\n                    ContextSpan(\n                        span_id=span_id,\n                        start_line=start_line,\n                        end_line=start_line,\n                        tokens=tokens,\n                        pinned=pinned,\n                    )\n                )\n                if add_extra:\n                    self._add_c..."
  },
  {
    "type": "function",
    "name": "_add_class_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 502,
    "end_line": 528,
    "code": "def _add_class_span(self, span: BlockSpan):\n        if span.initiating_block.type != CodeBlockType.CLASS:\n            class_block = span.initiating_block.find_type_in_parents(\n                CodeBlockType.CLASS\n            )\n        elif span.initiating_block.type == CodeBlockType.CLASS:\n            class_block = span.initiating_block\n        else:\n            return\n\n        if not class_block or self.has_span(class_block.belongs_to_span.span_id):\n            return\n\n        # Always add init spans like constructors to context\n        for child in class_block.children:\n            if (\n                child.belongs_to_span.span_type == SpanType.INITATION\n                and child.belongs_to_span.span_id\n                and not self.has_span(child.belongs_to_span.span_id)\n            ):\n                if child.belongs_to_span.span_id not in self.span_ids:\n                    self.spans.append(\n                        ContextSpan(span_id=child.belongs_to_span.span_id)\n                ..."
  },
  {
    "type": "function",
    "name": "add_line_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 530,
    "end_line": 558,
    "code": "def add_line_span(\n        self, start_line: int, end_line: int | None = None, add_extra: bool = True\n    ) -> list[str]:\n        self.was_viewed = True\n\n        if not self.module:\n            logger.warning(f\"Could not find module for file {self.file_path}\")\n            return []\n\n        logger.debug(f\"Adding line span {start_line} - {end_line} to {self.file_path}\")\n        blocks = self.module.find_blocks_by_line_numbers(\n            start_line, end_line, include_parents=True\n        )\n\n        added_spans = []\n        for block in blocks:\n            if (\n                block.belongs_to_span\n                and block.belongs_to_span.span_id not in self.span_ids\n            ):\n                added_spans.append(block.belongs_to_span.span_id)\n                self.add_span(\n                    block.belongs_to_span.span_id,\n                    start_line=start_line,\n                    end_line=end_line,\n                    add_extra=add_extra,\n                )\n\n        return adde..."
  },
  {
    "type": "function",
    "name": "lines_is_in_context",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 560,
    "end_line": 591,
    "code": "def lines_is_in_context(self, start_line: int, end_line: int) -> bool:\n        \"\"\"\n        Check if the given line range's start and end points are covered by spans in the context.\n        A single span can cover both points, or different spans can cover each point.\n\n        Args:\n            start_line (int): Start line number\n            end_line (int): End line number\n\n        Returns:\n            bool: True if both start and end lines are covered by spans in context, False otherwise\n        \"\"\"\n        if self.show_all_spans:\n            return True\n\n        if not self.module:\n            return False\n\n        start_covered = False\n        end_covered = False\n\n        for span in self.spans:\n            block_span = self.module.find_span_by_id(span.span_id)\n            if block_span:\n                if block_span.start_line <= start_line <= block_span.end_line:\n                    start_covered = True\n                if block_span.start_line <= end_line <= block_span.end_line:\n   ..."
  },
  {
    "type": "function",
    "name": "remove_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 593,
    "end_line": 594,
    "code": "def remove_span(self, span_id: str):\n        self.spans = [span for span in self.spans if span.span_id != span_id]"
  },
  {
    "type": "function",
    "name": "remove_all_spans",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 596,
    "end_line": 597,
    "code": "def remove_all_spans(self):\n        self.spans = [span for span in self.spans if span.pinned]"
  },
  {
    "type": "function",
    "name": "get_spans",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 599,
    "end_line": 608,
    "code": "def get_spans(self) -> List[BlockSpan]:\n        block_spans = []\n        for span in self.spans:\n            if not self.module:\n                continue\n\n            block_span = self.module.find_span_by_id(span.span_id)\n            if block_span:\n                block_spans.append(block_span)\n        return block_spans"
  },
  {
    "type": "function",
    "name": "get_block_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 610,
    "end_line": 622,
    "code": "def get_block_span(self, span_id: str) -> Optional[BlockSpan]:\n        if not self.module:\n            return None\n        for span in self.spans:\n            if span.span_id == span_id:\n                block_span = self.module.find_span_by_id(span_id)\n                if block_span:\n                    return block_span\n                else:\n                    logger.warning(\n                        f\"Could not find span with id {span_id} in file {self.file_path}\"\n                    )\n        return None"
  },
  {
    "type": "function",
    "name": "get_span",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 624,
    "end_line": 628,
    "code": "def get_span(self, span_id: str) -> Optional[ContextSpan]:\n        for span in self.spans:\n            if span.span_id == span_id:\n                return span\n        return None"
  },
  {
    "type": "function",
    "name": "get_patches",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 630,
    "end_line": 634,
    "code": "def get_patches(self) -> List[str]:\n        \"\"\"\n        Get all patches associated with this ContextFile.\n        \"\"\"\n        return self.patches"
  },
  {
    "type": "function",
    "name": "is_new",
    "class_name": "ContextFile",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 637,
    "end_line": 644,
    "code": "def is_new(self) -> bool:\n        \"\"\"\n        Returns whether this file is newly created in the context.\n\n        Returns:\n            bool: True if the file is new, False otherwise\n        \"\"\"\n        return self._is_new"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 659,
    "end_line": 677,
    "code": "def __init__(\n        self,\n        repo: Repository | None,\n        # runtime: RuntimeEnvironment | None = None,\n        **data,\n    ):\n        super().__init__(**data)\n\n        self._repo = repo\n        # self._runtime = runtime\n\n        if \"_files\" not in self.__dict__:\n            self.__dict__[\"_files\"] = {}\n\n        if \"_test_files\" not in self.__dict__:\n            self.__dict__[\"_test_files\"] = {}\n\n        if \"_max_tokens\" not in self.__dict__:\n            self.__dict__[\"_max_tokens\"] = data.get(\"max_tokens\", 8000)"
  },
  {
    "type": "function",
    "name": "from_dir",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 680,
    "end_line": 685,
    "code": "def from_dir(cls, repo_dir: str, max_tokens: int = 8000):\n        from moatless_qa.repository.file import FileRepository\n\n        repo = FileRepository(repo_path=repo_dir)\n        instance = cls(max_tokens=max_tokens, repo=repo)\n        return instance"
  },
  {
    "type": "function",
    "name": "from_json",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 688,
    "end_line": 698,
    "code": "def from_json(cls, repo_dir: str, json_data: str):\n        \"\"\"\n        Create a FileContext instance from JSON data.\n\n        :param repo_dir: The repository directory path.\n        :param json_data: A JSON string representing the FileContext data.\n        :return: A new FileContext instance.\n        \"\"\"\n        json_data = json_data.strip(\"```json\\n\").strip(\"\\n```\")\n        data = json.loads(json_data)\n        return cls.from_dict(data, repo_dir=repo_dir)"
  },
  {
    "type": "function",
    "name": "from_dict",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 701,
    "end_line": 716,
    "code": "def from_dict(\n        cls,\n        data: Dict,\n        repo_dir: str | None = None,\n        repo: Repository | None = None,\n        # runtime: RuntimeEnvironment | None = None,\n    ):\n        if not repo and repo_dir:\n            repo = FileRepository(repo_path=repo_dir)\n        instance = cls(\n            max_tokens=data.get(\"max_tokens\", 8000), repo=repo\n        )\n        instance.load_files_from_dict(\n            data.get(\"files\", []), test_files=data.get(\"test_files\", [])\n        )\n        return instance"
  },
  {
    "type": "function",
    "name": "load_files_from_dict",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 718,
    "end_line": 740,
    "code": "def load_files_from_dict(\n        self, files: list[dict]\n    ):\n        \"\"\"\n        Loads files and test files from a dictionary representation.\n\n        Args:\n            files (list[dict]): List of file data dictionaries\n            test_files (list[dict] | None): List of test file data dictionaries\n        \"\"\"\n        # Load regular files\n        for file_data in files:\n            file_path = file_data[\"file_path\"]\n            show_all_spans = file_data.get(\"show_all_spans\", False)\n            spans = [ContextSpan(**span) for span in file_data.get(\"spans\", [])]\n\n            self._files[file_path] = ContextFile(\n                file_path=file_path,\n                spans=spans,\n                show_all_spans=show_all_spans,\n                patch=file_data.get(\"patch\"),\n                repo=self._repo,\n            )"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 742,
    "end_line": 754,
    "code": "def model_dump(self, **kwargs):\n        \"\"\"\n        Dumps the model to a dictionary, including files and test files.\n        \"\"\"\n        if \"exclude_none\" not in kwargs:\n            kwargs[\"exclude_none\"] = True\n\n        files = [file.model_dump(**kwargs) for file in self._files.values()]\n\n        return {\n            \"max_tokens\": self.__dict__[\"_max_tokens\"],\n            \"files\": files,\n        }"
  },
  {
    "type": "function",
    "name": "snapshot",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 756,
    "end_line": 759,
    "code": "def snapshot(self):\n        dict = self.model_dump()\n        del dict[\"max_tokens\"]\n        return dict"
  },
  {
    "type": "function",
    "name": "restore_from_snapshot",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 761,
    "end_line": 764,
    "code": "def restore_from_snapshot(self, snapshot: dict):\n        self._files.clear()\n        self._test_files.clear()\n        self.load_files_from_dict(snapshot.get(\"files\", []))"
  },
  {
    "type": "function",
    "name": "to_files_with_spans",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 766,
    "end_line": 770,
    "code": "def to_files_with_spans(self) -> List[FileWithSpans]:\n        return [\n            FileWithSpans(file_path=file_path, span_ids=list(file.span_ids))\n            for file_path, file in self._files.items()\n        ]"
  },
  {
    "type": "function",
    "name": "add_files_with_spans",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 772,
    "end_line": 776,
    "code": "def add_files_with_spans(self, files_with_spans: List[FileWithSpans]):\n        for file_with_spans in files_with_spans:\n            self.add_spans_to_context(\n                file_with_spans.file_path, set(file_with_spans.span_ids)\n            )"
  },
  {
    "type": "function",
    "name": "add_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 778,
    "end_line": 791,
    "code": "def add_file(\n        self, file_path: str, show_all_spans: bool = False, add_extra: bool = True\n    ) -> ContextFile:\n        if file_path not in self._files:\n            self._files[file_path] = ContextFile(\n                file_path=file_path,\n                spans=[],\n                show_all_spans=show_all_spans,\n                repo=self._repo,\n            )\n            if add_extra:\n                self._files[file_path]._add_import_span()\n\n        return self._files[file_path]"
  },
  {
    "type": "function",
    "name": "add_file_with_lines",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 793,
    "end_line": 800,
    "code": "def add_file_with_lines(\n        self, file_path: str, start_line: int, end_line: Optional[int] = None\n    ):\n        end_line = end_line or start_line\n        if file_path not in self._files:\n            self.add_file(file_path)\n\n        self._files[file_path].add_line_span(start_line, end_line)"
  },
  {
    "type": "function",
    "name": "remove_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 802,
    "end_line": 804,
    "code": "def remove_file(self, file_path: str):\n        if file_path in self._files:\n            del self._files[file_path]"
  },
  {
    "type": "function",
    "name": "exists",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 806,
    "end_line": 807,
    "code": "def exists(self, file_path: str):\n        return file_path in self._files"
  },
  {
    "type": "function",
    "name": "has_runtime",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 810,
    "end_line": 811,
    "code": "def has_runtime(self):\n        return bool(self._runtime)"
  },
  {
    "type": "function",
    "name": "files",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 814,
    "end_line": 815,
    "code": "def files(self):\n        return list(self._files.values())"
  },
  {
    "type": "function",
    "name": "test_files",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 818,
    "end_line": 819,
    "code": "def test_files(self):\n        return list(self._test_files.values())"
  },
  {
    "type": "function",
    "name": "add_spans_to_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 821,
    "end_line": 837,
    "code": "def add_spans_to_context(\n        self,\n        file_path: str,\n        span_ids: Set[str],\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ):\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            context_file.add_spans(span_ids, tokens, pinned=pinned, add_extra=add_extra)\n        else:\n            logger.warning(f\"Could not find file {file_path} in the repository\")"
  },
  {
    "type": "function",
    "name": "add_span_to_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 839,
    "end_line": 858,
    "code": "def add_span_to_context(\n        self,\n        file_path: str,\n        span_id: str,\n        tokens: Optional[int] = None,\n        pinned: bool = False,\n        add_extra: bool = True,\n    ) -> bool:\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            return context_file.add_span(\n                span_id, tokens=tokens, pinned=pinned, add_extra=add_extra\n            )\n        else:\n            logger.warning(f\"Could not find file {file_path} in the repository\")\n            return False"
  },
  {
    "type": "function",
    "name": "add_line_span_to_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 860,
    "end_line": 876,
    "code": "def add_line_span_to_context(\n        self,\n        file_path: str,\n        start_line: int,\n        end_line: int | None = None,\n        add_extra: bool = True,\n    ) -> List[str]:\n        if not self.has_file(file_path):\n            context_file = self.add_file(file_path, add_extra=add_extra)\n        else:\n            context_file = self.get_context_file(file_path)\n\n        if context_file:\n            return context_file.add_line_span(start_line, end_line, add_extra=add_extra)\n        else:\n            logger.warning(f\"Could not find file {file_path} in the repository\")\n            return []"
  },
  {
    "type": "function",
    "name": "remove_span_from_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 878,
    "end_line": 886,
    "code": "def remove_span_from_context(\n        self, file_path: str, span_id: str, remove_file: bool = False\n    ):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            context_file.remove_span(span_id)\n\n            if not context_file.spans and remove_file:\n                self.remove_file(file_path)"
  },
  {
    "type": "function",
    "name": "remove_spans_from_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 888,
    "end_line": 892,
    "code": "def remove_spans_from_context(\n        self, file_path: str, span_ids: List[str], remove_file: bool = False\n    ):\n        for span_id in span_ids:\n            self.remove_span_from_context(file_path, span_id, remove_file)"
  },
  {
    "type": "function",
    "name": "get_spans",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 894,
    "end_line": 898,
    "code": "def get_spans(self, file_path: str) -> List[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_spans()\n        return []"
  },
  {
    "type": "function",
    "name": "get_span",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 900,
    "end_line": 904,
    "code": "def get_span(self, file_path: str, span_id: str) -> Optional[BlockSpan]:\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return context_file.get_block_span(span_id)\n        return None"
  },
  {
    "type": "function",
    "name": "has_span",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 906,
    "end_line": 910,
    "code": "def has_span(self, file_path: str, span_id: str):\n        context_file = self.get_context_file(file_path)\n        if context_file:\n            return span_id in context_file.span_ids\n        return False"
  },
  {
    "type": "function",
    "name": "apply",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 912,
    "end_line": 926,
    "code": "def apply(self, file_context: \"FileContext\"):\n        \"\"\"\n        Apply a list of FileContext instances, collecting their ContextFiles.\n        \"\"\"\n        for context_file in file_context.files:\n            file_path = context_file.file_path\n            if file_path not in self.files:\n                self._files[file_path] = ContextFile(\n                    file_path=file_path,\n                    repo=self.repo,\n                    initial_patch=file_context.generate_full_patch(),\n                )\n\n            self._files[file_path].spans.extend(context_file.spans)\n            self._files[file_path].show_all_spans = context_file.show_all_spans"
  },
  {
    "type": "function",
    "name": "has_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 928,
    "end_line": 931,
    "code": "def has_file(self, file_path: str):\n        return file_path in self._files and (\n            self._files[file_path].spans or self._files[file_path].show_all_spans\n        )"
  },
  {
    "type": "function",
    "name": "get_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 933,
    "end_line": 934,
    "code": "def get_file(self, file_path: str) -> Optional[ContextFile]:\n        return self.get_context_file(file_path)"
  },
  {
    "type": "function",
    "name": "file_exists",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 936,
    "end_line": 938,
    "code": "def file_exists(self, file_path: str):\n        context_file = self._files.get(file_path)\n        return context_file or self._repo.file_exists(file_path)"
  },
  {
    "type": "function",
    "name": "is_directory",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 940,
    "end_line": 941,
    "code": "def is_directory(self, file_path: str):\n        return self._repo.is_directory(file_path)"
  },
  {
    "type": "function",
    "name": "get_context_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 943,
    "end_line": 963,
    "code": "def get_context_file(\n        self, file_path: str, add_extra: bool = False\n    ) -> Optional[ContextFile]:\n        if self._repo and hasattr(self._repo, \"get_relative_path\"):\n            file_path = self._repo.get_relative_path(file_path)\n\n        context_file = self._files.get(file_path)\n\n        if not context_file:\n            if not self._repo.file_exists(file_path):\n                logger.info(f\"get_context_file({file_path}) File not found\")\n                return None\n\n            if self._repo.is_directory(file_path):\n                logger.info(f\"get_context_file({file_path}) File is a directory\")\n                return None\n\n            self.add_file(file_path, add_extra=add_extra)\n            context_file = self._files[file_path]\n\n        return context_file"
  },
  {
    "type": "function",
    "name": "get_context_files",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 965,
    "end_line": 968,
    "code": "def get_context_files(self) -> List[ContextFile]:\n        file_paths = list(self._files.keys())\n        for file_path in file_paths:\n            yield self.get_context_file(file_path)"
  },
  {
    "type": "function",
    "name": "context_size",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 970,
    "end_line": 983,
    "code": "def context_size(self):\n        if self._repo:\n            content = self.create_prompt(\n                show_span_ids=False,\n                show_line_numbers=True,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"...\",\n                only_signatures=False,\n            )\n            return count_tokens(content)\n\n        # TODO: This doesnt give accure results. Will count tokens in the generated prompt instead\n        # sum(file.context_size() for file in self._files.values())\n        return 0"
  },
  {
    "type": "function",
    "name": "available_context_size",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 985,
    "end_line": 986,
    "code": "def available_context_size(self):\n        return self._max_tokens - self.context_size()"
  },
  {
    "type": "function",
    "name": "save_file",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 988,
    "end_line": 989,
    "code": "def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        self._repo.save_file(file_path, updated_content)"
  },
  {
    "type": "function",
    "name": "reset",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 991,
    "end_line": 993,
    "code": "def reset(self):\n        self._files = {}\n        self._test_files = {}"
  },
  {
    "type": "function",
    "name": "is_empty",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 995,
    "end_line": 996,
    "code": "def is_empty(self):\n        return not self._files"
  },
  {
    "type": "function",
    "name": "strip_line_breaks_only",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 998,
    "end_line": 999,
    "code": "def strip_line_breaks_only(self, text):\n        return text.lstrip(\"\\n\\r\").rstrip(\"\\n\\r\")"
  },
  {
    "type": "function",
    "name": "create_prompt",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 1001,
    "end_line": 1039,
    "code": "def create_prompt(\n        self,\n        show_span_ids=False,\n        show_line_numbers=False,\n        exclude_comments=False,\n        show_outcommented_code=False,\n        outcomment_code_comment: str = \"...\",\n        files: set | None = None,\n        only_signatures: bool = False,\n        max_tokens: Optional[int] = None,\n    ):\n        file_contexts = []\n        current_tokens = 0\n\n        for context_file in self.get_context_files():\n            if not files or context_file.file_path in files:\n                content = context_file.to_prompt(\n                    show_span_ids,\n                    show_line_numbers,\n                    exclude_comments,\n                    show_outcommented_code,\n                    outcomment_code_comment,\n                    only_signatures=only_signatures,\n                    max_tokens=max_tokens,\n                )\n\n                if max_tokens:\n                    content_tokens = count_tokens(content)\n                    if current_tokens + c..."
  },
  {
    "type": "function",
    "name": "create_summary",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 1041,
    "end_line": 1088,
    "code": "def create_summary(self) -> str:\n        \"\"\"\n        Creates a summary of the files and spans in the context.\n\n        Returns:\n            str: A formatted summary string listing files and their spans\n        \"\"\"\n        if self.is_empty():\n            return \"No files in context\"\n\n        summary = []\n        for context_file in self.get_context_files():\n            # Get file stats\n            tokens = context_file.context_size()\n\n            # Get patch stats if available\n            patch_stats = \"\"\n            if context_file.patch:\n                patch_lines = context_file.patch.split(\"\\n\")\n                additions = sum(\n                    1\n                    for line in patch_lines\n                    if line.startswith(\"+\") and not line.startswith(\"+++\")\n                )\n                deletions = sum(\n                    1\n                    for line in patch_lines\n                    if line.startswith(\"-\") and not line.startswith(\"---\")\n                )\n          ..."
  },
  {
    "type": "function",
    "name": "add_file_context",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 1090,
    "end_line": 1121,
    "code": "def add_file_context(self, other_context: \"FileContext\") -> List[str]:\n        \"\"\"\n        Adds spans from another FileContext to the current one and returns newly added span IDs.\n\n        Args:\n            other_context: The FileContext to merge into this one\n\n        Returns:\n            List[str]: List of newly added span IDs\n        \"\"\"\n        new_span_ids = []\n\n        for other_file in other_context.files:\n            file_path = other_file.file_path\n\n            if not self.has_file(file_path):\n                # Create new file if it doesn't exist\n                context_file = self.add_file(file_path)\n            else:\n                context_file = self.get_context_file(file_path)\n\n            # Add spans that don't already exist\n            for span in other_file.spans:\n                if context_file.add_span(span.span_id):\n                    new_span_ids.append(span.span_id)\n\n            # Copy show_all_spans flag if either context has it enabled\n            context_file...."
  },
  {
    "type": "function",
    "name": "clone",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 1122,
    "end_line": 1130,
    "code": "def clone(self):\n        dump = self.model_dump(\n            exclude={\"files\": {\"__all__\": {\"was_edited\", \"was_viewed\"}}}\n        )\n        cloned_context = FileContext(repo=self._repo)\n        cloned_context.load_files_from_dict(\n            files=dump.get(\"files\", [])\n        )\n        return cloned_context"
  },
  {
    "type": "function",
    "name": "span_count",
    "class_name": "FileContext",
    "file": "file_context.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 1131,
    "end_line": 1141,
    "code": "def span_count(self) -> int:\n        \"\"\"\n        Returns the total number of span IDs across all files in the context.\n\n        Returns:\n            int: Total number of span IDs\n        \"\"\"\n        span_ids = []\n        for file in self._files.values():\n            span_ids.extend(file.span_ids)\n        return len(span_ids)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "MoatlessSolve",
    "file": "moatless_solve.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 23,
    "end_line": 57,
    "code": "def __init__(self, repo_name:str, repo_path: str):\n        # Global variables are used here as defined above the class:\n        # instance, repo_base_dir, index_store_dir, instance_path, persist_path\n    \n        completion_model = CompletionModel(model=\"deepseek/deepseek-chat\", temperature=0.7)\n        completion_model.response_format = LLMResponseFormat.TOOLS\n        repository = create_repository(instance, repo_base_dir=repo_base_dir)\n\n        code_index = CodeIndex.from_index_name(\n            instance[\"instance_id\"], index_store_dir=index_store_dir, file_repo=repository\n        )\n        file_context = FileContext(repo=repository)\n        selector = BestFirstSelector()\n        value_function = ValueFunction(completion_model=completion_model)\n        actions = [\n            FindClass(completion_model=completion_model, code_index=code_index, repository=repository),\n            FindFunction(completion_model=completion_model, code_index=code_index, repository=repository),\n            ..."
  },
  {
    "type": "function",
    "name": "moatless_solve",
    "class_name": "MoatlessSolve",
    "file": "moatless_solve.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 59,
    "end_line": 69,
    "code": "def moatless_solve(self, question: str):\n        search_tree = CodeQASearchTree.create(\n            message=question, \n            **self.search_args,\n            max_iterations=100,\n            max_expansions=3,\n            max_depth=25,\n            persist_path=self.persist_path\n        )\n        res_node = search_tree.run_search()\n        return res_node.observation.message if res_node else None"
  },
  {
    "type": "function",
    "name": "_missing_",
    "class_name": "MessageHistoryType",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 17,
    "end_line": 22,
    "code": "def _missing_(cls, value: str):\n        \"\"\"Handle case-insensitive enum lookup\"\"\"\n        for member in cls:\n            if member.value.lower() == value.lower():\n                return member\n        return None"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "MessageHistoryType",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 24,
    "end_line": 25,
    "code": "def __str__(self):\n        return self.value"
  },
  {
    "type": "function",
    "name": "json",
    "class_name": "MessageHistoryType",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 27,
    "end_line": 29,
    "code": "def json(self):\n        \"\"\"Custom JSON serialization\"\"\"\n        return self.value"
  },
  {
    "type": "function",
    "name": "add_span_id",
    "class_name": "FileWithSpans",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 41,
    "end_line": 43,
    "code": "def add_span_id(self, span_id):\n        if span_id not in self.span_ids:\n            self.span_ids.append(span_id)"
  },
  {
    "type": "function",
    "name": "add_span_ids",
    "class_name": "FileWithSpans",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 45,
    "end_line": 47,
    "code": "def add_span_ids(self, span_ids: list[str]):\n        for span_id in span_ids:\n            self.add_span_id(span_id)"
  },
  {
    "type": "function",
    "name": "__eq__",
    "class_name": "FileWithSpans",
    "file": "schema.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa",
    "start_line": 49,
    "end_line": 50,
    "code": "def __eq__(self, other: \"FileWithSpans\"):\n        return self.file_path == other.file_path and self.span_ids == other.span_ids"
  },
  {
    "type": "function",
    "name": "create",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 71,
    "end_line": 115,
    "code": "def create(\n        cls,\n        message: Optional[str] = None,\n        root: Optional[Node] = None,\n        file_context: Optional[FileContext] = None,\n        repository: Repository | None = None,\n        expander: Expander | None = None,\n        selector: Optional[Selector] = None,\n        agent: Optional[ActionAgent] = None,\n        value_function: Optional[ValueFunction] = None,\n        feedback_generator: Optional[FeedbackGenerator] = None,\n        persist_path: Optional[str] = None,\n        max_expansions: int = 1,\n        max_iterations: int = 10,\n        max_depth: int = 10,\n    ) -> \"CodeQASearchTree\":\n        if not root and not message:\n            raise ValueError(\"Either a root node or a message must be provided.\")\n\n        if not file_context:\n            file_context = FileContext(repo=repository)\n\n        if not root:\n            root = Node(\n                node_id=0,\n                max_expansions=max_expansions,\n                user_message=message,\n                ..."
  },
  {
    "type": "function",
    "name": "run_search",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 118,
    "end_line": 150,
    "code": "def run_search(self) -> Node | None:\n        \"\"\"Run the MCTS algorithm for a specified number of iterations.\"\"\"\n        # if len(self.root.get_all_nodes()) > 1:\n        #     self.log(\n        #         logger.info,\n        #         f\"Restarting search tree with {len(self.root.get_all_nodes())} nodes\",\n        #     )\n\n        while not self.is_finished():\n            node = self._select(self.root)\n\n            if node:\n                new_node = self._expand(node)\n                self._simulate(new_node)\n                self._backpropagate(new_node)\n                # self.maybe_persist()\n                # 如果生成的节点的action是Finish就跳出来，只完成一次trajectory\n                if new_node.is_terminal():\n                    break\n            else:\n                print(\"Search complete: no more nodes to expand.\")\n                break\n\n        if not len(self.get_finished_nodes()):\n            print(\n                f\"Search completed with no finished nodes. {len(self.root.get_all_nodes())} nodes cr..."
  },
  {
    "type": "function",
    "name": "_select",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 153,
    "end_line": 189,
    "code": "def _select(self, node: Node) -> Optional[Node]:\n        \"\"\"Select a node for expansion using the UCT algorithm.\"\"\"\n        expandable_nodes = node.get_expandable_descendants()\n\n        if not expandable_nodes:\n            print(\"No expandable nodes found.\")\n            return None\n\n        #         if expandable_nodes and self.finish_before_reexpanding:\n        #     # Sort by node_id to get the most recently created node\n        #     latest_node = max(expandable_nodes, key=lambda n: n.node_id)\n\n        #     # Check if any node in the tree has reached a finished state\n        #     all_nodes = node.get_all_nodes()\n        #     has_finished_node = any(n.is_finished() for n in all_nodes)\n\n        #     # Check if any node has exceeded the depth limit\n        #     max_depth_exceeded = (\n        #         any(\n        #             n.get_depth() >= self.finish_before_reexpanding_depth\n        #             for n in all_nodes\n        #         )\n        #         if self.finish_before..."
  },
  {
    "type": "function",
    "name": "_expand",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 192,
    "end_line": 217,
    "code": "def _expand(self, node: Node, force_expansion: bool = False) -> Node:\n        \"\"\"Expand the node and return a child node.\"\"\"\n\n        # Check if any action step was not executed, if so return the node\n        if node.action_steps and node.has_unexecuted_actions():\n            print(\n                f\"Returning Node{node.node_id} with unexecuted actions\"\n            )\n            return node\n\n        child_node = self.expander.expand(node, self, force_expansion)\n\n        if not node.action_steps and node.assistant_message:\n            child_node.user_message = \"You're an autonomous AI agent that must respond with one of the provided functions\"\n\n        # Only add feedback if this is the second expansion from this node\n        if self.feedback_generator and len(node.children) >= 2:\n            child_node.feedback_data = self.feedback_generator.generate_feedback(\n                child_node,\n                self.agent.actions,\n            )\n\n        print(\n            f\"Expanded Node{node...."
  },
  {
    "type": "function",
    "name": "_simulate",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 220,
    "end_line": 247,
    "code": "def _simulate(self, node: Node, experience=None):\n        \"\"\"Simulate a playout by executing the action and evaluating the result.\"\"\"\n\n        if node.observation:\n            print(f\"Node{node.node_id}: Action already executed. Skipping.\")\n        else:\n            self.agent.run(node, experience)\n\n        if self.value_function and not node.is_duplicate and node.observation:\n            try:\n                node.reward, completion_response = self.value_function.get_reward(\n                    node=node\n                )\n                node.completions[\"value_function\"] = completion_response\n\n                print(\n                    f\"Node{node.node_id}: The value function returned a reward of {node.reward.value}.\",\n                )\n            except RejectError as e:\n                print(\n                    f\"Node{node.node_id}: Value function rejected: {e.message}\",\n                )\n                node.reward = None\n            except RuntimeError as e:\n                prin..."
  },
  {
    "type": "function",
    "name": "_backpropagate",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 250,
    "end_line": 266,
    "code": "def _backpropagate(self, node: Node):\n        \"\"\"Backpropagate the reward up the tree.\"\"\"\n    \n        if not node.reward:\n            print(\n                f\"Node{node.node_id} has no evaluation. Skipping backpropagation.\",\n            )\n            return\n    \n        reward = node.reward.value\n        while node is not None:\n            node.visits += 1\n            if not node.value:\n                node.value = reward\n            else:\n                node.value += reward\n            node = node.parent"
  },
  {
    "type": "function",
    "name": "get_finished_nodes",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 269,
    "end_line": 279,
    "code": "def get_finished_nodes(self) -> List[Node]:\n        \"\"\"Get all finished nodes in the search tree by uniqe parent node.\"\"\"\n        parent_ids = set()\n        finished_nodes = []\n        for node in self.root.get_all_nodes():\n            # TODO: Pick finished node with highest/avg/lowest reward?\n            if node.is_finished() and node.parent.node_id not in parent_ids:\n                parent_ids.add(node.parent.node_id)\n                finished_nodes.append(node)\n\n        return finished_nodes"
  },
  {
    "type": "function",
    "name": "is_finished",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 282,
    "end_line": 302,
    "code": "def is_finished(self):\n        \n        # Check max iterations\n        if len(self.root.get_all_nodes()) >= self.max_iterations:\n            print(\n                f\"Search finished: Reached max iterations {self.max_iterations}\"\n            )\n            return True\n\n        finished_nodes = self.get_finished_nodes()\n        unique_finished_parents = set()\n        for node in finished_nodes:\n            unique_finished_parents.add(node.parent.node_id)\n\n        # Check if there are no more expandable nodes\n        expandable_nodes = self.root.get_expandable_descendants()\n        if not expandable_nodes:\n            print(\"Search finished: No more expandable nodes\")\n            return True\n\n        return False"
  },
  {
    "type": "function",
    "name": "get_leaf_nodes",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 305,
    "end_line": 307,
    "code": "def get_leaf_nodes(self) -> List[Node]:\n        \"\"\"Get all leaf nodes in the search tree.\"\"\"\n        return [node for node in self.root.get_all_nodes() if node.is_leaf()]"
  },
  {
    "type": "function",
    "name": "_generate_unique_id",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 310,
    "end_line": 312,
    "code": "def _generate_unique_id(self) -> int:\n        self.unique_id += 1\n        return self.unique_id"
  },
  {
    "type": "function",
    "name": "get_best_trajectory",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 315,
    "end_line": 316,
    "code": "def get_best_trajectory(self) -> Node | None:\n        pass"
  },
  {
    "type": "function",
    "name": "get_all_trajectory",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 319,
    "end_line": 336,
    "code": "def get_all_trajectory(self) -> Node | None:\n        \"\"\"\n        Get all finished trajectory to return\n        \"\"\"\n        nodes = self.get_finished_nodes()\n        if not nodes:\n            nodes = self.get_leaf_nodes()\n            print(\n                f\"get_best_trajectory() No finished nodes found. Will select from {len(nodes)} leaf nodes.\",\n            )\n\n        if len(nodes) == 1:\n            return nodes[0]\n\n        print(\n                \"No discriminator provided. Returning all the finished node.\",\n            )\n        return nodes"
  },
  {
    "type": "function",
    "name": "display_value",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 348,
    "end_line": 352,
    "code": "def display_value(self, node):\n        # 自底向上打印node的value值\n        while node:\n            print(f'The value of Node {node.node_id} is {node.value}')\n            node = node.parent"
  },
  {
    "type": "function",
    "name": "display_uct",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 355,
    "end_line": 360,
    "code": "def display_uct(self, node):\n        # 自底向上打印node的uct值\n        while node:\n            value = self.selector.uct_score(node)\n            print(f'The uct score list of Node {node.node_id} is {value}')\n            node = node.parent"
  },
  {
    "type": "function",
    "name": "persist",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 363,
    "end_line": 380,
    "code": "def persist(self, **kwargs):\n        \"\"\"\n        Persist the entire SearchTree to a file.\n\n        Args:\n            file_path (str): The path to the file where the tree will be saved.\n        \"\"\"\n        tree_data = self.model_dump(**kwargs)\n        os.makedirs(os.path.dirname(self.persist_path), exist_ok=True)\n        \n        with open(self.persist_path, \"w\") as f:\n            try:\n                json.dump(tree_data, f, indent=2)\n            except Exception as e:\n                print(\n                    f\"Error saving search tree to {self.persist_path}: {tree_data}\"\n                )\n                raise e"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "CodeQASearchTree",
    "file": "search_tree.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/code_qa",
    "start_line": 383,
    "end_line": 428,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Generate a dictionary representation of the SearchTree.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the search tree.\n        \"\"\"\n        data = {\n            field: getattr(self, field)\n            for field in self.model_fields\n            if field\n            not in [\n                \"root\",\n                \"selector\",\n                \"repository\",\n                \"agent\",\n                \"value_function\",\n                \"feedback_generator\",\n                # \"discriminator\",\n                \"persist_path\",\n                # \"event_handlers\",\n            ]\n        }\n\n        data.pop(\"persist_path\", None)\n\n        data[\"selector\"] = self.selector.model_dump(**kwargs)\n        data[\"expander\"] = self.expander.model_dump(**kwargs)\n        data[\"agent\"] = self.agent.model_dump(**kwargs)\n        # data[\"agent_settings\"] = (\n        #     self.agent_settings.model_dump(**kwargs) if self..."
  },
  {
    "type": "function",
    "name": "to_prompt_format",
    "class_name": "Artifact",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 26,
    "end_line": 27,
    "code": "def to_prompt_format(self) -> PromptModel:\n        pass"
  },
  {
    "type": "function",
    "name": "load",
    "class_name": "ArtifactHandler",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 50,
    "end_line": 51,
    "code": "def load(self, artifact_id: str) -> T:\n        pass"
  },
  {
    "type": "function",
    "name": "save",
    "class_name": "ArtifactHandler",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 54,
    "end_line": 55,
    "code": "def save(self, artifact: T) -> None:\n        pass"
  },
  {
    "type": "function",
    "name": "update",
    "class_name": "ArtifactHandler",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 58,
    "end_line": 59,
    "code": "def update(self, artifact: T) -> None:\n        pass"
  },
  {
    "type": "function",
    "name": "delete",
    "class_name": "ArtifactHandler",
    "file": "artifact.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 62,
    "end_line": 63,
    "code": "def delete(self, artifact_id: str) -> None:\n        pass"
  },
  {
    "type": "function",
    "name": "to_prompt_format",
    "class_name": "FileArtifact",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 25,
    "end_line": 39,
    "code": "def to_prompt_format(self) -> PromptModel:\n        if self.mime_type is None:\n            self.mime_type = \"text/plain\"\n\n        if self.mime_type.startswith(\"text/\"):\n            # Return TextPromptModel for text content\n            text_str = self.content.decode(\"utf-8\", errors=\"replace\")\n            return TextPromptModel(type=\"text\", text=text_str)\n        else:\n            # Return ImageURLPromptModel for binary content\n            encoded = base64.b64encode(self.content).decode(\"utf-8\")\n            return ImageURLPromptModel(\n                type=\"image_url\",\n                image_url={\"url\": f\"data:{self.mime_type};base64,{encoded}\"},\n            )"
  },
  {
    "type": "function",
    "name": "_detect_mime_type",
    "class_name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 48,
    "end_line": 50,
    "code": "def _detect_mime_type(self, file_path: str) -> str:\n        mime_type, _ = mimetypes.guess_type(file_path)\n        return mime_type or \"application/octet-stream\""
  },
  {
    "type": "function",
    "name": "load",
    "class_name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 52,
    "end_line": 61,
    "code": "def load(self, artifact_id: str) -> FileArtifact:\n        file_path = self.directory_path / artifact_id\n        return FileArtifact(\n            id=artifact_id,\n            type=self.type,\n            name=file_path.name,\n            file_path=str(file_path),\n            mime_type=self._detect_mime_type(str(file_path)),\n            content=file_path.read_bytes() if file_path.exists() else None,\n        )"
  },
  {
    "type": "function",
    "name": "save",
    "class_name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 63,
    "end_line": 67,
    "code": "def save(self, artifact: FileArtifact) -> None:\n        file_path = self.directory_path / artifact.file_path\n        if artifact.content:\n            file_path.parent.mkdir(parents=True, exist_ok=True)\n            file_path.write_bytes(artifact.content)"
  },
  {
    "type": "function",
    "name": "update",
    "class_name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 69,
    "end_line": 70,
    "code": "def update(self, artifact: FileArtifact) -> None:\n        self.save(artifact)"
  },
  {
    "type": "function",
    "name": "delete",
    "class_name": "FileArtifactHandler",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/artifacts",
    "start_line": 72,
    "end_line": 75,
    "code": "def delete(self, artifact_id: str) -> None:\n        file_path = self.directory_path / artifact_id\n        if file_path.exists():\n            file_path.unlink()"
  },
  {
    "type": "function",
    "name": "load_moatless_datasets",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 18,
    "end_line": 25,
    "code": "def load_moatless_datasets(split: str | None):\n    global _moatless_instances\n\n    if split:\n        _load_moatless_dataset(split)\n    else:\n        _load_moatless_dataset(\"lite\")\n        _load_moatless_dataset(\"verified\")"
  },
  {
    "type": "function",
    "name": "_load_moatless_dataset",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 28,
    "end_line": 36,
    "code": "def _load_moatless_dataset(split: str):\n    global _moatless_instances\n\n    file_path = os.path.join(\n        os.path.dirname(__file__), f\"swebench_{split}_all_evaluations.json\"\n    )\n    with open(file_path) as f:\n        dataset = json.load(f)\n        _moatless_instances.update({d[\"instance_id\"]: d for d in dataset})"
  },
  {
    "type": "function",
    "name": "get_moatless_instances",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 39,
    "end_line": 43,
    "code": "def get_moatless_instances(split: str | None = None):\n    global _moatless_instances\n    if not _moatless_instances:\n        load_moatless_datasets(split)\n    return _moatless_instances"
  },
  {
    "type": "function",
    "name": "get_moatless_instance",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 46,
    "end_line": 55,
    "code": "def get_moatless_instance(instance_id: str, split: str | None = None):\n    global _moatless_instances\n    if not _moatless_instances:\n        load_moatless_datasets(split)\n    # instance = _moatless_instances.get(split).get(instance_id)\n    instance = _moatless_instances.get(instance_id)\n    if not instance:\n        raise ValueError(f\"Instance {instance_id} not found.\")\n\n    return instance"
  },
  {
    "type": "function",
    "name": "find_relevant_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 58,
    "end_line": 92,
    "code": "def find_relevant_spans(original_block: Module, updated_block: Module):\n    \"\"\"Find relevant spans in test content. Used for finding the \"perfect\" context in benchmark instances.\"\"\"\n\n    relevant_spans = set()\n\n    for span in updated_block.spans_by_id.values():\n        if span.span_id in relevant_spans:\n            continue\n\n        if original_block.has_span(span.span_id):\n            updated_content = updated_block.to_prompt(\n                span_ids=set(span.span_id), show_outcommented_code=False\n            ).strip()\n            original_content = original_block.to_prompt(\n                span_ids=set(span.span_id), show_outcommented_code=False\n            ).strip()\n            if original_content != updated_content:\n                relevant_spans.add(span.span_id)\n\n            # TODO: Second prio after token count\n            related_span_ids = original_block.find_related_span_ids(span.span_id)\n            relevant_spans.update(related_span_ids)\n        else:\n            parent_b..."
  },
  {
    "type": "function",
    "name": "get_diff_lines",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 95,
    "end_line": 140,
    "code": "def get_diff_lines(diff_input):\n    if not diff_input:\n        return []\n    file_name_re = re.compile(r\"diff --git a/(.+) b/.+\")\n    file_name_no_git_re = re.compile(r\"--- a/(.+)\")\n\n    line_change_re = re.compile(r\"^@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@\")\n\n    changes = []\n\n    current_file = None\n    for line in diff_input.splitlines():\n        file_match = file_name_re.match(line)\n        if file_match:\n            current_file = file_match.group(1)\n            continue\n\n        if not current_file:\n            file_match = file_name_no_git_re.match(line)\n            if file_match:\n                current_file = file_match.group(1)\n\n            continue\n\n        line_change_match = line_change_re.match(line)\n        if line_change_match:\n            old_start, old_length, new_start, new_length = map(\n                int, line_change_match.groups()\n            )\n\n            adjustment_start = max(1, min(3, old_start - 3))\n            adjusted_start = old_start + adjustment_start\n\n      ..."
  },
  {
    "type": "function",
    "name": "compare_patches",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 143,
    "end_line": 171,
    "code": "def compare_patches(expected_patch, actual_patch):\n    expected_diffs = get_diff_lines(expected_patch)\n    actual_diffs = get_diff_lines(actual_patch)\n\n    expected_files = set()\n    file_hits = set()\n    line_hits = 0\n\n    for patch_diff in expected_diffs:\n        change_file, change_start, change_end, change_type = patch_diff\n\n        for actual_diff in actual_diffs:\n            (\n                actual_change_file,\n                actual_change_start,\n                actual_change_end,\n                actual_change_type,\n            ) = actual_diff\n            expected_files.add(change_file)\n            if change_file == actual_change_file:\n                file_hits.add(change_file)\n                if (\n                    change_start >= actual_change_start\n                    and change_end <= actual_change_end\n                ):\n                    line_hits += 1\n                    continue\n\n    return len(expected_files) - len(file_hits), len(expected_diffs) - line_hits"
  },
  {
    "type": "function",
    "name": "create_file_spans_from_patch",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 174,
    "end_line": 184,
    "code": "def create_file_spans_from_patch(repo_dir: str, patch: str) -> list[FileWithSpans]:\n    repository = FileRepository(repo_dir)\n    files_with_spans = []\n    for file_path, span_ids in get_file_spans_from_patch(repository, patch).items():\n        file_with_spans = FileWithSpans(\n            file_path=file_path,\n            span_ids=span_ids,\n        )\n        files_with_spans.append(file_with_spans)\n\n    return files_with_spans"
  },
  {
    "type": "function",
    "name": "get_file_spans_from_patch",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 187,
    "end_line": 206,
    "code": "def get_file_spans_from_patch(\n    repository: FileRepository, patch: str\n) -> dict[str, list[str]]:\n    expected_diff_lines = get_diff_lines(patch)\n    expected_files_with_spans = {}\n\n    for diff_line in expected_diff_lines:\n        change_file, change_start, change_end, change_type = diff_line\n        file = repository.get_file(change_file)\n\n        if file is None or file.module is None:\n            continue\n\n        if file.file_path not in expected_files_with_spans:\n            expected_files_with_spans[file.file_path] = []\n        spans = file.module.find_spans_by_line_numbers(change_start, change_end)\n        for span in spans:\n            if span.span_id not in expected_files_with_spans[file.file_path]:\n                expected_files_with_spans[file.file_path].append(span.span_id)\n    return expected_files_with_spans"
  },
  {
    "type": "function",
    "name": "get_files_from_patch",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 209,
    "end_line": 211,
    "code": "def get_files_from_patch(patch: str) -> list[str]:\n    diff_lines = get_diff_lines(patch)\n    return [diff_line[0] for diff_line in diff_lines]"
  },
  {
    "type": "function",
    "name": "file_spans_to_dict",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 214,
    "end_line": 226,
    "code": "def file_spans_to_dict(files_with_spans: list[FileWithSpans]) -> dict[str, list[str]]:\n    span_dict = {}\n    if not files_with_spans:\n        return span_dict\n\n    for file_with_spans in files_with_spans:\n        if file_with_spans.file_path not in span_dict:\n            span_dict[file_with_spans.file_path] = []\n\n        for span_id in file_with_spans.span_ids:\n            if span_id not in span_dict[file_with_spans.file_path]:\n                span_dict[file_with_spans.file_path].append(span_id)\n    return span_dict"
  },
  {
    "type": "function",
    "name": "get_missing_files",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 229,
    "end_line": 237,
    "code": "def get_missing_files(\n    expected_files_with_spans: dict[str, list[str]],\n    files: list[str],\n) -> list[str]:\n    misses = list(expected_files_with_spans.keys())\n    for actual_file in files:\n        if actual_file in misses:\n            misses.remove(actual_file)\n    return misses"
  },
  {
    "type": "function",
    "name": "get_missing_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 240,
    "end_line": 259,
    "code": "def get_missing_spans(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> dict[str, list[str]]:\n    misses = {}\n    for expected_file, expected_span_ids in expected_files_with_spans.items():\n        if expected_file not in actual_files_with_spans:\n            actual_span_ids = []\n        else:\n            actual_span_ids = actual_files_with_spans[expected_file]\n\n        missing_span_ids = [\n            span_id\n            for span_id in expected_span_ids\n            if span_id not in actual_span_ids and span_id not in IGNORED_SPANS\n        ]\n\n        if missing_span_ids:\n            misses[expected_file] = missing_span_ids\n    return misses"
  },
  {
    "type": "function",
    "name": "count_identified_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 262,
    "end_line": 272,
    "code": "def count_identified_spans(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> int:\n    count = 0\n    for actual_file, actual_span_ids in actual_files_with_spans.items():\n        if expected_files_with_spans.get(actual_file, []):\n            for actual_span_id in actual_span_ids:\n                if actual_span_id in expected_files_with_spans[actual_file]:\n                    count += 1\n    return count"
  },
  {
    "type": "function",
    "name": "count_identified_files",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 275,
    "end_line": 283,
    "code": "def count_identified_files(\n    expected_files_with_spans: dict[str, list[str]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> int:\n    count = 0\n    for actual_file, actual_span_ids in actual_files_with_spans.items():\n        if expected_files_with_spans.get(actual_file, []):\n            count += 1\n    return count"
  },
  {
    "type": "function",
    "name": "has_identified_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 286,
    "end_line": 296,
    "code": "def has_identified_spans(\n    expected_solutions: list[dict[str, list[str]]],\n    actual_files_with_spans: dict[str, list[str]],\n) -> bool:\n    for expected_file_with_spans in expected_solutions:\n        missing_spans = get_missing_spans(\n            expected_file_with_spans, actual_files_with_spans\n        )\n        if not missing_spans or missing_spans == [\"docstring\"]:\n            return True\n    return False"
  },
  {
    "type": "function",
    "name": "has_identified_files",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 299,
    "end_line": 311,
    "code": "def has_identified_files(\n    expected_solutions: list[dict[str, list[str]]],\n    actual_files_with_spans: dict[str, list[str]] | list[str],\n) -> bool:\n    if isinstance(actual_files_with_spans, dict):\n        actual_files = list(actual_files_with_spans.keys())\n    else:\n        actual_files = actual_files_with_spans\n\n    for expected_file_with_spans in expected_solutions:\n        if not get_missing_files(expected_file_with_spans, actual_files):\n            return True\n    return False"
  },
  {
    "type": "function",
    "name": "calculate_estimated_context_window",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 314,
    "end_line": 372,
    "code": "def calculate_estimated_context_window(instance, results):\n    patch = instance.get(\"patch\") or instance.get(\"golden_patch\")\n    patch_diffs = get_diff_lines(patch)\n    expected_changes = []\n\n    for patch_diff in patch_diffs:\n        change_file, change_start, change_end, change_type = patch_diff\n        expected_changes.append(\n            {\n                \"file_path\": change_file,\n                \"start_line\": change_start,\n                \"end_line\": change_end,\n                \"closest_match_context_window\": None,\n                \"closest_match_lines\": None,\n                \"position\": None,\n                \"distance\": None,\n                \"context_window\": None,\n            }\n        )\n\n    sum_tokens = 0\n\n    for i, result in enumerate(results):\n        sum_tokens += result.tokens\n        for change in expected_changes:\n            if result.file_path == change[\"file_path\"]:\n                logger.info(\n                    f\"Found result for {change['file_path']} ({change['sta..."
  },
  {
    "type": "function",
    "name": "read_search_trees",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 375,
    "end_line": 391,
    "code": "def read_search_trees(dir: str) -> list[CodeQASearchTree]:\n    search_trees = []\n    for root, _, files in os.walk(dir):\n        trajectory_path = os.path.join(root, \"trajectory.json\")\n        if not os.path.exists(trajectory_path):\n            continue\n\n        try:\n            if os.stat(trajectory_path).st_size == 0:\n                logger.warning(f\"Empty trajectory file: {trajectory_path}\")\n                continue\n\n            search_tree = CodeQASearchTree.from_file(trajectory_path)\n            search_trees.append(search_tree)\n        except Exception as e:\n            logger.exception(f\"Failed to load trajectory from {trajectory_path}: {e}\")\n    return search_trees"
  },
  {
    "type": "function",
    "name": "trace_metadata",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark",
    "start_line": 394,
    "end_line": 403,
    "code": "def trace_metadata(instance_id: str, session_id: str, trace_name: str):\n    date_time_str = time.strftime(\"%Y%m%d-%H%M%S\")\n    trace_id = f\"coder_{instance_id}_{date_time_str}\"\n    return {\n        \"session_id\": session_id,\n        \"name\": trace_name,\n        \"trace\": trace_name,\n        \"trace_id\": trace_id,\n        \"tags\": [instance_id],\n    }"
  },
  {
    "type": "function",
    "name": "load_instances",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 23,
    "end_line": 29,
    "code": "def load_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\", split: str = \"test\"\n):\n    from datasets import load_dataset\n\n    data = load_dataset(dataset_name, split=split)\n    return {d[\"instance_id\"]: d for d in data}"
  },
  {
    "type": "function",
    "name": "load_instance",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 32,
    "end_line": 38,
    "code": "def load_instance(\n    instance_id: str,\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n):\n    data = load_instances(dataset_name, split=split)\n    return data[instance_id]"
  },
  {
    "type": "function",
    "name": "sorted_instances",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 41,
    "end_line": 51,
    "code": "def sorted_instances(\n    dataset_name: str = \"princeton-nlp/SWE-bench_Lite\",\n    split: str = \"test\",\n    sort_by: str = \"created_at\",\n):\n    from datasets import load_dataset\n\n    data = load_dataset(dataset_name, split=split)\n    instances = list(data)\n    instances = sorted(instances, key=lambda x: x[sort_by])\n    return instances"
  },
  {
    "type": "function",
    "name": "get_repo_dir_name",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 54,
    "end_line": 55,
    "code": "def get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"__\")"
  },
  {
    "type": "function",
    "name": "found_in_expected_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 58,
    "end_line": 66,
    "code": "def found_in_expected_spans(instance: dict, spans: dict):\n    for file_path, span_ids in instance[\"expected_spans\"].items():\n        if not span_ids:\n            logging.warning(\n                f\"{instance['instance_id']} Expected spans for {file_path} is empty\"\n            )\n\n    missing_spans = get_missing_spans(instance[\"expected_spans\"], spans)\n    return not missing_spans"
  },
  {
    "type": "function",
    "name": "found_in_alternative_spans",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 69,
    "end_line": 83,
    "code": "def found_in_alternative_spans(instance: dict, spans: dict):\n    if \"alternative_spans\" not in instance:\n        return False\n    for alternative_spans in instance[\"alternative_spans\"]:\n        for file_path, span_ids in alternative_spans[\"spans\"].items():\n            if not span_ids:\n                logging.info(\n                    f\"{instance['instance_id']} Alternative spans for {file_path} is empty\"\n                )\n\n        missing_spans = get_missing_spans(alternative_spans[\"spans\"], spans)\n        if not missing_spans:\n            return True\n\n    return False"
  },
  {
    "type": "function",
    "name": "found_in_alternative_files",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 86,
    "end_line": 100,
    "code": "def found_in_alternative_files(instance: dict, files: list):\n    if \"alternative_spans\" not in instance:\n        return False\n    for alternative_spans in instance[\"alternative_spans\"]:\n        for file_path, span_ids in alternative_spans[\"spans\"].items():\n            if not span_ids:\n                logging.info(\n                    f\"{instance['instance_id']} Alternative spans for {file_path} is empty\"\n                )\n\n        missing_spans = get_missing_files(alternative_spans[\"spans\"], files)\n        if not missing_spans:\n            return True\n\n    return False"
  },
  {
    "type": "function",
    "name": "setup_swebench_repo",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 103,
    "end_line": 123,
    "code": "def setup_swebench_repo(\n    instance_data: Optional[dict] = None,\n    instance_id: str = None,\n    repo_base_dir: Optional[str] = None,\n) -> str:\n    assert (\n        instance_data or instance_id\n    ), \"Either instance_data or instance_id must be provided\"\n    if not instance_data:\n        instance_data = load_instance(instance_id)\n\n    if not repo_base_dir:\n        repo_base_dir = os.getenv(\"REPO_DIR\", \"/tmp/repos\")\n\n    repo_dir_name = instance_data[\"repo\"].replace(\"/\", \"__\")\n    github_repo_path = f\"swe-bench/{repo_dir_name}\"\n    return setup_github_repo(\n        repo=github_repo_path,\n        base_commit=instance_data[\"base_commit\"],\n        base_dir=repo_base_dir,\n    )"
  },
  {
    "type": "function",
    "name": "create_repository",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 126,
    "end_line": 301,
    "code": "def create_repository(\n    instance: Optional[dict] = None,\n    instance_id: Optional[str] = None,\n    repo_base_dir: Optional[str] = None,\n    repo_url: Optional[str] = None,\n    repo_path: Optional[str] = None,\n    commit: Optional[str] = None,\n):\n    \"\"\"\n    创建代码仓库的工作区。\n    支持三种方式：\n    1. 通过instance或instance_id创建SWE-bench实例的工作区\n    2. 通过repo_url直接克隆Git仓库\n    3. 通过repo_path使用已存在的本地仓库\n\n    参数:\n        instance: SWE-bench实例数据字典\n        instance_id: SWE-bench实例ID\n        repo_base_dir: 仓库基础目录\n        repo_url: Git仓库URL\n        repo_path: 本地仓库路径\n        commit: Git提交哈希\n    \n    返回:\n        Repository: 仓库对象\n    \"\"\"\n    if repo_path and os.path.exists(repo_path):\n        logger.info(f\"使用已存在的本地仓库: {repo_path}\")\n        if commit:\n            # 检查提交是否存在\n            try:\n                import subprocess\n                result = subprocess.run(\n                    [\"git\", \"cat-file\", \"-e\", commit],\n                    cwd=repo_path,\n                    capture_output=True,\n                   ..."
  },
  {
    "type": "function",
    "name": "create_index",
    "class_name": null,
    "file": "utils.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/benchmark/swebench",
    "start_line": 304,
    "end_line": 413,
    "code": "def create_index(\n    instance: dict = None,\n    repository: Repository | None = None,\n    index_store_dir: Optional[str] = None,\n    instance_id: Optional[str] = None,\n    repo_url: Optional[str] = None,\n    repo_path: Optional[str] = None,\n    repo_base_dir: Optional[str] = None,\n    commit: Optional[str] = None,\n    index_name: Optional[str] = None,\n    force_rebuild: bool = False,\n):\n    \"\"\"\n    为仓库创建代码索引。\n    支持多种方式指定仓库：\n    1. 提供已有的Repository对象\n    2. 提供instance或instance_id（SWE-bench实例）\n    3. 提供repo_url（Git仓库URL）\n    4. 提供repo_path（本地仓库路径）\n\n    参数:\n        instance: SWE-bench实例数据字典\n        repository: 已初始化的Repository对象\n        index_store_dir: 索引存储目录\n        instance_id: SWE-bench实例ID\n        repo_url: Git仓库URL\n        repo_path: 本地仓库路径\n        repo_base_dir: 仓库基础目录\n        commit: Git提交哈希\n        index_name: 索引名称（如果为None，将使用实例ID或从仓库路径/URL派生）\n        force_rebuild: 是否强制重建索引\n    \n    返回:\n        CodeIndex: 代码索引对象\n    \"\"\"\n    if not index_store_dir:\n        index_store_dir = os.ge..."
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 68,
    "end_line": 92,
    "code": "def __init__(\n        self,\n        faiss_index: Any,\n        d: int = 1536,\n        data: SimpleVectorStoreData | None = None,\n        fs: fsspec.AbstractFileSystem | None = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n\n        import_err_msg = \"\"\"\n            `faiss` package not found. For instructions on\n            how to install `faiss` please visit\n            https://github.com/facebookresearch/faiss/wiki/Installing-Faiss\n        \"\"\"\n        try:\n            import faiss\n        except ImportError as e:\n            raise ImportError(import_err_msg) from e\n\n        self._d = d\n        self._faiss_index = cast(faiss.Index, faiss_index)\n        self._data = data or SimpleVectorStoreData()\n        self._fs = fs or fsspec.filesystem(\"file\")\n        super().__init__(**kwargs)"
  },
  {
    "type": "function",
    "name": "from_defaults",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 95,
    "end_line": 97,
    "code": "def from_defaults(cls, d: int = 1536):\n        faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(1536))\n        return cls(faiss_index, d)"
  },
  {
    "type": "function",
    "name": "client",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 100,
    "end_line": 102,
    "code": "def client(self) -> Any:\n        \"\"\"Return the faiss index.\"\"\"\n        return self._faiss_index"
  },
  {
    "type": "function",
    "name": "add",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 104,
    "end_line": 142,
    "code": "def add(\n        self,\n        nodes: list[BaseNode],\n        **add_kwargs: Any,\n    ) -> list[str]:\n        \"\"\"Add nodes to index.\"\"\"\n\n        if not nodes:\n            return []\n\n        vector_id = (\n            max([int(k) for k in self._data.vector_id_to_text_id])\n            if self._data.vector_id_to_text_id\n            else 0\n        )\n\n        logger.info(f\"Adding {len(nodes)} nodes to index, start at id {vector_id}.\")\n\n        embeddings = []\n        ids = []\n        for node in nodes:\n            embeddings.append(node.get_embedding())\n            ids.append(int(vector_id))\n            self._data.vector_id_to_text_id[vector_id] = node.id_\n            self._data.text_id_to_ref_doc_id[node.id_] = node.ref_doc_id or node.id_\n            vector_id += 1\n\n            metadata = node_to_metadata_dict(\n                node, remove_text=True, flat_metadata=False\n            )\n            metadata.pop(\"_node_content\", None)\n            self._data.metadata_dict[node.node_id] = metadata..."
  },
  {
    "type": "function",
    "name": "delete",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 144,
    "end_line": 160,
    "code": "def delete(self, ref_doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"\n        Delete nodes using with ref_doc_id.\n\n        Args:\n            ref_doc_id (str): The doc_id of the document to delete.\n\n        \"\"\"\n\n        self._text_ids_to_delete = set()\n        for text_id, ref_doc_id_ in self._data.text_id_to_ref_doc_id.items():\n            if ref_doc_id == ref_doc_id_:\n                self._text_ids_to_delete.add(text_id)\n\n        for vector_id, text_id in self._data.vector_id_to_text_id.items():\n            if text_id in self._text_ids_to_delete:\n                self._vector_ids_to_delete.append(vector_id)"
  },
  {
    "type": "function",
    "name": "query",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 162,
    "end_line": 218,
    "code": "def query(\n        self,\n        query: VectorStoreQuery,\n        **kwargs: Any,\n    ) -> VectorStoreQueryResult:\n        \"\"\"Query index for top k most similar nodes.\n\n        Args:\n            query_embedding (List[float]): query embedding\n            similarity_top_k (int): top k most similar nodes\n\n        \"\"\"\n        query_filter_fn = _build_metadata_filter_fn(\n            lambda node_id: self._data.metadata_dict[node_id], query.filters\n        )\n\n        query_embedding = cast(list[float], query.query_embedding)\n        query_embedding_np = np.array(query_embedding, dtype=\"float32\")[np.newaxis, :]\n        dists, indices = self._faiss_index.search(\n            query_embedding_np, query.similarity_top_k\n        )\n        dists = list(dists[0])\n\n        if len(indices) == 0:\n            return VectorStoreQueryResult(similarities=[], ids=[])\n\n        node_idxs = indices[0]\n\n        duplicates = 0\n        not_found = 0\n        filtered_out = 0\n\n        filtered_dists = []\n        filte..."
  },
  {
    "type": "function",
    "name": "persist",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 220,
    "end_line": 259,
    "code": "def persist(\n        self,\n        persist_dir: str = DEFAULT_PERSIST_DIR,\n        fs: fsspec.AbstractFileSystem | None = None,\n    ) -> None:\n        \"\"\"Persist the SimpleVectorStore to a directory.\"\"\"\n        fs = fs or self._fs\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: write to a temporary file and then copy to the final destination\n        if fs and not isinstance(fs, LocalFileSystem):\n            raise NotImplementedError(\"FAISS only supports local storage for now.\")\n        import faiss\n\n        if not os.path.exists(persist_dir):\n            os.makedirs(persist_dir)\n\n        logger.info(f\"Deleting {len(self._vector_ids_to_delete)} vectors from index.\")\n\n        if self._vector_ids_to_delete:\n            ids_to_remove_array = np.array(self._vector_ids_to_delete, dtype=np.int64)\n            removed = self._faiss_index.remove_ids(ids_to_remove_array)\n            logger.info(f\"Removed {removed} vectors from index.\")\n\n   ..."
  },
  {
    "type": "function",
    "name": "from_persist_dir",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 262,
    "end_line": 285,
    "code": "def from_persist_dir(\n        cls, persist_dir: str, fs: fsspec.AbstractFileSystem | None = None\n    ) -> \"SimpleFaissVectorStore\":\n        \"\"\"Create a SimpleKVStore from a persist directory.\"\"\"\n\n        fs = fs or fsspec.filesystem(\"file\")\n        if not fs.exists(persist_dir):\n            raise ValueError(f\"No existing index store found at {persist_dir}.\")\n\n        # I don't think FAISS supports fsspec, it requires a path in the SWIG interface\n        # TODO: copy to a temp file and load into memory from there\n        if fs and not isinstance(fs, LocalFileSystem):\n            raise NotImplementedError(\"FAISS only supports local storage for now.\")\n\n        faiss_index = faiss.read_index(f\"{persist_dir}/vector_index.faiss\")\n\n        logger.debug(f\"Loading {__name__} from {persist_dir}.\")\n        with fs.open(f\"{persist_dir}/vector_index.json\", \"rb\") as f:\n            data_dict = json.load(f)\n            data = SimpleVectorStoreData.from_dict(data_dict)\n\n        logger.info(f\"Loading {_..."
  },
  {
    "type": "function",
    "name": "from_index",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 288,
    "end_line": 289,
    "code": "def from_index(cls, faiss_index: Any):\n        return cls(faiss_index)"
  },
  {
    "type": "function",
    "name": "to_dict",
    "class_name": "SimpleFaissVectorStore",
    "file": "simple_faiss.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 291,
    "end_line": 292,
    "code": "def to_dict(self) -> dict:\n        return self._data.to_dict()"
  },
  {
    "type": "function",
    "name": "span_ids",
    "class_name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 41,
    "end_line": 42,
    "code": "def span_ids(self):\n        return [span.span_id for span in self.spans]"
  },
  {
    "type": "function",
    "name": "add_span",
    "class_name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 44,
    "end_line": 46,
    "code": "def add_span(self, span_id: str, rank: int = 0, tokens: int = 0):\n        if span_id not in [span.span_id for span in self.spans]:\n            self.spans.append(SpanHit(span_id=span_id, rank=rank, tokens=tokens))"
  },
  {
    "type": "function",
    "name": "contains_span",
    "class_name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 48,
    "end_line": 49,
    "code": "def contains_span(self, span_id: str) -> bool:\n        return span_id in [span.span_id for span in self.spans]"
  },
  {
    "type": "function",
    "name": "add_spans",
    "class_name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 51,
    "end_line": 53,
    "code": "def add_spans(self, span_ids: list[str], rank: int = 0):\n        for span_id in span_ids:\n            self.add_span(span_id, rank)"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "SearchCodeHit",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 55,
    "end_line": 56,
    "code": "def __str__(self):\n        return f\"{self.file_path}: {', '.join([span.span_id for span in self.spans])}\""
  },
  {
    "type": "function",
    "name": "sum_tokens",
    "class_name": "SearchCodeResponse",
    "file": "types.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 69,
    "end_line": 70,
    "code": "def sum_tokens(self):\n        return sum([sum([span.tokens for span in hit.spans]) for hit in self.hits])"
  },
  {
    "type": "function",
    "name": "default_vector_store",
    "class_name": null,
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 34,
    "end_line": 44,
    "code": "def default_vector_store(settings: IndexSettings):\n    try:\n        import faiss\n    except ImportError as e:\n        raise ImportError(\n            \"faiss needs to be installed to set up a default index for CodeIndex. Run 'pip install faiss-cpu'\"\n        ) from e\n\n    # faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(settings.dimensions))\n    faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(1024))\n    return SimpleFaissVectorStore(faiss_index)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 48,
    "end_line": 86,
    "code": "def __init__(\n        self,\n        file_repo: Repository,\n        index_name: Optional[str] = None,\n        vector_store: \"BasePydanticVectorStore | None\" = None,\n        docstore: \"DocumentStore | None\" = None,\n        embed_model: \"BaseEmbedding | None\" = None,\n        blocks_by_class_name: Optional[dict] = None,\n        blocks_by_function_name: Optional[dict] = None,\n        settings: IndexSettings | None = None,\n        max_results: int = 25,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n    ):\n        self._index_name = index_name\n        self._settings = settings or IndexSettings()\n\n        self.max_results = max_results\n        self.max_hits_without_exact_match = max_hits_without_exact_match\n        self.max_exact_results = max_exact_results\n\n        self._file_repo = file_repo\n\n        self._blocks_by_class_name = blocks_by_class_name or {}\n        self._blocks_by_function_name = blocks_by_function_name or {}\n\n        from moatless_qa.ind..."
  },
  {
    "type": "function",
    "name": "from_persist_dir",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 89,
    "end_line": 117,
    "code": "def from_persist_dir(cls, persist_dir: str, file_repo: Repository, **kwargs):\n        from moatless_qa.index.simple_faiss import SimpleFaissVectorStore\n        from llama_index.core.storage.docstore import SimpleDocumentStore\n        vector_store = SimpleFaissVectorStore.from_persist_dir(persist_dir)\n        docstore = SimpleDocumentStore.from_persist_dir(persist_dir)\n\n        settings = IndexSettings.from_persist_dir(persist_dir)\n\n        if os.path.exists(os.path.join(persist_dir, \"blocks_by_class_name.json\")):\n            with open(os.path.join(persist_dir, \"blocks_by_class_name.json\")) as f:\n                blocks_by_class_name = json.load(f)\n        else:\n            blocks_by_class_name = {}\n\n        if os.path.exists(os.path.join(persist_dir, \"blocks_by_function_name.json\")):\n            with open(os.path.join(persist_dir, \"blocks_by_function_name.json\")) as f:\n                blocks_by_function_name = json.load(f)\n        else:\n            blocks_by_function_name = {}\n\n        ..."
  },
  {
    "type": "function",
    "name": "from_url",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 120,
    "end_line": 148,
    "code": "def from_url(cls, url: str, persist_dir: str, file_repo: FileRepository):\n        try:\n            # 检查目标目录是否可写\n            if not os.access(os.path.dirname(persist_dir), os.W_OK):\n                alt_dir = os.path.join(\"/tmp\", os.path.basename(persist_dir))\n                logger.warning(f\"目标目录 {persist_dir} 不可写，尝试使用替代目录 {alt_dir}\")\n                persist_dir = alt_dir\n                os.makedirs(persist_dir, exist_ok=True)\n            \n            response = requests.get(url, stream=True)\n            response.raise_for_status()\n\n            with tempfile.TemporaryDirectory() as temp_dir:\n                temp_zip_file = os.path.join(temp_dir, url.split(\"/\")[-1])\n\n                with open(temp_zip_file, \"wb\") as data:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        data.write(chunk)\n                shutil.unpack_archive(temp_zip_file, persist_dir)\n\n        except requests.exceptions.HTTPError as e:\n            logger.exception(f\"HTTP E..."
  },
  {
    "type": "function",
    "name": "from_index_name",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 151,
    "end_line": 174,
    "code": "def from_index_name(\n        cls,\n        index_name: str,\n        file_repo: Repository,\n        index_store_dir: Optional[str] = None,\n    ):\n        if not index_store_dir:\n            index_store_dir = os.getenv(\"INDEX_STORE_DIR\")\n\n        persist_dir = os.path.join(index_store_dir, index_name)\n        if os.path.exists(persist_dir):\n            logger.info(f\"Loading existing index {index_name} from {persist_dir}.\")\n            return cls.from_persist_dir(persist_dir, file_repo=file_repo)\n        else:\n            logger.info(f\"No existing index found at {persist_dir}.\")\n\n        if os.getenv(\"INDEX_STORE_URL\"):\n            index_store_url = os.getenv(\"INDEX_STORE_URL\")\n        else:\n            index_store_url = \"https://stmoatless.blob.core.windows.net/indexstore/20240814-voyage-code-2/\"\n\n        store_url = os.path.join(index_store_url, f\"{index_name}.zip\")\n        logger.info(f\"Downloading existing index {index_name} from {store_url}.\")\n        return cls.from_url(store_url, pe..."
  },
  {
    "type": "function",
    "name": "from_repository",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 177,
    "end_line": 237,
    "code": "def from_repository(\n        cls,\n        repo_url: Optional[str] = None,\n        repo_path: Optional[str] = None,\n        commit: Optional[str] = None,\n        index_name: Optional[str] = None,\n        index_store_dir: Optional[str] = None,\n        file_repo: Optional[Repository] = None,\n        force_rebuild: bool = False,\n    ):\n        \"\"\"\n        直接从Git仓库URL或本地仓库路径创建CodeIndex实例。\n        \n        参数:\n            repo_url: Git仓库URL\n            repo_path: 本地仓库路径\n            commit: Git提交哈希\n            index_name: 索引名称（如果为None，将从仓库路径/URL派生）\n            index_store_dir: 索引存储目录\n            repo_base_dir: 仓库基础目录\n            force_rebuild: 是否强制重建索引\n        \n        返回:\n            CodeIndex: 代码索引对象\n        \"\"\"\n        from moatless_qa.benchmark.swebench.utils import create_index\n        \n        if not repo_url and not repo_path:\n            raise ValueError(\"必须提供repo_url或repo_path\")\n        \n        if not index_store_dir:\n            index_store_dir = os.getenv(\"MOATLESS_INDEX_DIR\", \"/t..."
  },
  {
    "type": "function",
    "name": "dict",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 239,
    "end_line": 240,
    "code": "def dict(self):\n        return {\"index_name\": self._index_name}"
  },
  {
    "type": "function",
    "name": "semantic_search",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 242,
    "end_line": 414,
    "code": "def semantic_search(\n        self,\n        query: Optional[str] = None,\n        code_snippet: Optional[str] = None,\n        file_pattern: Optional[str] = None,\n        category: str | None = None,\n        max_results: int = 100,\n        max_tokens: int = 8000,\n        max_hits_without_exact_match: int = 100,\n        max_exact_results: int = 5,\n        max_spans_per_file: Optional[int] = None,\n        exact_match_if_possible: bool = False,\n    ) -> SearchCodeResponse:\n        if query is None:\n            query = \"\"\n\n        message = \"\"\n        if file_pattern:\n            if category and category != \"test\":\n                exclude_files = self._file_repo.matching_files(\"**/test*/**\")\n            else:\n                exclude_files = []\n\n            try:\n                matching_files = self._file_repo.matching_files(file_pattern)\n                matching_files = [\n                    file for file in matching_files if file not in exclude_files\n                ]\n            except Exce..."
  },
  {
    "type": "function",
    "name": "find_class",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 416,
    "end_line": 419,
    "code": "def find_class(self, class_name: str, file_pattern: Optional[str] = None):\n        return self.find_by_name(\n            class_name=class_name, file_pattern=file_pattern, strict=True\n        )"
  },
  {
    "type": "function",
    "name": "find_function",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 421,
    "end_line": 432,
    "code": "def find_function(\n        self,\n        function_name: str,\n        class_name: Optional[str] = None,\n        file_pattern: Optional[str] = None,\n    ):\n        return self.find_by_name(\n            function_name=function_name,\n            class_name=class_name,\n            file_pattern=file_pattern,\n            strict=True,\n        )"
  },
  {
    "type": "function",
    "name": "find_by_name",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 434,
    "end_line": 614,
    "code": "def find_by_name(\n        self,\n        class_name: str = None,\n        function_name: str = None,\n        file_pattern: Optional[str] = None,\n        include_functions_in_class: bool = True,\n        strict: bool = False,\n        category: str | None = None,\n    ) -> SearchCodeResponse:\n        if not class_name and not function_name:\n            raise ValueError(\n                \"At least one of class_name or function_name must be provided.\"\n            )\n\n        paths = []\n\n        # If class name is provided only find the clasees and then filter on function name if necessary\n        if class_name:\n            paths = self._blocks_by_class_name.get(class_name, [])\n        elif function_name:\n            paths = self._blocks_by_function_name.get(function_name, [])\n        else:\n            raise ValueError(\n                \"At least one of class_name or function_name must be provided.\"\n            )\n\n        if file_pattern:\n            include_files = self._file_repo.matching_files(..."
  },
  {
    "type": "function",
    "name": "find_test_files",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 616,
    "end_line": 691,
    "code": "def find_test_files(\n        self,\n        file_path: str,\n        span_id: str | None = None,\n        query: str | None = None,\n        max_results: int = 5,\n        max_tokens: int | None = None,\n        max_method_tokens: int = 500,\n        max_spans: int | None = None,\n    ) -> list[FileWithSpans]:\n        if span_id:\n            query = f\"{file_path} {span_id}\"\n        elif query:\n            query = f\"{file_path} {query}\"\n        else:\n            query = file_path\n\n        search_results = self._vector_search(query, category=\"test\")\n\n        sum_tokens = 0\n        files = []\n        matching_file = self._find_by_test_pattern(file_path)\n        if matching_file:\n            files.append(FileWithSpans(file_path=matching_file, span_ids=[]))\n        elif span_id or query and max_results > 1:\n            # Try to find the most similar test file by file name if no exact match on file name\n            files = self.find_test_files(file_path, max_results=1, max_spans=max_spans)\n\n        ..."
  },
  {
    "type": "function",
    "name": "_find_by_test_pattern",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 693,
    "end_line": 722,
    "code": "def _find_by_test_pattern(self, file_path: str) -> str | None:\n        \"\"\"\n        Find the test file related to the provided file path.\n\n        Test files should match the pattern \"test_[filename].py\" or \"[filename]_test.py\".\n        If there are multiple matches, the one with the most similar directory path is picked.\n        \"\"\"\n        filename = os.path.basename(file_path)\n        dirname = os.path.dirname(file_path)\n        test_patterns = [f\"test_{filename}\", f\"{filename}_test.py\"]\n\n        matched_files = self._file_repo.find_by_pattern(test_patterns)\n        if not matched_files:\n            return None\n\n        if len(matched_files) == 1:\n            return matched_files[0]\n\n        # Find the test file with the most similar directory path\n        best_match = None\n        best_match_score = float(\"inf\")\n        for test_file in matched_files:\n            test_dirname = os.path.dirname(test_file)\n            common_prefix = os.path.commonprefix([dirname, test_dirname])\n     ..."
  },
  {
    "type": "function",
    "name": "_create_search_hit",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 724,
    "end_line": 728,
    "code": "def _create_search_hit(self, file: FileWithSpans, rank: int = 0):\n        file_hit = SearchCodeHit(file_path=file.file_path)\n        for span_id in file.span_ids:\n            file_hit.add_span(span_id, rank)\n        return file_hit"
  },
  {
    "type": "function",
    "name": "_vector_search",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 730,
    "end_line": 861,
    "code": "def _vector_search(\n        self,\n        query: str = \"\",\n        exact_query_match: bool = False,\n        category: str | None = None,\n        file_pattern: Optional[str] = None,\n        exact_content_match: Optional[str] = None,\n        top_k: int = 500,\n    ):\n        # Import llama_index components only when needed\n        from llama_index.core.vector_stores.types import VectorStoreQuery\n\n        if file_pattern:\n            query += f\" file:{file_pattern}\"\n\n        if exact_content_match:\n            query += \"\\n\" + exact_content_match\n\n        if not query:\n            raise ValueError(\n                \"At least one of query, span_keywords or content_keywords must be provided.\"\n            )\n\n        logger.debug(\n            f\"vector_search() Searching for query [{query[:50]}...] and file pattern [{file_pattern}].\"\n        )\n\n        query_embedding = self._embed_model.get_query_embedding(query)\n\n        # FIXME: Filters can't be used ATM. Category isn't set in some instance ve..."
  },
  {
    "type": "function",
    "name": "run_ingestion",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 863,
    "end_line": 988,
    "code": "def run_ingestion(\n        self,\n        repo_path: Optional[str] = None,\n        input_files: list[str] | None = None,\n        num_workers: Optional[int] = None,\n    ):\n        # Import llama_index components only when needed\n        from llama_index.core import SimpleDirectoryReader\n        from llama_index.core.ingestion import DocstoreStrategy, IngestionPipeline\n\n        repo_path = repo_path or self._file_repo.path\n\n        # Only extract file name and type to not trigger unnecessary embedding jobs\n        def file_metadata_func(file_path: str) -> dict:\n            file_path = file_path.replace(repo_path, \"\")\n            if file_path.startswith(\"/\"):\n                file_path = file_path[1:]\n\n            category = \"test\" if is_test(file_path) else \"implementation\"\n\n            return {\n                \"file_path\": file_path,\n                \"file_name\": os.path.basename(file_path),\n                \"file_type\": mimetypes.guess_type(file_path)[0],\n                \"category\": catego..."
  },
  {
    "type": "function",
    "name": "persist",
    "class_name": "CodeIndex",
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 990,
    "end_line": 1002,
    "code": "def persist(self, persist_dir: str):\n        self._vector_store.persist(persist_dir)\n        self._docstore.persist(\n            # os.path.join(persist_dir, self._docstore.types.DEFAULT_PERSIST_FNAME)\n            os.path.join(persist_dir, \"docstore.json\")\n        )\n        self._settings.persist(persist_dir)\n\n        with open(os.path.join(persist_dir, \"blocks_by_class_name.json\"), \"w\") as f:\n            f.write(json.dumps(self._blocks_by_class_name, indent=2))\n\n        with open(os.path.join(persist_dir, \"blocks_by_function_name.json\"), \"w\") as f:\n            f.write(json.dumps(self._blocks_by_function_name, indent=2))"
  },
  {
    "type": "function",
    "name": "_rerank_files",
    "class_name": null,
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 1005,
    "end_line": 1027,
    "code": "def _rerank_files(file_paths: list[str], file_pattern: str):\n    if len(file_paths) < 2:\n        return file_paths\n\n    tokenized_query = file_pattern.replace(\".py\", \"\").replace(\"*\", \"\").split(\"/\")\n    tokenized_query = [part for part in tokenized_query if part.strip()]\n    query = \"/\".join(tokenized_query)\n\n    scored_files = []\n    for file_path in file_paths:\n        cleaned_file_path = file_path.replace(\".py\", \"\")\n        score = fuzz.partial_ratio(cleaned_file_path, query)\n        scored_files.append((file_path, score))\n\n    scored_files.sort(key=lambda x: x[1], reverse=True)\n\n    sorted_file_paths = [file for file, score in scored_files]\n\n    logger.info(\n        f\"rerank_files() Reranked {len(file_paths)} files with query {tokenized_query}. First hit {sorted_file_paths[0]}\"\n    )\n\n    return sorted_file_paths"
  },
  {
    "type": "function",
    "name": "is_string_in",
    "class_name": null,
    "file": "code_index.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 1030,
    "end_line": 1034,
    "code": "def is_string_in(s1, s2):\n    s1_clean = s1.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    s2_clean = s2.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\")\n    found_in = s1_clean in s2_clean\n    return found_in"
  },
  {
    "type": "function",
    "name": "get_embed_model",
    "class_name": null,
    "file": "embed_model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 40,
    "end_line": 58,
    "code": "def get_embed_model(model_name: str) -> \"BaseEmbedding\":\n\n    try:\n        from llama_index.embeddings.voyageai import VoyageEmbedding\n    except ImportError as e:\n        raise ImportError(\n            \"llama-index-embeddings-voyageai is not installed. Please install it using `pip install llama-index-embeddings-voyageai`\"\n        ) from e\n\n    if \"VOYAGE_API_KEY\" not in os.environ:\n        raise ValueError(\n            \"VOYAGE_API_KEY environment variable is not set. Please set it to your Voyage API key.\"\n        )\n    return VoyageEmbeddingWithRetry(\n        model_name=\"voyage-3\",\n        voyage_api_key=os.environ.get(\"VOYAGE_API_KEY\"),\n        truncation=True,\n        embed_batch_size=80,\n    )"
  },
  {
    "type": "function",
    "name": "to_serializable_dict",
    "class_name": "IndexSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 39,
    "end_line": 42,
    "code": "def to_serializable_dict(self):\n        data = self.dict()\n        data[\"comment_strategy\"] = data[\"comment_strategy\"].value\n        return data"
  },
  {
    "type": "function",
    "name": "persist",
    "class_name": "IndexSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 44,
    "end_line": 46,
    "code": "def persist(self, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\"), \"w\") as f:\n            json.dump(self.to_serializable_dict(), f, indent=4)"
  },
  {
    "type": "function",
    "name": "from_persist_dir",
    "class_name": "IndexSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 49,
    "end_line": 52,
    "code": "def from_persist_dir(cls, persist_dir: str):\n        with open(os.path.join(persist_dir, \"settings.json\")) as f:\n            data = json.load(f)\n        return cls(**data)"
  },
  {
    "type": "function",
    "name": "count_chunk_tokens",
    "class_name": null,
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 21,
    "end_line": 22,
    "code": "def count_chunk_tokens(chunk: CodeBlockChunk) -> int:\n    return sum([block.tokens for block in chunk])"
  },
  {
    "type": "function",
    "name": "count_parent_tokens",
    "class_name": null,
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 25,
    "end_line": 29,
    "code": "def count_parent_tokens(codeblock: CodeBlock) -> int:\n    tokens = codeblock.tokens\n    if codeblock.parent:\n        tokens += codeblock.parent.tokens\n    return tokens"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 88,
    "end_line": 139,
    "code": "def __init__(\n        self,\n        language: str = \"python\",\n        chunk_size: int = 750,\n        min_chunk_size: int = 100,\n        max_chunk_size: int = 1500,\n        hard_token_limit: int = 6000,\n        max_chunks: int = 100,\n        include_metadata: bool = True,\n        include_prev_next_rel: bool = True,\n        text_splitter: TextSplitter | None = None,\n        index_callback: Optional[Callable[[CodeBlock], None]] = None,\n        repo_path: Optional[str] = None,\n        comment_strategy: CommentStrategy = CommentStrategy.ASSOCIATE,\n        min_lines_to_parse_block: int = 25,\n        # fallback_code_splitter: Optional[TextSplitter] = None,\n        include_non_code_files: bool = True,\n        tokenizer: Optional[Callable] = None,\n        non_code_file_extensions: list[str] | None = None,\n        callback_manager: CallbackManager | None = None,\n    ) -> None:\n        if non_code_file_extensions is None:\n            non_code_file_extensions = [\"md\", \"txt\"]\n        callback_manag..."
  },
  {
    "type": "function",
    "name": "class_name",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 142,
    "end_line": 143,
    "code": "def class_name(cls):\n        return \"GhostcoderNodeParser\""
  },
  {
    "type": "function",
    "name": "_parse_nodes",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 145,
    "end_line": 199,
    "code": "def _parse_nodes(\n        self,\n        nodes: Sequence[BaseNode],\n        show_progress: bool = False,\n        **kwargs: Any,\n    ) -> list[BaseNode]:\n        nodes_with_progress = get_tqdm_iterable(nodes, show_progress, \"Parsing nodes\")\n\n        all_nodes: list[BaseNode] = []\n\n        for node in nodes_with_progress:\n            file_path = node.metadata.get(\"file_path\")\n            content = node.text\n            try:\n                starttime = time.time_ns()\n\n                # TODO: Derive language from file extension\n                codeblock = self._parser.parse(content, file_path=file_path)\n\n                parse_time = time.time_ns() - starttime\n                if parse_time > 1e9:\n                    logger.warning(\n                        f\"Parsing file {file_path} took {parse_time / 1e9:.2f} seconds.\"\n                    )\n\n            except Exception as e:\n                logger.warning(\n                    f\"Failed to use epic splitter to split {file_path}. Fallback to t..."
  },
  {
    "type": "function",
    "name": "_chunk_contents",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 201,
    "end_line": 227,
    "code": "def _chunk_contents(\n        self, codeblock: CodeBlock | None = None, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        tokens = codeblock.sum_tokens()\n        if tokens == 0:\n            logger.debug(f\"Skipping file {file_path} because it has no tokens.\")\n            return []\n\n        if tokens > self.hard_token_limit:\n            for child in codeblock.children:\n                if (\n                    child.type == CodeBlockType.COMMENT\n                    and \"generated\" in child.content.lower()\n                ):  # TODO: Make a generic solution to detect files that shouldn't be indexed. Maybe ask an LLM?\n                    logger.info(\n                        f\"File {file_path} has {tokens} tokens and the word 'generated' in the first comments,\"\n                        f\" will assume it's a generated file.\"\n                    )\n                    return []\n                else:\n                    break\n\n        if tokens < self.min_chunk_size:\n         ..."
  },
  {
    "type": "function",
    "name": "_chunk_block",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 229,
    "end_line": 315,
    "code": "def _chunk_block(\n        self, codeblock: CodeBlock, file_path: Optional[str] = None\n    ) -> list[CodeBlockChunk]:\n        chunks: list[CodeBlockChunk] = []\n        current_chunk = []\n        comment_chunk = []\n\n        parent_tokens = count_parent_tokens(codeblock)\n\n        ignoring_comment = False\n\n        for child in codeblock.children:\n            if child.type == CodeBlockType.COMMENT:\n                if self.comment_strategy == CommentStrategy.EXCLUDE:\n                    continue\n                elif self._ignore_comment(child) or ignoring_comment:\n                    ignoring_comment = True\n                    continue\n                elif (\n                    self.comment_strategy == CommentStrategy.ASSOCIATE\n                    and not codeblock.parent\n                ):\n                    comment_chunk.append(child)\n                    continue\n            else:\n                ignoring_comment = False\n\n            if (\n                child.type in SPLIT_BLOCK_TYPES\n  ..."
  },
  {
    "type": "function",
    "name": "_merge_chunks",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 317,
    "end_line": 381,
    "code": "def _merge_chunks(self, chunks: list[CodeBlockChunk]) -> list[CodeBlockChunk]:\n        while True:\n            merged_chunks = []\n            should_continue = False\n\n            for i, chunk in enumerate(chunks):\n                if (\n                    count_chunk_tokens(chunk) < self.min_chunk_size\n                    or len(chunks) > self.max_chunks\n                ):\n                    if i == 0 and len(chunks) > 1:\n                        if (\n                            count_chunk_tokens(chunks[1]) + count_chunk_tokens(chunk)\n                            <= self.hard_token_limit\n                        ):\n                            chunks[1] = chunk + chunks[1]\n                            should_continue = True\n                        else:\n                            merged_chunks.append(chunk)\n\n                    elif i == len(chunks) - 1:\n                        if (\n                            merged_chunks\n                            and count_chunk_tokens(merged_chunks[..."
  },
  {
    "type": "function",
    "name": "_create_path_tree",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 383,
    "end_line": 387,
    "code": "def _create_path_tree(self, blocks: list[CodeBlock]) -> PathTree:\n        path_tree = PathTree()\n        for block in blocks:\n            path_tree.add_to_tree(block.full_path())\n        return path_tree"
  },
  {
    "type": "function",
    "name": "_ignore_comment",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 389,
    "end_line": 393,
    "code": "def _ignore_comment(self, codeblock: CodeBlock) -> bool:\n        return (\n            re.search(r\"(?i)copyright|license|author\", codeblock.content)\n            or not codeblock.content\n        )"
  },
  {
    "type": "function",
    "name": "_to_context_string",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 395,
    "end_line": 453,
    "code": "def _to_context_string(self, codeblock: CodeBlock, path_tree: PathTree) -> str:\n        contents = \"\"\n\n        if codeblock.pre_lines:\n            contents += \"\\n\" * (codeblock.pre_lines - 1)\n            for i, line in enumerate(codeblock.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + codeblock.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        else:\n            contents += codeblock.pre_code + codeblock.content\n\n        has_outcommented_code = False\n        for _i, child in enumerate(codeblock.children):\n            child_tree = path_tree.child_tree(child.identifier)\n            if child_tree and child_tree.show:\n                if (\n                    has_outcommented_code\n                    and child.type\n                    not in [\n                        CodeBlockType.COMMENT,\n                        CodeBlockType.COMMENTED_OUT_CO..."
  },
  {
    "type": "function",
    "name": "_contains_block_paths",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 455,
    "end_line": 460,
    "code": "def _contains_block_paths(self, codeblock: CodeBlock, block_paths: list[list[str]]):\n        return [\n            block_path\n            for block_path in block_paths\n            if block_path[: len(codeblock.full_path())] == codeblock.full_path()\n        ]"
  },
  {
    "type": "function",
    "name": "_create_node",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 462,
    "end_line": 513,
    "code": "def _create_node(\n        self, content: str, node: BaseNode, chunk: CodeBlockChunk | None = None\n    ) -> TextNode | None:\n        metadata = {}\n        metadata.update(node.metadata)\n\n        node_id = node.id_\n\n        if chunk:\n            metadata[\"start_line\"] = chunk[0].start_line\n            metadata[\"end_line\"] = chunk[-1].end_line\n\n            # TODO: Change this when EpicSplitter is adjusted to use the span concept natively\n            span_ids = set(\n                [\n                    block.belongs_to_span.span_id\n                    for block in chunk\n                    if block.belongs_to_span\n                ]\n            )\n            metadata[\"span_ids\"] = list(sorted(span_ids))\n\n            node_id += f\"_{chunk[0].path_string()}_{chunk[-1].path_string()}\"\n\n        content = content.strip(\"\\n\")\n\n        tokens = count_chunk_tokens(chunk)\n\n        # Truncate large chunks\n        if tokens > self.hard_token_limit:\n            content = content[: self.hard_token_limit..."
  },
  {
    "type": "function",
    "name": "_count_tokens",
    "class_name": "EpicSplitter",
    "file": "epic_split.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 515,
    "end_line": 517,
    "code": "def _count_tokens(self, text: str):\n        tokenizer = get_tokenizer()\n        return len(tokenizer(text))"
  },
  {
    "type": "function",
    "name": "hash",
    "class_name": "CodeNode",
    "file": "code_node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 9,
    "end_line": 16,
    "code": "def hash(self):\n        metadata = self.metadata.copy()\n        metadata.pop(\"start_line\", None)\n        metadata.pop(\"end_line\", None)\n        metadata.pop(\"tokens\", None)\n        cleaned_text = self._clean_text(self.text)\n        doc_identity = cleaned_text + str(metadata)\n        return str(sha256(doc_identity.encode(\"utf-8\", \"surrogatepass\")).hexdigest())"
  },
  {
    "type": "function",
    "name": "_clean_text",
    "class_name": "CodeNode",
    "file": "code_node.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 18,
    "end_line": 22,
    "code": "def _clean_text(self, text):\n        \"\"\"\n        Remove all whitespace and convert to lowercase to reduce the number of changes in hashes.\n        \"\"\"\n        return \"\".join(text.split()).lower()"
  },
  {
    "type": "function",
    "name": "_get_embedding",
    "class_name": "VoyageEmbeddingWithRetry",
    "file": "retry_voyage_embedding.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/index",
    "start_line": 15,
    "end_line": 40,
    "code": "def _get_embedding(self, texts: List[str], input_type: str) -> List[List[float]]:\n        try:\n            return self._client.embed(\n                texts,\n                model=self.model_name,\n                input_type=input_type,\n                truncation=self.truncation,\n            ).embeddings\n        except InvalidRequestError as e:\n            if \"Please lower the number of tokens in the batch\" in str(e):\n                if len(texts) < 10:\n                    raise  # If batch size is already less than 10 we expect batchs to be abnormaly large and raise the error\n\n                mid = len(texts) // 2\n                first_half = texts[:mid]\n                second_half = texts[mid:]\n\n                logger.info(\n                    f\"Splitting batch of {len(texts)} texts into two halves of {len(first_half)} and {len(second_half)} texts.\"\n                )\n\n                embeddings_first = self._get_embedding(first_half, input_type)\n                embeddings_second = self..."
  },
  {
    "type": "function",
    "name": "validate_snippet",
    "class_name": "FindCodeSnippetArgs",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 38,
    "end_line": 41,
    "code": "def validate_snippet(self) -> \"FindCodeSnippetArgs\":\n        if not self.code_snippet.strip():\n            raise ValueError(\"code_snippet cannot be empty\")\n        return self"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FindCodeSnippetArgs",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 43,
    "end_line": 47,
    "code": "def to_prompt(self):\n        prompt = f\"Searching for code snippet: {self.code_snippet}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "FindCodeSnippetArgs",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 49,
    "end_line": 53,
    "code": "def short_summary(self) -> str:\n        param_str = f\"code_snippet={self.code_snippet}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "_search_for_context",
    "class_name": "FindCodeSnippet",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 64,
    "end_line": 91,
    "code": "def _search_for_context(\n        self, args: FindCodeSnippetArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.code_snippet} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.code_snippet, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_path, line_num in matches\n                if fnmatch(file_path, args.file_pattern)\n            ]\n\n        search_result_context = FileContext(repo=self._repository)\n        for file_path, start_line in matches[: self.max_hits]:\n            num_lines = len(args.code_snippet.splitlines())\n            end_line = start_line + num_lines - 1\n\n            search_result_context.add_line_span_to_context(\n                file_path, start_line, end_line, add_extra=False\n            )\n\n        return search_resul..."
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "FindCodeSnippet",
    "file": "find_code_snippet.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 94,
    "end_line": 119,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"I need to understand how the User class is structured in our authentication system. Let me find its definition.\",\n                action=FindCodeSnippetArgs(\n                    thoughts=\"To find the User class definition, I'll search for the exact class declaration line 'class User(BaseModel):'\",\n                    code_snippet=\"class User(BaseModel):\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"The system seems to use a default timeout value. I should check where DEFAULT_TIMEOUT is defined in the configuration.\",\n                action=FindCodeSnippetArgs(\n                    thoughts=\"To find the timeout configuration, I'll search for the exact variable declaration 'DEFAULT_TIMEOUT =' in config files\",\n                    code_snippet=\"DEFAULT_TIMEOUT =\",\n                    file_pattern=\"**/con..."
  },
  {
    "type": "function",
    "name": "validate_names",
    "class_name": "FindClassArgs",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 29,
    "end_line": 39,
    "code": "def validate_names(self) -> \"FindClassArgs\":\n        if not self.class_name.strip():\n            raise ValueError(\"class_name cannot be empty\")\n        # Extract just the class name if a fully qualified name is provided\n        if \".\" in self.class_name:\n            original_name = self.class_name\n            self.class_name = self.class_name.split(\".\")[-1]\n            logger.info(\n                f\"Using class name '{self.class_name}' from fully qualified name '{original_name}'\"\n            )\n        return self"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "FindClassArgs",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 44,
    "end_line": 48,
    "code": "def short_summary(self) -> str:\n        param_str = f\"class_name={self.class_name}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 54,
    "end_line": 58,
    "code": "def to_prompt(self):\n        prompt = f\"Searching for class: {self.args.class_name}\"\n        if self.args.file_pattern:\n            prompt += f\" in files matching the pattern: {self.args.file_pattern}\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "_search",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 60,
    "end_line": 66,
    "code": "def _search(self, args: FindClassArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.class_name} (file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_class(\n            args.class_name, file_pattern=args.file_pattern\n        )"
  },
  {
    "type": "function",
    "name": "_select_span_instructions",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 68,
    "end_line": 72,
    "code": "def _select_span_instructions(self, search_result: SearchCodeResponse) -> str:\n        return (\n            f\"Here's the class structure.\"\n            f\"Use the function ViewCode and specify the SpanIDs of the relevant functions to view them.\\n\"\n        )"
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 74,
    "end_line": 79,
    "code": "def _search_for_alternative_suggestion(\n        self, args: FindClassArgs\n    ) -> SearchCodeResponse:\n        if args.file_pattern:\n            return self._code_index.find_class(args.class_name, file_pattern=None)\n        return SearchCodeResponse()"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 82,
    "end_line": 89,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Identifier Correctness: Verify that the class name is accurate.\",\n            ]\n        )\n        return criteria"
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "FindClass",
    "file": "find_class.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 92,
    "end_line": 109,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"I need to see the implementation of the DatabaseManager class to understand how it handles transactions\",\n                action=FindClassArgs(\n                    thoughts=\"To examine how the DatabaseManager class handles transactions, we need to locate its implementation in the codebase.\",\n                    class_name=\"DatabaseManager\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"Show me the UserAuthentication class in the auth module\",\n                action=FindClassArgs(\n                    thoughts=\"Looking for the UserAuthentication class specifically in the authentication module.\",\n                    class_name=\"UserAuthentication\",\n                    file_pattern=\"auth/*.py\",\n                ),\n            ),\n        ]"
  },
  {
    "type": "function",
    "name": "validate_file_pattern",
    "class_name": "SearchBaseArgs",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 55,
    "end_line": 59,
    "code": "def validate_file_pattern(cls, v):\n        if v:\n            if \",\" in v:\n                raise ValueError(\"File pattern cannot contain commas\")\n        return v"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 115,
    "end_line": 124,
    "code": "def __init__(\n        self,\n        repository: Repository = None,\n        code_index: CodeIndex | None = None,\n        completion_model: CompletionModel = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository\n        self._code_index = code_index"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 126,
    "end_line": 216,
    "code": "def execute(\n        self,\n        args: SearchBaseArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the search action.\"\n            )\n\n        properties = {\"search_hits\": [], \"search_tokens\": 0}\n\n        search_result_context, alternative_suggestion = self._search_for_context(args)\n\n        if search_result_context.is_empty():\n            properties[\"fail_reason\"] = \"no_search_hits\"\n            return Observation(message=\"No search results found\", properties=properties)\n\n        properties[\"search_tokens\"] = search_result_context.context_size()\n        properties[\"search_hits\"] = search_result_context.model_dump(exclude_none=True)\n\n        completion = None\n\n        if (\n            search_result_context.span_count() == 1\n            and search_result_context.context_size() > self.max_identify_tokens\n        ):\n            logger.warning(..."
  },
  {
    "type": "function",
    "name": "_search_for_context",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 218,
    "end_line": 237,
    "code": "def _search_for_context(self, args: SearchBaseArgs) -> Tuple[FileContext, bool]:\n        alternative_suggestion = False\n        search_result = self._search(args)\n        if not search_result.hits:\n            search_result = self._search_for_alternative_suggestion(args)\n            alternative_suggestion = True\n            logger.info(\n                f\"{self.name}: No relevant search results found. Will use alternative suggestion with {search_result.hits} hits.\"\n            )\n\n        span_count = 0\n        search_result_context = FileContext(repo=self._repository)\n        for hit in search_result.hits:\n            span_count += len(hit.spans)\n            for span in hit.spans:\n                search_result_context.add_span_to_context(\n                    hit.file_path, span.span_id, add_extra=True\n                )\n\n        return search_result_context, alternative_suggestion"
  },
  {
    "type": "function",
    "name": "_select_span_instructions",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 239,
    "end_line": 243,
    "code": "def _select_span_instructions(self, search_result: SearchCodeResponse) -> str:\n        if not self.add_to_context:\n            return f\"Here's the search result with the first line of codes in each code block. Use ViewCode to view specific code sections. \"\n\n        return f\"The search result is too large. You must identify the relevant code sections in the search results to use them. \""
  },
  {
    "type": "function",
    "name": "_select_span_response_prompt",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 245,
    "end_line": 264,
    "code": "def _select_span_response_prompt(self, search_result: SearchCodeResponse) -> str:\n        search_result_context = FileContext(repo=self._repository)\n        for hit in search_result.hits:\n            for span in hit.spans:\n                search_result_context.add_span_to_context(\n                    hit.file_path, span.span_id, add_extra=False\n                )\n\n        search_result_str = search_result_context.create_prompt(\n            show_span_ids=False,\n            show_line_numbers=True,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"...\",\n            # only_signatures=True\n        )\n\n        prompt = self._select_span_instructions(search_result)\n        prompt += f\"\\n<search_results>\\n{search_result_str}\\n</search_result>\\n\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "_search",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 266,
    "end_line": 267,
    "code": "def _search(self, args: SearchBaseArgs) -> SearchCodeResponse:\n        raise NotImplementedError(\"Subclasses must implement this method.\")"
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 269,
    "end_line": 272,
    "code": "def _search_for_alternative_suggestion(\n        self, args: SearchBaseArgs\n    ) -> SearchCodeResponse:\n        return SearchCodeResponse()"
  },
  {
    "type": "function",
    "name": "_identify_code",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 274,
    "end_line": 352,
    "code": "def _identify_code(\n        self, args: SearchBaseArgs, search_result_ctx: FileContext\n    ) -> Tuple[IdentifiedSpans, Completion]:\n        search_result_str = search_result_ctx.create_prompt(\n            show_span_ids=True,\n            show_line_numbers=True,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"...\",\n            max_tokens=self.max_identify_prompt_tokens,\n        )\n\n        content = \"Search request:\"\n        content += f\"\\n{args.to_prompt()}\"\n\n        content += \"\\n\\nIdentify the relevant code sections in the search results to use them. \"\n        content += f\"\\n\\n<search_results>\\n{search_result_str}\\n</search_result>\\n\"\n        identify_message = ChatCompletionUserMessage(role=\"user\", content=content)\n\n        messages = [identify_message]\n        completion = None\n\n        MAX_RETRIES = 3\n        for retry_attempt in range(MAX_RETRIES):\n            completion_response = self.completion_model.create_comple..."
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 355,
    "end_line": 366,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        evaluation_criteria = super().get_evaluation_criteria(trajectory_length)\n        evaluation_criteria.extend(\n            [\n                \"Query Relevance: Evaluate if the search query or parameters are well-defined and likely to find relevant code.\",\n                \"Search Scope Appropriateness: Check if the file patterns and class/function names narrow down the search effectively.\",\n                \"Relevance of Search Results: Assess whether the search results are directly related to the problem and useful for making progress.\",\n                \"Size of Search Results: Ensure that the code context provided is appropriately sized—not too large to overwhelm nor too small to be unhelpful.\",\n            ]\n        )\n\n        return evaluation_criteria"
  },
  {
    "type": "function",
    "name": "get_reward_scale",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 369,
    "end_line": 429,
    "code": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        if trajectory_length <= 3:\n            return cls.generate_reward_scale_entries(\n                [\n                    (\n                        90,\n                        100,\n                        \"The search action is excellent, with well-defined parameters yielding only highly relevant results.\",\n                    ),\n                    (\n                        75,\n                        89,\n                        \"The search action is good, with reasonable parameters yielding relevant results.\",\n                    ),\n                    (\n                        25,\n                        74,\n                        \"The search action have issues with parameters or yields few or no relevant results.\",\n                    ),\n                    (\n                        0,\n                        24,\n                        \"The action is counterproductive, with search results that are entirel..."
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "SearchBaseAction",
    "file": "search_base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 432,
    "end_line": 438,
    "code": "def model_validate(cls, obj: Any) -> \"SearchBaseAction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            repository = obj.pop(\"repository\")\n            code_index = obj.pop(\"code_index\")\n            return cls(code_index=code_index, repository=repository, **obj)\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "answer",
    "class_name": "FinishArgs",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 33,
    "end_line": 34,
    "code": "def answer(self):\n        return self.answer"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FinishArgs",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 36,
    "end_line": 37,
    "code": "def to_prompt(self):\n        return f\"Provide Answer: {self.finish_reason}\""
  },
  {
    "type": "function",
    "name": "equals",
    "class_name": "FinishArgs",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 39,
    "end_line": 41,
    "code": "def equals(self, other: \"ActionArguments\") -> bool:\n        # Keep comparison simple for now, might need adjustment based on usage\n        return isinstance(other, FinishArgs) and self.finish_reason == other.finish_reason"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 47,
    "end_line": 53,
    "code": "def execute(\n        self,\n        args: FinishArgs,\n        file_context: FileContext | None = None, # Keep for potential future context use\n    ):\n        # Return the answer from FinishArgs\n        return Observation(message=args.answer, terminal=True)"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 56,
    "end_line": 64,
    "code": "def get_evaluation_criteria(cls, trajectory_length: int) -> List[str]:\n        # Adapted criteria for Code QA Answering\n        return [\n            \"**Answer Accuracy:** Evaluate the correctness of the provided code snippet or explanation. Does it accurately answer the user's query?\",\n            \"**Answer Completeness:** Assess if the answer provides all necessary information or code components required by the user's query. Are there missing imports, configurations, or steps?\",\n            \"**Relevance:** Verify that the answer directly addresses the user's specific question or request. Is the provided code/explanation relevant to the context?\",\n            \"**Clarity and Quality:** Evaluate the clarity, conciseness, and overall quality of the code and explanation. Is the code well-formatted and easy to understand? Is the explanation clear?\",\n            \"**Safety and Best Practices:** Check if the provided code follows general safety guidelines and best practices (e.g., avoiding obv..."
  },
  {
    "type": "function",
    "name": "get_reward_scale",
    "class_name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 67,
    "end_line": 107,
    "code": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        # Adapted reward scale for Code QA Answering\n        return cls.generate_reward_scale_entries(\n            [\n                (\n                    90,\n                    100,\n                    \"The answer is perfectly accurate, complete, directly relevant, clear, and follows best practices. It fully satisfies the user's query.\",\n                ),\n                (\n                    75,\n                    89,\n                    \"The answer is accurate and addresses the main aspects of the query, but might lack minor details, alternative approaches, or optimal clarity/formatting.\",\n                ),\n                (\n                    50,\n                    74,\n                    \"The answer is generally correct but is incomplete, misses some nuances of the query, or has minor inaccuracies or issues with clarity/best practices.\",\n                ),\n                (\n                    25,\n      ..."
  },
  {
    "type": "function",
    "name": "get_value_function_prompt",
    "class_name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 110,
    "end_line": 112,
    "code": "def get_value_function_prompt(cls) -> str:\n        # Adapted value function prompt for Code QA Answering\n        return \"\"\"Your role is to evaluate the proposed final answer generated by an AI agent in response to a user's code-related query. The goal is to ensure the answer is accurate, complete, relevant, and clear.\"\"\""
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "Finish",
    "file": "finish.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 115,
    "end_line": 139,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        # Adapted few-shot examples for Code QA Answering\n        return [\n            FewShotExample.create(\n                user_input=\"How do I read a file line by line in Python?\",\n                action=FinishArgs(\n                    answer=\"with open('file.txt', 'r') as file:\\n    for line in file:\\n        print(line.strip())\",\n                    thoughts=\"The provided Python code snippet correctly demonstrates reading a file line by line using a 'with open(...)' statement and a for loop, which is the standard and recommended way. It includes error handling implicitly via 'with'.\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"Explain the difference between 'let' and 'const' in JavaScript.\",\n                action=FinishArgs(\n                    answer=\"'let' allows you to declare variables that are limited in scope to the block, statement, or expression on which it is us..."
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "RejectArgs",
    "file": "reject.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 18,
    "end_line": 19,
    "code": "def to_prompt(self):\n        return f\"Reject with reason: {self.rejection_reason}\""
  },
  {
    "type": "function",
    "name": "equals",
    "class_name": "RejectArgs",
    "file": "reject.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 21,
    "end_line": 22,
    "code": "def equals(self, other: \"ActionArguments\") -> bool:\n        return isinstance(other, RejectArgs)"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "Reject",
    "file": "reject.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 28,
    "end_line": 33,
    "code": "def execute(\n        self,\n        args: RejectArgs,\n        file_context: FileContext | None = None,\n    ):\n        return Observation(message=args.rejection_reason, terminal=True)"
  },
  {
    "type": "function",
    "name": "get_name",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 24,
    "end_line": 26,
    "code": "def get_name(cls) -> str:\n        \"\"\"Returns the action name for the class based on Config title.\"\"\"\n        return str(getattr(cls.Config, \"title\", cls.__name__))"
  },
  {
    "type": "function",
    "name": "format_for_llm",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 28,
    "end_line": 30,
    "code": "def format_for_llm(self) -> str:\n        \"\"\"Format the action name for LLM consumption\"\"\"\n        return str(self.name)"
  },
  {
    "type": "function",
    "name": "format_name_for_llm",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 33,
    "end_line": 35,
    "code": "def format_name_for_llm(cls) -> str:\n        \"\"\"Format the class name for LLM consumption\"\"\"\n        return str(cls.get_name())"
  },
  {
    "type": "function",
    "name": "to_tool_call",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 37,
    "end_line": 40,
    "code": "def to_tool_call(self) -> ToolCall:\n        tool_input = self.model_dump()\n\n        return ToolCall(name=self.name, input=tool_input)"
  },
  {
    "type": "function",
    "name": "from_tool_call",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 43,
    "end_line": 44,
    "code": "def from_tool_call(cls, tool_args: dict[str, Any], tool_name: str | None = None):\n        return cls(**tool_args)"
  },
  {
    "type": "function",
    "name": "equals",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 46,
    "end_line": 49,
    "code": "def equals(self, other: \"ActionArguments\") -> bool:\n        return self.model_dump(exclude={\"thoughts\"}) == other.model_dump(\n            exclude={\"thoughts\"}\n        )"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 51,
    "end_line": 56,
    "code": "def to_prompt(self):\n        prompt = f\"Action: {self.name}\\n\"\n        prompt += \"\\n\".join(\n            [f\"  {k}: {v}\" for k, v in self.model_dump(exclude={\"thoughts\"}).items()]\n        )\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 58,
    "end_line": 59,
    "code": "def short_summary(self) -> str:\n        return f\"{self.name}()\""
  },
  {
    "type": "function",
    "name": "fix_thoughts",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 63,
    "end_line": 73,
    "code": "def fix_thoughts(cls, data: Any) -> Any:\n        \"\"\"Allow thoughts to be null.\"\"\"\n        if isinstance(data, dict):\n            if \"scratch_pad\" in data:\n                data[\"thoughts\"] = data[\"scratch_pad\"]\n                del data[\"scratch_pad\"]\n\n            if not data.get(\"thoughts\"):\n                data[\"thoughts\"] = \"\"\n\n        return data"
  },
  {
    "type": "function",
    "name": "fix_null_fields",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 77,
    "end_line": 84,
    "code": "def fix_null_fields(cls, data: Any) -> Any:\n        \"\"\"Allow thoughts to be null.\"\"\"\n        if isinstance(data, dict):\n            for key, value in data.items():\n                if value == \"null\":\n                    data[key] = None\n\n        return data"
  },
  {
    "type": "function",
    "name": "get_action_args",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 87,
    "end_line": 98,
    "code": "def get_action_args(cls, action_name: str) -> Type[\"ActionArguments\"]:\n        \"\"\"\n        Dynamically import and return the appropriate ActionArguments class for the given action.\n        \"\"\"\n        if not _action_args:\n            cls._load_action_args()\n\n        action_args = _action_args.get(action_name)\n        if action_args:\n            return action_args\n\n        raise ValueError(f\"Unknown action: {action_name}\")"
  },
  {
    "type": "function",
    "name": "_load_action_args",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 101,
    "end_line": 113,
    "code": "def _load_action_args(cls):\n        actions_package = importlib.import_module(\"moatless_qa.actions\")\n\n        for _, module_name, _ in pkgutil.iter_modules(actions_package.__path__):\n            full_module_name = f\"moatless_qa.actions.{module_name}\"\n            module = importlib.import_module(full_module_name)\n            for name, obj in module.__dict__.items():\n                if (\n                    isinstance(obj, type)\n                    and issubclass(obj, ActionArguments)\n                    and obj != ActionArguments\n                ):\n                    _action_args[name] = obj"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "ActionArguments",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 116,
    "end_line": 131,
    "code": "def model_validate(cls, obj: Any) -> \"ActionArguments\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            action_args_class_path = obj.pop(\"action_args_class\", None)\n            if (\n                action_args_class_path\n                == \"moatless_qa.actions.request_context.RequestMoreContextArgs\"\n            ):\n                action_args_class_path = \"moatless_qa.actions.view_code.ViewCodeArgs\"\n\n            if action_args_class_path:\n                module_name, class_name = action_args_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                action_args_class = getattr(module, class_name)\n                return action_args_class.model_validate(obj)\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "create",
    "class_name": "Observation",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 164,
    "end_line": 165,
    "code": "def create(cls, message: str, terminal: bool = False):\n        return cls(message=message, terminal=terminal)"
  },
  {
    "type": "function",
    "name": "create",
    "class_name": "FewShotExample",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 175,
    "end_line": 176,
    "code": "def create(cls, user_input: str, action: ActionArguments) -> \"FewShotExample\":\n        return cls(user_input=user_input, action=action)"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "ActionError",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 187,
    "end_line": 188,
    "code": "def to_prompt(self):\n        return f\"Error: {self.error}\""
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "RetryException",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 194,
    "end_line": 197,
    "code": "def __init__(self, message: str, action_args: ActionArguments):\n        super().__init__(message)\n        self.message = message\n        self.action_args = action_args"
  },
  {
    "type": "function",
    "name": "log_name",
    "class_name": "CodeSpan",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 38,
    "end_line": 47,
    "code": "def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "type": "function",
    "name": "log_name",
    "class_name": "FurtherViewCodeArgs",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 62,
    "end_line": 69,
    "code": "def log_name(self):\n        if len(self.files) == 1:\n            return f\"FurtherViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"FurtherViewCode(\" + \", \".join(logs) + \")\""
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FurtherViewCodeArgs",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 71,
    "end_line": 79,
    "code": "def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids:\n                prompt += f\"  Spans: {', '.join(file.span_ids)}\\n\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "FurtherViewCodeArgs",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 81,
    "end_line": 86,
    "code": "def short_summary(self) -> str:\n        param_strs = []\n        for file in self.files:\n            param_strs.append(f\"path={file.file_path}\")\n        param_str = \", \".join(param_strs)\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 94,
    "end_line": 101,
    "code": "def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 108,
    "end_line": 261,
    "code": "def execute(\n        self,\n        args: FurtherViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file_path not in grouped_files:\n                grouped_files[file_with_spans.file_path] = file_with_spans\n            else:\n                grouped_files[file_with_spans.file_path].span_ids.extend(\n                    file_with_spans.span_ids\n                )\n\n        # Validate all file spans before processing\n        for file_path, file_span in grouped_files.items():\n            logger.info(\n                f\"Processing file {file_path} with span_ids {file_span.span_ids}\"\n            )\n            file = file_co..."
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 263,
    "end_line": 264,
    "code": "def _search_for_alternative_suggestion(self, args: FurtherViewCodeArgs):\n        return None"
  },
  {
    "type": "function",
    "name": "_select_span_instructions",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 266,
    "end_line": 267,
    "code": "def _select_span_instructions(self, search_result) -> str:\n        return \"The requested code is too large. You must identify the most relevant code sections to view.\""
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 270,
    "end_line": 295,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"The authenticate method is called, but there is no implementation code for it in the current code.\",\n                action=FurtherViewCodeArgs(\n                    thoughts=\"To understand the authentication implementation, we need to examine the authenticate method within the AuthenticationService class.\",\n                    files=[\n                        CodeSpan(\n                            file_path=\"auth/service.py\",\n                            span_ids=[\"AuthenticationService.authenticate\"],\n                        )\n                    ],\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"Show me lines 50-75 of the database configuration file\",\n                action=FurtherViewCodeArgs(\n                    thoughts=\"To examine the database configuration settings, we'll look at the specified line r..."
  },
  {
    "type": "function",
    "name": "create_retry_message",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 297,
    "end_line": 319,
    "code": "def create_retry_message(self, file: ContextFile, message: str):\n        retry_message = f\"\\n\\nProblems when trying to find spans in {file.file_path}. \"\n        retry_message += message\n\n        hint = self.create_hint(file)\n        if hint:\n            retry_message += f\"\\n\\n{hint}\"\n\n        if file.module and file.span_ids:\n            search_result_context = FileContext(repo=self._repository)\n            search_result_context.add_file(file.file_path, show_all_spans=True)\n\n            search_result_str = search_result_context.create_prompt(\n                show_span_ids=False,\n                show_line_numbers=False,\n                exclude_comments=False,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"...\",\n                only_signatures=True,\n            )\n            retry_message += f\"\\n\\nHere's the code structure:\\n{search_result_str}\"\n\n        return retry_message"
  },
  {
    "type": "function",
    "name": "create_hint",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 321,
    "end_line": 325,
    "code": "def create_hint(self, file: ContextFile):\n        if \"test\" in file.file_path:\n            return \"If you want to write a new test method, start by adding one of the existing ones that might relevant for reference.\"\n\n        return None"
  },
  {
    "type": "function",
    "name": "span_id_list",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 327,
    "end_line": 331,
    "code": "def span_id_list(self, span_ids: set[str]) -> str:\n        list_str = \"\"\n        for span_id in span_ids:\n            list_str += f\" * {span_id}\\n\"\n        return list_str"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 334,
    "end_line": 341,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = [\n            \"Relevance of Requested Context: Ensure that the requested context is directly related to the problem and necessary for making progress.\",\n            \"Avoiding Hallucinations: Verify that the agent is requesting context for code that actually exists in the codebase.\",\n            \"Efficiency: Assess whether the agent is requesting an appropriate amount of context without overloading unnecessary information.\",\n            \"Appropriateness of Action: Evaluate if requesting more context is logical at this point in the problem-solving process.\",\n        ]\n        return criteria"
  },
  {
    "type": "function",
    "name": "get_reward_scale",
    "class_name": "FurtherViewCode",
    "file": "further_view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 344,
    "end_line": 371,
    "code": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The requested context is highly relevant, precise, and necessary for solving the problem; the agent avoids hallucinations.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The requested context is relevant and helpful, with minor issues in specificity or relevance.\",\n            ),\n            RewardScaleEntry(\n                min_value=25,\n                max_value=49,\n                description=\"The requested context is somewhat relevant but may include unnecessary information or lacks specificity.\",\n            ),\n            RewardScaleEntry(\n                min_value=0,\n                max_value=24,\n                description=\"The requested context has minimal relevance or includes excess..."
  },
  {
    "type": "function",
    "name": "log_name",
    "class_name": "CodeSpan",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 38,
    "end_line": 47,
    "code": "def log_name(self):\n        log = self.file_path\n\n        if self.start_line and self.end_line:\n            log += f\" {self.start_line}-{self.end_line}\"\n\n        if self.span_ids:\n            log += f\" {', '.join(self.span_ids)}\"\n\n        return log"
  },
  {
    "type": "function",
    "name": "log_name",
    "class_name": "ViewCodeArgs",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 62,
    "end_line": 69,
    "code": "def log_name(self):\n        if len(self.files) == 1:\n            return f\"ViewCode({self.files[0].log_name})\"\n        else:\n            logs = []\n            for i, file in enumerate(self.files):\n                logs.append(f\"{i}=[{file.log_name}]\")\n            return f\"ViewCode(\" + \", \".join(logs) + \")\""
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "ViewCodeArgs",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 71,
    "end_line": 79,
    "code": "def to_prompt(self):\n        prompt = \"Show the following code:\\n\"\n        for file in self.files:\n            prompt += f\"* {file.file_path}\\n\"\n            if file.start_line and file.end_line:\n                prompt += f\"  Lines: {file.start_line}-{file.end_line}\\n\"\n            if file.span_ids:\n                prompt += f\"  Spans: {', '.join(file.span_ids)}\\n\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "ViewCodeArgs",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 81,
    "end_line": 86,
    "code": "def short_summary(self) -> str:\n        param_strs = []\n        for file in self.files:\n            param_strs.append(f\"path={file.file_path}\")\n        param_str = \", \".join(param_strs)\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 94,
    "end_line": 101,
    "code": "def __init__(\n        self,\n        repository: Repository = None,\n        completion_model: CompletionModel | None = None,\n        **data,\n    ):\n        super().__init__(completion_model=completion_model, **data)\n        self._repository = repository"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 108,
    "end_line": 261,
    "code": "def execute(\n        self,\n        args: ViewCodeArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if file_context is None:\n            raise ValueError(\n                \"File context must be provided to execute the view action.\"\n            )\n\n        properties = {\"files\": {}}\n\n        # Group files by filepath and combine span_ids\n        grouped_files = {}\n        for file_with_spans in args.files:\n            if file_with_spans.file_path not in grouped_files:\n                grouped_files[file_with_spans.file_path] = file_with_spans\n            else:\n                grouped_files[file_with_spans.file_path].span_ids.extend(\n                    file_with_spans.span_ids\n                )\n\n        # Validate all file spans before processing\n        for file_path, file_span in grouped_files.items():\n            logger.info(\n                f\"Processing file {file_path} with span_ids {file_span.span_ids}\"\n            )\n            file = file_context.g..."
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 263,
    "end_line": 264,
    "code": "def _search_for_alternative_suggestion(self, args: ViewCodeArgs):\n        return None"
  },
  {
    "type": "function",
    "name": "_select_span_instructions",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 266,
    "end_line": 267,
    "code": "def _select_span_instructions(self, search_result) -> str:\n        return \"The requested code is too large. You must identify the most relevant code sections to view.\""
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 270,
    "end_line": 295,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Show me the implementation of the authenticate method in the AuthenticationService class\",\n                action=ViewCodeArgs(\n                    thoughts=\"To understand the authentication implementation, we need to examine the authenticate method within the AuthenticationService class.\",\n                    files=[\n                        CodeSpan(\n                            file_path=\"auth/service.py\",\n                            span_ids=[\"AuthenticationService.authenticate\"],\n                        )\n                    ],\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"Show me lines 50-75 of the database configuration file\",\n                action=ViewCodeArgs(\n                    thoughts=\"To examine the database configuration settings, we'll look at the specified line range in the config file...."
  },
  {
    "type": "function",
    "name": "create_retry_message",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 297,
    "end_line": 319,
    "code": "def create_retry_message(self, file: ContextFile, message: str):\n        retry_message = f\"\\n\\nProblems when trying to find spans in {file.file_path}. \"\n        retry_message += message\n\n        hint = self.create_hint(file)\n        if hint:\n            retry_message += f\"\\n\\n{hint}\"\n\n        if file.module and file.span_ids:\n            search_result_context = FileContext(repo=self._repository)\n            search_result_context.add_file(file.file_path, show_all_spans=True)\n\n            search_result_str = search_result_context.create_prompt(\n                show_span_ids=False,\n                show_line_numbers=False,\n                exclude_comments=False,\n                show_outcommented_code=True,\n                outcomment_code_comment=\"...\",\n                only_signatures=True,\n            )\n            retry_message += f\"\\n\\nHere's the code structure:\\n{search_result_str}\"\n\n        return retry_message"
  },
  {
    "type": "function",
    "name": "create_hint",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 321,
    "end_line": 325,
    "code": "def create_hint(self, file: ContextFile):\n        if \"test\" in file.file_path:\n            return \"If you want to write a new test method, start by adding one of the existing ones that might relevant for reference.\"\n\n        return None"
  },
  {
    "type": "function",
    "name": "span_id_list",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 327,
    "end_line": 331,
    "code": "def span_id_list(self, span_ids: set[str]) -> str:\n        list_str = \"\"\n        for span_id in span_ids:\n            list_str += f\" * {span_id}\\n\"\n        return list_str"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 334,
    "end_line": 341,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = [\n            \"Relevance of Requested Context: Ensure that the requested context is directly related to the problem and necessary for making progress.\",\n            \"Avoiding Hallucinations: Verify that the agent is requesting context for code that actually exists in the codebase.\",\n            \"Efficiency: Assess whether the agent is requesting an appropriate amount of context without overloading unnecessary information.\",\n            \"Appropriateness of Action: Evaluate if requesting more context is logical at this point in the problem-solving process.\",\n        ]\n        return criteria"
  },
  {
    "type": "function",
    "name": "get_reward_scale",
    "class_name": "ViewCode",
    "file": "view_code.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 344,
    "end_line": 371,
    "code": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The requested context is highly relevant, precise, and necessary for solving the problem; the agent avoids hallucinations.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The requested context is relevant and helpful, with minor issues in specificity or relevance.\",\n            ),\n            RewardScaleEntry(\n                min_value=25,\n                max_value=49,\n                description=\"The requested context is somewhat relevant but may include unnecessary information or lacks specificity.\",\n            ),\n            RewardScaleEntry(\n                min_value=0,\n                max_value=24,\n                description=\"The requested context has minimal relevance or includes excess..."
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 29,
    "end_line": 30,
    "code": "def __init__(self, **data):\n        super().__init__(**data)"
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 32,
    "end_line": 42,
    "code": "def execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        \"\"\"\n        Execute the action.\n        \"\"\"\n\n        message = self._execute(args, file_context=file_context)\n        return Observation.create(message)"
  },
  {
    "type": "function",
    "name": "_execute",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 44,
    "end_line": 52,
    "code": "def _execute(\n        self,\n        args: ActionArguments,\n        file_context: FileContext | None = None,\n    ) -> str | None:\n        \"\"\"\n        Execute the action and return the updated FileContext.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")"
  },
  {
    "type": "function",
    "name": "name",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 55,
    "end_line": 57,
    "code": "def name(self) -> str:\n        \"\"\"Returns the name of the action class as a st ring.\"\"\"\n        return self.__class__.__name__"
  },
  {
    "type": "function",
    "name": "get_name",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 60,
    "end_line": 62,
    "code": "def get_name(cls) -> str:\n        \"\"\"Returns the name of the action class as a string.\"\"\"\n        return cls.__name__"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 65,
    "end_line": 77,
    "code": "def get_evaluation_criteria(cls, trajectory_length: int | None = None) -> List[str]:\n        if trajectory_length < 3:\n            return [\n                \"Exploratory Actions: Recognize that initial searches and information-gathering steps are essential and should not be heavily penalized if they don't yield immediate results.\",\n                \"Appropriateness of Action: Evaluate if the action is logical given the agent's current knowledge and the early stage of problem-solving.\",\n            ]\n\n        else:\n            return [\n                \"Solution Quality: Assess the logical changes, contextual fit, and overall improvement without introducing new issues.\",\n                \"Progress Assessment: Evaluate the agent's awareness of solution history, detection of repetitive actions, and planned next steps.\",\n                \"Repetitive or Redundant Actions: Detect if the agent is repeating the same unsuccessful or redundant actions without making progress. Pay close attention to t..."
  },
  {
    "type": "function",
    "name": "get_reward_scale",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 80,
    "end_line": 112,
    "code": "def get_reward_scale(cls, trajectory_length) -> List[RewardScaleEntry]:\n        return [\n            RewardScaleEntry(\n                min_value=75,\n                max_value=100,\n                description=\"The action significantly advances the solution.\",\n            ),\n            RewardScaleEntry(\n                min_value=50,\n                max_value=74,\n                description=\"The action contributes positively towards solving the problem.\",\n            ),\n            RewardScaleEntry(\n                min_value=25,\n                max_value=49,\n                description=\"The action is acceptable but may have some issues.\",\n            ),\n            RewardScaleEntry(\n                min_value=0,\n                max_value=24,\n                description=\"The action has minimal impact or minor negative consequences.\",\n            ),\n            RewardScaleEntry(\n                min_value=-49,\n                max_value=-1,\n                description=\"The code change is inap..."
  },
  {
    "type": "function",
    "name": "generate_reward_scale_entries",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 115,
    "end_line": 130,
    "code": "def generate_reward_scale_entries(\n        descriptions: List[Tuple[int, int, str]],\n    ) -> List[RewardScaleEntry]:\n        \"\"\"\n        Generate a list of RewardScaleEntry objects based on the provided descriptions.\n\n        Args:\n            descriptions: A list of tuples, each containing (min_value, max_value, description)\n\n        Returns:\n            A list of RewardScaleEntry objects\n        \"\"\"\n        return [\n            RewardScaleEntry(min_value=min_val, max_value=max_val, description=desc)\n            for min_val, max_val, desc in descriptions\n        ]"
  },
  {
    "type": "function",
    "name": "get_reward_range",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 133,
    "end_line": 146,
    "code": "def get_reward_range(cls, trajectory_length: int) -> Tuple[int, int]:\n        \"\"\"\n        Get the minimum and maximum reward values for this action.\n\n        Args:\n            trajectory_length: The length of the current trajectory\n\n        Returns:\n            A tuple containing the minimum and maximum reward values\n        \"\"\"\n        reward_scale = cls.get_reward_scale(trajectory_length)\n        min_reward = min(entry.min_value for entry in reward_scale)\n        max_reward = max(entry.max_value for entry in reward_scale)\n        return min_reward, max_reward"
  },
  {
    "type": "function",
    "name": "get_value_function_prompt",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 149,
    "end_line": 161,
    "code": "def get_value_function_prompt(cls) -> str:\n        \"\"\"\n        Get the base prompt for the value function.\n        This method can be overridden in subclasses to provide action-specific prompts.\n        \"\"\"\n        return \"\"\"Your role is to evaluate the **last executed action** of the search tree that our AI agents are traversing, to help us determine the best trajectory to solve a programming issue. The agent is responsible for identifying and modifying the correct file(s) in response to the problem statement.\n\nImportant: While line numbers may be referenced in the initial problem description, they can shift as changes are made to the file. Focus on whether the agent is modifying the correct logical parts of the code, rather than strictly matching the initially mentioned line numbers. What matters is that the right section of code is being modified, even if its current line number differs from what was originally specified.\n\nAt this stage, the agent is still working on the solution. Y..."
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 164,
    "end_line": 169,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        \"\"\"\n        Returns a list of few-shot examples specific to this action.\n        Override this method in subclasses to provide custom examples.\n        \"\"\"\n        return []"
  },
  {
    "type": "function",
    "name": "get_action_by_args_class",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 172,
    "end_line": 197,
    "code": "def get_action_by_args_class(\n        cls, args_class: Type[ActionArguments]\n    ) -> Optional[Type[\"Action\"]]:\n        \"\"\"\n        Get the Action subclass corresponding to the given ActionArguments subclass.\n\n        Args:\n            args_class: The ActionArguments subclass to look up.\n\n        Returns:\n            The Action subclass if found, None otherwise.\n        \"\"\"\n\n        def search_subclasses(current_class):\n            if (\n                hasattr(current_class, \"args_schema\")\n                and current_class.args_schema == args_class\n            ):\n                return current_class\n            for subclass in current_class.__subclasses__():\n                result = search_subclasses(subclass)\n                if result:\n                    return result\n            return None\n\n        return search_subclasses(cls)"
  },
  {
    "type": "function",
    "name": "get_action_by_name",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 200,
    "end_line": 211,
    "code": "def get_action_by_name(cls, action_name: str) -> Type[\"Action\"]:\n        \"\"\"\n        Dynamically import and return the appropriate Action class for the given action name.\n        \"\"\"\n        if not _actions:\n            cls._load_actions()\n\n        action = _actions.get(action_name)\n        if action:\n            return action\n\n        raise ValueError(f\"Unknown action: {action_name}\")"
  },
  {
    "type": "function",
    "name": "_load_actions",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 214,
    "end_line": 222,
    "code": "def _load_actions(cls):\n        actions_package = importlib.import_module(\"moatless_qa.actions\")\n\n        for _, module_name, _ in pkgutil.iter_modules(actions_package.__path__):\n            full_module_name = f\"moatless_qa.actions.{module_name}\"\n            module = importlib.import_module(full_module_name)\n            for name, obj in module.__dict__.items():\n                if isinstance(obj, type) and issubclass(obj, Action) and obj != Action:\n                    _actions[name] = obj"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 225,
    "end_line": 250,
    "code": "def model_validate(\n        cls,\n        obj: Any,\n        repository: Repository = None,\n        # runtime: Any = None,\n        code_index: CodeIndex = None,\n    ) -> \"Action\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            action_class_path = obj.pop(\"action_class\", None)\n\n            if action_class_path:\n                module_name, class_name = action_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                action_class = getattr(module, class_name)\n\n                if repository and hasattr(action_class, \"_repository\"):\n                    obj[\"repository\"] = repository\n                if code_index and hasattr(action_class, \"_code_index\"):\n                    obj[\"code_index\"] = code_index\n                # if runtime and hasattr(action_class, \"_runtime\"):\n                #   obj[\"runtime\"] = runtime\n\n                return action_class(**obj)\n\n        return cls(**obj)"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "Action",
    "file": "action.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 252,
    "end_line": 255,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"action_class\"] = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        return dump"
  },
  {
    "type": "function",
    "name": "validate_snippet",
    "class_name": "FindCalledObjectArgs",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 41,
    "end_line": 44,
    "code": "def validate_snippet(self) -> \"FindCalledObjectArgs\":\n        if not self.called_object.strip():\n            raise ValueError(\"called object cannot be empty\")\n        return self"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FindCalledObjectArgs",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 46,
    "end_line": 50,
    "code": "def to_prompt(self):\n        prompt = f\"Searching for called object: {self.called_object}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "FindCalledObjectArgs",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 52,
    "end_line": 56,
    "code": "def short_summary(self) -> str:\n        param_str = f\"called_object={self.called_object}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "_search_for_context",
    "class_name": "FindCalledObject",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 67,
    "end_line": 94,
    "code": "def _search_for_context(\n        self, args: FindCalledObjectArgs\n    ) -> Tuple[FileContext, bool]:\n        logger.info(\n            f\"{self.name}: {args.called_object} (file_pattern: {args.file_pattern})\"\n        )\n\n        matches = self._repository.find_exact_matches(\n            search_text=args.called_object, file_pattern=args.file_pattern\n        )\n\n        if args.file_pattern and len(matches) > 1:\n            matches = [\n                (file_path, line_num)\n                for file_path, line_num in matches\n                if fnmatch(file_path, args.file_pattern)\n            ]\n\n        search_result_context = FileContext(repo=self._repository)\n        for file_path, start_line in matches[: self.max_hits]:\n            num_lines = len(args.called_object.splitlines())\n            end_line = start_line + num_lines - 1\n\n            search_result_context.add_line_span_to_context(\n                file_path, start_line, end_line, add_extra=False\n            )\n\n        return search_r..."
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "FindCalledObject",
    "file": "find_called_objects.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 97,
    "end_line": 130,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input='''The user's location is empty, but the location is update by the profile and I need to find the object associated with the user's location that is called in the code but not implemented in the code.''',\n                action=FindCalledObjectArgs(\n                    thoughts=\"The user's location is defined via user.update_location(profile.location), profile is called, I need to look further into the 'class Profile'\",\n                    called_object=\"class Profile\",\n                    file_pattern=\"**/profile.py\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"This code seems to use DEFAULT_TIMEOUT variable to initialize the system. However, DEFAULT_TIMEOUT doesn't seem to be defined in the current code, I need to search further for DEFAULT_TIMEOUT.\",\n                action=FindCalledObjectArgs(\n   ..."
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "ListFilesArgs",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 24,
    "end_line": 25,
    "code": "def to_prompt(self):\n        return f\"List contents of directory: {self.directory or '(root)'}\""
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "ListFilesArgs",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 27,
    "end_line": 29,
    "code": "def short_summary(self) -> str:\n        param_str = f\"directory={self.directory}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "execute",
    "class_name": "ListFiles",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 35,
    "end_line": 73,
    "code": "def execute(\n        self,\n        args: ListFilesArgs,\n        file_context: FileContext | None = None,\n    ) -> Observation:\n        if not file_context._repo:\n            raise RuntimeError(\"Repository not available for listing files.\")\n\n        try:\n            result = file_context._repo.list_directory(args.directory)\n\n            message = f\"Contents of directory '{args.directory or '(root)'}'\\n\\n\"\n\n            if result[\"directories\"]:\n                message += \"Directories:\\n\"\n                for directory in result[\"directories\"]:\n                    message += f\"📁 {directory}\\n\"\n                message += \"\\n\"\n\n            if result[\"files\"]:\n                message += \"Files:\\n\"\n                for file in result[\"files\"]:\n                    message += f\"📄 {file}\\n\"\n\n            if not result[\"directories\"] and not result[\"files\"]:\n                message += \"Directory is empty or does not exist.\"\n\n            return Observation(\n                message=message,\n          ..."
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "ListFiles",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 76,
    "end_line": 81,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        return [\n            \"Directory Path Validity: Ensure the requested directory path exists and is valid.\",\n            \"Usefulness: Assess if listing the directory contents is helpful for the current task.\",\n            \"Efficiency: Evaluate if the action is being used at an appropriate time in the workflow.\",\n        ]"
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "ListFiles",
    "file": "list_files.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 84,
    "end_line": 100,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Show me what files are in the tests directory\",\n                action=ListFilesArgs(\n                    thoughts=\"I'll list the contents of the tests directory to see what test files are available.\",\n                    directory=\"tests\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"What files are in the root directory?\",\n                action=ListFilesArgs(\n                    thoughts=\"I'll list the contents of the root directory to see the project structure.\",\n                    directory=\"\",\n                ),\n            ),\n        ]"
  },
  {
    "type": "function",
    "name": "_identify_code",
    "class_name": "IdentifyMixin",
    "file": "identify_mixin.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 35,
    "end_line": 123,
    "code": "def _identify_code(\n        self, args, view_context: FileContext, max_tokens: int\n    ) -> Tuple[FileContext, Completion]:\n        \"\"\"Identify relevant code sections in a large context.\n\n        Args:\n            args: The arguments containing the request information\n            view_context: The context containing the code to identify from\n            max_tokens: The maximum number of tokens allowed in the result\n\n        Returns:\n            A tuple of (identified_context, completion)\n        \"\"\"\n        code_str = view_context.create_prompt(\n            show_span_ids=True,\n            show_line_numbers=True,\n            exclude_comments=False,\n            show_outcommented_code=True,\n            outcomment_code_comment=\"...\",\n            max_tokens=self.max_identify_prompt_tokens,\n        )\n\n        content = \"Code request:\"\n        content += f\"\\n{args.to_prompt()}\"\n\n        content += \"\\n\\nIdentify the relevant code sections to view. \"\n        content += f\"\\n\\n<code>\\n{code_str}\\..."
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "SemanticSearchArgs",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 37,
    "end_line": 41,
    "code": "def to_prompt(self):\n        prompt = f\"Searching for code using the query: {self.query}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "validate_query",
    "class_name": "SemanticSearchArgs",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 44,
    "end_line": 47,
    "code": "def validate_query(self) -> \"SemanticSearchArgs\":\n        if not self.query.strip():\n            raise ValueError(\"query cannot be empty\")\n        return self"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "SemanticSearchArgs",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 49,
    "end_line": 53,
    "code": "def short_summary(self) -> str:\n        param_str = f\"query={self.query[:20]}, category={self.category}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "_search",
    "class_name": "SemanticSearch",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 59,
    "end_line": 65,
    "code": "def _search(self, args: SemanticSearchArgs) -> SearchCodeResponse:\n        return self._code_index.semantic_search(\n            args.query,\n            file_pattern=args.file_pattern,\n            max_results=self.max_hits,\n            category=args.category,\n        )"
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "SemanticSearch",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 67,
    "end_line": 77,
    "code": "def _search_for_alternative_suggestion(\n        self, args: SemanticSearchArgs\n    ) -> SearchCodeResponse:\n        if args.file_pattern:\n            return self._code_index.semantic_search(\n                args.query,\n                max_results=self.max_hits,\n                category=args.category,\n            )\n\n        return SearchCodeResponse()"
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "SemanticSearch",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 80,
    "end_line": 88,
    "code": "def get_evaluation_criteria(cls, trajectory_length: int | None = None) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Query Relevance: Evaluate if the search query is well-defined and likely to find relevant code.\",\n                \"Category Appropriateness: Assess if the category (implementation or test) aligns with the search intent.\",\n            ]\n        )\n        return criteria"
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "SemanticSearch",
    "file": "semantic_search.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 91,
    "end_line": 110,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Find all implementations of database connection pooling in our codebase\",\n                action=SemanticSearchArgs(\n                    thoughts=\"To find implementations of database connection pooling, we should search for code related to managing database connections efficiently. This might include classes or functions that handle connection creation, reuse, and management.\",\n                    query=\"database connection pooling implementation\",\n                    category=\"implementation\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"We need to find all test cases related to user authentication in our test suite\",\n                action=SemanticSearchArgs(\n                    thoughts=\"To find test cases related to user authentication, we should search for test files that contain assertions and s..."
  },
  {
    "type": "function",
    "name": "validate_names",
    "class_name": "FindFunctionArgs",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 31,
    "end_line": 36,
    "code": "def validate_names(self) -> \"FindFunctionArgs\":\n        if not self.function_name.strip():\n            raise ValueError(\"function_name cannot be empty\")\n        if self.class_name is not None and not self.class_name.strip():\n            raise ValueError(\"class_name must be None or non-empty\")\n        return self"
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "FindFunctionArgs",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 41,
    "end_line": 47,
    "code": "def to_prompt(self):\n        prompt = f\"Searching for function: {self.function_name}\"\n        if self.class_name:\n            prompt += f\" in class: {self.class_name}\"\n        if self.file_pattern:\n            prompt += f\" in files matching the pattern: {self.file_pattern}\"\n        return prompt"
  },
  {
    "type": "function",
    "name": "short_summary",
    "class_name": "FindFunctionArgs",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 49,
    "end_line": 55,
    "code": "def short_summary(self) -> str:\n        param_str = f\"function_name={self.function_name}\"\n        if self.file_pattern:\n            param_str += f\", file_pattern={self.file_pattern}\"\n        if self.class_name:\n            param_str += f\", class_name={self.class_name}\"\n        return f\"{self.name}({param_str})\""
  },
  {
    "type": "function",
    "name": "_search",
    "class_name": "FindFunction",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 61,
    "end_line": 69,
    "code": "def _search(self, args: FindFunctionArgs) -> SearchCodeResponse:\n        logger.info(\n            f\"{self.name}: {args.function_name} (class_name: {args.class_name}, file_pattern: {args.file_pattern})\"\n        )\n        return self._code_index.find_function(\n            args.function_name,\n            class_name=args.class_name,\n            file_pattern=args.file_pattern,\n        )"
  },
  {
    "type": "function",
    "name": "_search_for_alternative_suggestion",
    "class_name": "FindFunction",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 71,
    "end_line": 109,
    "code": "def _search_for_alternative_suggestion(\n        self, args: FindFunctionArgs\n    ) -> SearchCodeResponse:\n        \"\"\"Return methods in the same class or other methods in same file with the method name the method in class is not found.\"\"\"\n\n        if args.class_name and args.file_pattern:\n            file = self._repository.get_file(args.file_pattern)\n\n            span_ids = []\n            if file and file.module:\n                class_block = file.module.find_by_identifier(args.class_name)\n                if class_block and class_block.type == CodeBlockType.CLASS:\n                    function_blocks = class_block.find_blocks_with_type(\n                        CodeBlockType.FUNCTION\n                    )\n                    for function_block in function_blocks:\n                        span_ids.append(function_block.belongs_to_span.span_id)\n\n                function_blocks = file.module.find_blocks_with_identifier(\n                    args.function_name\n                )\n               ..."
  },
  {
    "type": "function",
    "name": "get_evaluation_criteria",
    "class_name": "FindFunction",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 112,
    "end_line": 120,
    "code": "def get_evaluation_criteria(cls, trajectory_length) -> List[str]:\n        criteria = super().get_evaluation_criteria(trajectory_length)\n        criteria.extend(\n            [\n                \"Function Identifier Accuracy: Ensure that the function name is correctly specified.\",\n                \"Class Name Appropriateness: Verify that the class names, if any, are appropriate.\",\n            ]\n        )\n        return criteria"
  },
  {
    "type": "function",
    "name": "get_few_shot_examples",
    "class_name": "FindFunction",
    "file": "find_function.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/actions",
    "start_line": 123,
    "end_line": 141,
    "code": "def get_few_shot_examples(cls) -> List[FewShotExample]:\n        return [\n            FewShotExample.create(\n                user_input=\"Find the calculate_interest function in our financial module to review its logic\",\n                action=FindFunctionArgs(\n                    thoughts=\"To review the logic of the calculate_interest function, we need to locate its implementation in the financial module.\",\n                    function_name=\"calculate_interest\",\n                    file_pattern=\"financial/**/*.py\",\n                ),\n            ),\n            FewShotExample.create(\n                user_input=\"Show me the validate_token method in the JWTAuthenticator class\",\n                action=FindFunctionArgs(\n                    thoughts=\"Looking for the validate_token method specifically within the JWTAuthenticator class to examine the token validation logic.\",\n                    function_name=\"validate_token\",\n                    class_name=\"JWTAuthenticator\",\n                )..."
  },
  {
    "type": "function",
    "name": "create",
    "class_name": "CodeQAAgent",
    "file": "code_qa_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 39,
    "end_line": 123,
    "code": "def create(\n        cls,\n        repository: Repository,\n        completion_model: CompletionModel,\n        preset_actions: List[Action] | None = None,\n        code_index: CodeIndex | None = None,\n        edit_completion_model: CompletionModel | None = None,\n        message_history_type: MessageHistoryType | None = None,\n        thoughts_in_action: bool = False,\n        **kwargs,\n    ):\n        # Clone the completion model to ensure we have our own instance\n        completion_model = completion_model.clone()\n\n        if message_history_type is None:\n            if completion_model.response_format == LLMResponseFormat.TOOLS:\n                message_history_type = MessageHistoryType.MESSAGES\n            else:\n                message_history_type = MessageHistoryType.REACT\n\n        action_completion_format = completion_model.response_format\n        if action_completion_format != LLMResponseFormat.TOOLS:\n            logger.info(\n                \"Default to JSON as Response format for actio..."
  },
  {
    "type": "function",
    "name": "create_base_actions",
    "class_name": null,
    "file": "code_qa_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 126,
    "end_line": 154,
    "code": "def create_base_actions(\n    repository: Repository,\n    code_index: CodeIndex | None = None,\n    completion_model: CompletionModel | None = None,\n) -> List[Action]:\n    \"\"\"Create the common base actions used across all action creators.\"\"\"\n    return [\n        SemanticSearch(\n            code_index=code_index,\n            repository=repository,\n            completion_model=completion_model,\n        ),\n        FindClass(\n            code_index=code_index,\n            repository=repository,\n            completion_model=completion_model,\n        ),\n        FindFunction(\n            code_index=code_index,\n            repository=repository,\n            completion_model=completion_model,\n        ),\n        FindCodeSnippet(\n            code_index=code_index,\n            repository=repository,\n            completion_model=completion_model,\n        ),\n        ViewCode(repository=repository, completion_model=completion_model),\n    ]"
  },
  {
    "type": "function",
    "name": "create_all_actions",
    "class_name": null,
    "file": "code_qa_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 157,
    "end_line": 164,
    "code": "def create_all_actions(\n    repository: Repository,\n    code_index: CodeIndex | None = None,\n    completion_model: CompletionModel | None = None,\n) -> List[Action]:\n    actions = create_base_actions(repository, code_index, completion_model)\n    actions.append(Finish())\n    return actions"
  },
  {
    "type": "function",
    "name": "__eq__",
    "class_name": "AgentSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 28,
    "end_line": 36,
    "code": "def __eq__(self, other):\n        if not isinstance(other, AgentSettings):\n            return False\n        return (\n            self.completion_model == other.completion_model\n            and self.system_prompt == other.system_prompt\n            and self.actions == other.actions\n            and self.message_history_type == other.message_history_type\n        )"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "AgentSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 38,
    "end_line": 41,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"message_history_type\"] = self.message_history_type.value\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "AgentSettings",
    "file": "settings.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 44,
    "end_line": 51,
    "code": "def model_validate(cls, obj: Any) -> \"AgentSettings\":\n        if isinstance(obj, dict):\n            if \"message_history_type\" in obj:\n                obj[\"message_history_type\"] = MessageHistoryType(\n                    obj[\"message_history_type\"]\n                )\n\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "generate_workflow_prompt",
    "class_name": null,
    "file": "code_qa_prompts.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 109,
    "end_line": 173,
    "code": "def generate_workflow_prompt(actions) -> str:\n    \"\"\"Generate the workflow prompt based on available actions.\"\"\"\n    search_actions = []\n    other_actions = []\n\n    # Define search action descriptions\n    search_descriptions = {\n        \"FindClass\": \"Search for class definitions by class name\",\n        \"FindFunction\": \"Search for function definitions by function name\",\n        \"FindCodeSnippet\": \"Search for specific code patterns or text\",\n        \"SemanticSearch\": \"Search code by semantic meaning and natural language description\",\n        \"FindCalledObject\": \"Search code for the objects that are referenced in the current code but whose implementation has not yet been found\",\n    }\n\n    # Define modify action descriptions\n\n    for action in actions:\n        action_name = action.__class__.__name__\n        if action_name in search_descriptions:\n            search_actions.append((action_name, search_descriptions[action_name]))\n        elif action_name not in [\"Finish\", \"Reject\", \"RunTests..."
  },
  {
    "type": "function",
    "name": "generate_guideline_prompt",
    "class_name": null,
    "file": "code_qa_prompts.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 178,
    "end_line": 204,
    "code": "def generate_guideline_prompt() -> str:\n    prompt = \"\"\"\n# Important Guidelines\n\n * **Focus on the Specific Question**\n  - Answer the question exactly as asked, based on the code in the repository.\n  - Provide complete and accurate information.\n  - Do not make assumptions about code you haven't seen.\n\n * **Code Context and Information**\n   - Base your answer only on code you can see through searches and ViewCode actions.\n   - If you need to examine more code to provide a complete answer, use ViewCode to see it.\n   - Reference specific parts of the code in your answer for clarity.\"\"\"\n\n    prompt += \"\"\"\n\n * **Task Completion**\n   - Finish the task only when you have gathered sufficient information to provide a complete and accurate answer.\n   - Cite specific evidence from the code to support your answer.\n   - Make sure you've explored all relevant parts of the codebase before formulating your final answer.\n\n * **State Management**\n   - Keep a detailed record of all code sections you have..."
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 44,
    "end_line": 61,
    "code": "def __init__(\n        self,\n        completion: CompletionModel,\n        system_prompt: str | None = None,\n        actions: List[Action] | None = None,\n        message_generator: MessageHistoryGenerator | None = None,\n        **data,\n    ):\n        actions = actions or []\n        message_generator = message_generator or MessageHistoryGenerator()\n        super().__init__(\n            actions=actions,\n            system_prompt=system_prompt,\n            message_generator=message_generator,\n            **data,\n        )\n        self.set_actions(actions)\n        self._completion = completion"
  },
  {
    "type": "function",
    "name": "from_agent_settings",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 64,
    "end_line": 78,
    "code": "def from_agent_settings(\n        cls, agent_settings: AgentSettings, actions: List[Action] | None = None\n    ):\n        if agent_settings.actions:\n            actions = [\n                action\n                for action in actions\n                if action.__class__.__name__ in agent_settings.actions\n            ]\n\n        return cls(\n            completion=agent_settings.completion_model,\n            system_prompt=agent_settings.system_prompt,\n            actions=actions,\n        )"
  },
  {
    "type": "function",
    "name": "set_actions",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 80,
    "end_line": 82,
    "code": "def set_actions(self, actions: List[Action]):\n        self.actions = actions\n        self._action_map = {action.args_schema: action for action in actions}"
  },
  {
    "type": "function",
    "name": "verify_actions",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 85,
    "end_line": 95,
    "code": "def verify_actions(self) -> \"ActionAgent\":\n        for action in self.actions:\n            if not isinstance(action, Action):\n                raise ValidationError(\n                    f\"Invalid action type: {type(action)}. Expected Action subclass.\"\n                )\n            if not hasattr(action, \"args_schema\"):\n                raise ValidationError(\n                    f\"Action {action.__class__.__name__} is missing args_schema attribute\"\n                )\n        return self"
  },
  {
    "type": "function",
    "name": "run",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 97,
    "end_line": 163,
    "code": "def run(self, node: Node, experience):\n        \"\"\"Run the agent on a node to generate and execute an action.\"\"\"\n\n        if node.action:\n            logger.info(f\"Node{node.node_id}: Resetting node\")\n            node.reset()\n\n        node.possible_actions = [action.name for action in self.actions]\n        system_prompt = self.generate_system_prompt()\n        action_args = [action.args_schema for action in self.actions]\n\n        messages = self.message_generator.generate(node)\n        # add experience\n        if experience:\n            messages.append({'role': 'user',  'content': [{'type': 'text',\n                                                           'text': experience}]})\n        \n        logger.info(f\"Node{node.node_id}: Build action with {len(messages)} messages\")\n        try:\n            completion_response = self._completion.create_completion(\n                messages, system_prompt=system_prompt, response_model=action_args\n            )\n            print('Response Structured ..."
  },
  {
    "type": "function",
    "name": "_execute",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 165,
    "end_line": 202,
    "code": "def _execute(self, node: Node, action_step: ActionStep):\n        action = self._action_map.get(type(action_step.action))\n        if not action:\n            logger.error(\n                f\"Node{node.node_id}: Action {node.action.name} not found in action map. \"\n                f\"Available actions: {self._action_map.keys()}\"\n            )\n            raise RuntimeError(f\"Action {type(node.action)} not found in action map.\")\n\n        try:\n            action_step.observation = action.execute(\n                action_step.action, node.file_context\n            )\n            if not action_step.observation:\n                print(\n                    f\"Node{node.node_id}: Action {action_step.action.name} returned no observation\"\n                )\n            else:\n                print('Observation: ', action_step.observation)\n                node.terminal = action_step.observation.terminal\n                if action_step.observation.execution_completion:\n                    action_step.completio..."
  },
  {
    "type": "function",
    "name": "generate_system_prompt",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 204,
    "end_line": 214,
    "code": "def generate_system_prompt(self) -> str:\n        \"\"\"Generate a system prompt for the agent.\"\"\"\n\n        system_prompt = self.system_prompt\n        if self.use_few_shots:\n            system_prompt += \"\\n\\n\" + self.generate_few_shots()\n        \n        system_prompt+=f\"\\n{RESPONSE_FORMAT}\"\n        \n\n        return system_prompt"
  },
  {
    "type": "function",
    "name": "generate_few_shots",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 216,
    "end_line": 262,
    "code": "def generate_few_shots(self) -> str:\n        few_shot_examples = []\n        for action in self.actions:\n            examples = action.get_few_shot_examples()\n            if examples:\n                few_shot_examples.extend(examples)\n\n        prompt = \"\"\n        if few_shot_examples:\n            prompt += \"\\n\\n# Examples\\nHere are some examples of how to use the available actions:\\n\\n\"\n            for i, example in enumerate(few_shot_examples):\n                if self.completion.response_format == LLMResponseFormat.REACT:\n                    prompt += f\"\\n**Example {i + 1}**\"\n                    action_data = example.action.model_dump()\n                    thoughts = action_data.pop(\"thoughts\", \"\")\n\n                    # Use standard JSON format for all actions\n                    prompt += (\n                        f\"\\nTask: {example.user_input}\"\n                        f\"\\nThought: {thoughts}\\n\"\n                        f\"Action: {str(example.action.name)}\\n\"\n                        f..."
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 264,
    "end_line": 271,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion\"] = self._completion.model_dump(**kwargs)\n        dump[\"actions\"] = []\n        dump[\"agent_class\"] = f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        for action in self.actions:\n            dump[\"actions\"].append(action.model_dump(**kwargs))\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 274,
    "end_line": 321,
    "code": "def model_validate(\n        cls,\n        obj: Any,\n        repository: Repository = None,\n        runtime: Any = None,\n        code_index: CodeIndex = None,\n    ) -> \"ActionAgent\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion\", None)\n            agent_class_path = obj.pop(\"agent_class\", None)\n\n            message_generator_data = obj.get(\"message_generator\", {})\n            if message_generator_data:\n                obj[\"message_generator\"] = MessageHistoryGenerator.model_validate(\n                    message_generator_data\n                )\n\n            if completion_data:\n                obj[\"completion\"] = CompletionModel.model_validate(completion_data)\n            else:\n                obj[\"completion\"] = None\n\n            if repository:\n                obj[\"actions\"] = [\n                    Action.model_validate(\n                        action_data,\n                        repository=repository,\n                  ..."
  },
  {
    "type": "function",
    "name": "from_dict",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 324,
    "end_line": 363,
    "code": "def from_dict(\n        cls,\n        data: Dict[str, Any],\n        repository: Repository | None = None,\n        code_index: CodeIndex | None = None,\n        runtime: Any | None = None,\n    ) -> \"ActionAgent\":\n        \"\"\"Create an ActionAgent from a dictionary, properly handling dependencies.\"\"\"\n        data = data.copy()\n\n        # Handle completion model\n        if \"completion\" in data and isinstance(data[\"completion\"], dict):\n            data[\"completion\"] = CompletionModel.model_validate(data[\"completion\"])\n\n        # Handle actions with dependencies\n        if repository and \"actions\" in data and isinstance(data[\"actions\"], list):\n            data[\"actions\"] = [\n                Action.model_validate(\n                    action_data,\n                    repository=repository,\n                    runtime=runtime,\n                    code_index=code_index,\n                )\n                for action_data in data[\"actions\"]\n            ]\n\n        # Handle message generator\n        if ..."
  },
  {
    "type": "function",
    "name": "completion",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 366,
    "end_line": 367,
    "code": "def completion(self) -> CompletionModel:\n        return self._completion"
  },
  {
    "type": "function",
    "name": "completion",
    "class_name": "ActionAgent",
    "file": "agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/agent",
    "start_line": 370,
    "end_line": 371,
    "code": "def completion(self, value: CompletionModel):\n        self._completion = value"
  },
  {
    "type": "function",
    "name": "build_ascii_tree",
    "class_name": null,
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 18,
    "end_line": 68,
    "code": "def build_ascii_tree(self, node: Node, prefix: str = \"\", is_last: bool = True) -> str:\n    \"\"\"\n    Build an ASCII representation of the search tree starting from the given node.\n\n    Args:\n        node: The current node to process\n        prefix: The prefix to use for the current line (for indentation)\n        is_last: Whether this node is the last child of its parent\n\n    Returns:\n        A string containing the ASCII tree representation\n    \"\"\"\n    # Start with the current line's prefix\n    current_prefix = \"└─\" if is_last else \"├─\"\n\n    # Build the node information string\n    node_info = f\"[{node.node_id}] {node.action.__class__.__name__ if node.action else 'Pending'}\"\n    node_info += f\" (depth: {node.get_depth()}, visits: {node.visits}\"\n    node_info += f\", value: {node.reward.value:.2f}\" if node.reward else \", value: 0.00\"\n\n    # Calculate average reward if the node has been visited\n    if node.visits > 0:\n        total_reward = sum(\n            child.reward.value for child in no..."
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "UCTScore",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 88,
    "end_line": 105,
    "code": "def __str__(self):\n        components = [\n            f\"Final Score: {self.final_score:.2f}\",\n            f\"Exploitation: {self.exploitation:.2f}\",\n            f\"Exploration: {self.exploration:.2f}\",\n            f\"Depth Bonus: {self.depth_bonus:.2f}\",\n            f\"Depth Penalty: {self.depth_penalty:.2f}\",\n            f\"High Value Leaf Bonus: {self.high_value_leaf_bonus:.2f}\",\n            f\"High Value Bad Children Bonus: {self.high_value_bad_children_bonus:.2f}\",\n            f\"High Value Child Penalty: {self.high_value_child_penalty:.2f}\",\n            f\"High Value Parent Bonus: {self.high_value_parent_bonus:.2f}\",\n            f\"Finished Trajectory Penalty: {self.finished_trajectory_penalty:.2f}\",\n            f\"Expect Correction Bonus: {self.expect_correction_bonus:.2f}\",\n            f\"Diversity Bonus: {self.diversity_bonus:.2f}\",\n            f\"Duplicate Child Penalty: {self.duplicate_child_penalty:.2f}\",\n            f\"Duplicate Action Penalty: {self.duplicate_action_penalty:.2f}\",\n    ..."
  },
  {
    "type": "function",
    "name": "select",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 187,
    "end_line": 210,
    "code": "def select(self, expandable_nodes: List[Node]) -> Node:\n        \"\"\"Base select method with common validation logic\"\"\"\n        if len(expandable_nodes) == 0:\n            raise ValueError(\"No expandable nodes provided\")\n\n        if len(expandable_nodes) == 1:\n            return expandable_nodes[0]\n\n        # Filter nodes based on minimum reward threshold\n        valid_nodes = [\n            node\n            for node in expandable_nodes\n            if self._get_reward(node) >= self.minimum_reward_threshold\n        ]\n\n        # If no nodes meet the threshold, return root if it's expandable\n        if not valid_nodes:\n            root = expandable_nodes[0].get_root()\n            if root.is_expandable():\n                return root\n            # If root is not expandable, return None\n            return None\n\n        return self._select_node(valid_nodes)"
  },
  {
    "type": "function",
    "name": "_get_reward",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 212,
    "end_line": 216,
    "code": "def _get_reward(self, node: Node):\n        if self.use_average_reward:\n            return node.calculate_mean_reward()\n        else:\n            return node.reward.value if node.reward else 0"
  },
  {
    "type": "function",
    "name": "_select_node",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 218,
    "end_line": 220,
    "code": "def _select_node(self, nodes: List[Node]) -> Node:\n        \"\"\"Internal selection method to be implemented by subclasses\"\"\"\n        raise NotImplementedError(\"Subclasses must implement _select_node method\")"
  },
  {
    "type": "function",
    "name": "uct_score",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 222,
    "end_line": 279,
    "code": "def uct_score(self, node: Node) -> UCTScore:\n        \"\"\"\n        Compute the UCT score with additional bonuses and penalties based on node characteristics.\n\n        This method combines various components to create a comprehensive score for node selection,\n        balancing exploration and exploitation while considering node-specific factors.\n        \"\"\"\n        if node.visits == 0:\n            return UCTScore(final_score=float(\"inf\"))\n\n        exploitation = self.calculate_exploitation(node)\n        exploration = self.calculate_exploration(node)\n        depth_bonus = self.calculate_depth_bonus(node)\n        depth_penalty = self.calculate_depth_penalty(node)\n        high_value_leaf_bonus = self.calculate_high_value_leaf_bonus(node)\n        high_value_bad_children_bonus = self.calculate_high_value_bad_children_bonus(\n            node\n        )\n        high_value_child_penalty = self.calculate_high_value_child_penalty(node)\n        high_value_parent_bonus = self.calculate_high_value_pare..."
  },
  {
    "type": "function",
    "name": "calculate_exploitation",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 281,
    "end_line": 293,
    "code": "def calculate_exploitation(self, node: Node) -> float:\n        \"\"\"\n        Calculate the exploitation component of the UCT score.\n\n        Purpose: Favors nodes with higher rewards, encouraging the algorithm to exploit\n        known good paths in the search tree.\n        \"\"\"\n        if self.use_average_reward:\n            reward = node.calculate_mean_reward()\n        else:\n            reward = node.reward.value if node.reward else 0\n\n        return self.exploitation_weight * reward"
  },
  {
    "type": "function",
    "name": "calculate_exploration",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 295,
    "end_line": 303,
    "code": "def calculate_exploration(self, node: Node) -> float:\n        \"\"\"\n        Calculate the exploration component of the UCT score.\n\n        Purpose: Encourages the exploration of less-visited nodes, ensuring a balance\n        between exploitation and exploration in the search process.\n        \"\"\"\n        total_visits = node.parent.visits if node.parent else 1\n        return self.exploration_weight * math.sqrt(math.log(total_visits) / node.visits)"
  },
  {
    "type": "function",
    "name": "calculate_depth_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 305,
    "end_line": 315,
    "code": "def calculate_depth_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the depth-based exploration bonus.\n\n        Purpose: Provides an incentive to explore deeper into the search tree,\n        particularly for nodes near the root, to encourage thorough exploration.\n        \"\"\"\n        depth = node.get_depth()\n        if depth == 0:\n            return self.depth_bonus_factor * np.exp(-self.depth_weight * (depth - 1))\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_depth_penalty",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 317,
    "end_line": 325,
    "code": "def calculate_depth_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the depth penalty for very deep nodes.\n\n        Purpose: Discourages excessive depth in the search tree, preventing the\n        algorithm from getting stuck in overly long paths.\n        \"\"\"\n        depth = node.get_depth()\n        return self.depth_weight * math.sqrt(depth)"
  },
  {
    "type": "function",
    "name": "calculate_high_value_leaf_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 327,
    "end_line": 336,
    "code": "def calculate_high_value_leaf_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for not expanded nodes with high reward.\n\n        Purpose: Encourages the exploration of promising leaf nodes, potentially\n        leading to valuable new paths in the search tree.\n        \"\"\"\n        if not node.children and node.reward.value >= self.high_value_threshold:\n            return self.high_value_leaf_bonus_constant\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_high_value_bad_children_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 338,
    "end_line": 370,
    "code": "def calculate_high_value_bad_children_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with high reward that expanded to low-reward nodes.\n\n        Purpose: Acts as an \"auto-correct\" mechanism for promising nodes that led to poor\n        outcomes, likely due to invalid actions (e.g., syntax errors from incorrect code changes).\n        This bonus gives these nodes a second chance, allowing the algorithm to potentially\n        recover from or find alternatives to invalid actions.\n\n        The bonus is applied when:\n        1. The node has a high reward\n        2. It has exactly one child (indicating a single action was taken)\n        3. The child action is of a type we want to check (e.g., RequestCodeChange)\n        4. The child node has a low reward\n\n        In such cases, we encourage revisiting this node to try different actions,\n        potentially leading to better outcomes.\n        \"\"\"\n        exploitation = self.calculate_exploitation(node)\n     ..."
  },
  {
    "type": "function",
    "name": "calculate_high_value_child_penalty",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 372,
    "end_line": 386,
    "code": "def calculate_high_value_child_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the penalty for nodes with a child with very high reward.\n\n        Purpose: Discourages over-exploitation of a single high-value path, promoting\n        exploration of alternative routes in the search tree.\n        \"\"\"\n        if node.children:\n            child_values = [\n                child.reward.value for child in node.children if child.reward\n            ]\n            max_child_value = max(child_values) if child_values else 0\n            if max_child_value >= self.very_high_value_threshold:\n                return self.high_value_child_penalty_constant * 1\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_high_value_parent_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 388,
    "end_line": 403,
    "code": "def calculate_high_value_parent_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with low reward that haven't been expanded yet but have high reward parents or not rewarded parents.\n\n        Purpose: Encourages exploration of nodes that might be undervalued due to their\n        current low reward, especially if they have promising ancestors.\n        \"\"\"\n        exploitation = self.calculate_exploitation(node)\n        if not node.children:\n            if node.parent and (\n                not node.parent.reward\n                or node.parent.reward.value > self.high_value_threshold\n            ):\n                if exploitation <= self.low_value_threshold:\n                    return self.high_value_threshold - exploitation\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_finished_trajectory_penalty",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 405,
    "end_line": 418,
    "code": "def calculate_finished_trajectory_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate the penalty for nodes where there are changes and a child node was already finished with high reward.\n\n        Purpose: Discourages revisiting paths that have already led to successful outcomes,\n        promoting exploration of new areas in the search space.\n        \"\"\"\n        if (\n            self.finished_trajectory_penalty\n            and node.file_context\n            and self.is_on_finished_trajectory(node, 100)\n        ):\n            return self.finished_trajectory_penalty\n        return 0"
  },
  {
    "type": "function",
    "name": "is_on_finished_trajectory",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 420,
    "end_line": 440,
    "code": "def is_on_finished_trajectory(\n        self, node: Node, min_reward_thresh: int = 100\n    ) -> bool:\n        \"\"\"\n        Check if the current node is on a trajectory that includes a 'Finish' node.\n        \"\"\"\n\n        for child in node.children:\n            if (\n                child.is_finished()\n                and child.reward\n                and child.reward.value >= min_reward_thresh\n            ):\n                return True\n\n            if self.is_on_finished_trajectory(\n                child, min_reward_thresh=min_reward_thresh\n            ):\n                return True\n\n        return False"
  },
  {
    "type": "function",
    "name": "calculate_expect_correction_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 442,
    "end_line": 464,
    "code": "def calculate_expect_correction_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the bonus for nodes with a parent node that expect correction.\n\n        Purpose: Prioritizes nodes that are marked as expecting correction (e.g., after\n        a failed test run or an invalid search request). This bonus decreases rapidly\n        as the parent node accumulates more children, encouraging exploration of less-visited\n        correction paths.\n        \"\"\"\n        if (\n            node.observation\n            and node.observation.expect_correction\n            and not (\n                node.parent\n                and node.parent.observation\n                and node.parent.observation.expect_correction\n            )\n        ):  # TODO: Set parent as decay factor  instead?\n            # Use a more aggressive decay factor\n            decay_factor = 1 / (1 + len(node.children) ** 2)\n            return self.expect_correction_bonus * decay_factor\n\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_diversity_bonus",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 466,
    "end_line": 501,
    "code": "def calculate_diversity_bonus(self, node: Node) -> float:\n        \"\"\"\n        Calculate the diversity bonus based on the similarity of the node's solution to already expanded nodes.\n\n        Purpose: Boosts the score for nodes whose solutions have low similarity to other explored nodes,\n        encouraging the exploration of novel solutions.\n        \"\"\"\n        if not self.diversity_weight:\n            return 0\n\n        # Ignore nodes without any code added to file context yet\n        if node.file_context.is_empty():\n            return 0\n\n        expandable_nodes = [\n            n\n            for n in node.get_root().get_expanded_descendants()\n            if n.node_id != node.node_id\n        ]\n\n        if not expandable_nodes:\n            # No other nodes to compare; return maximum bonus\n            return self.diversity_weight\n\n        similarities = []\n        for other_node in expandable_nodes:\n            similarity = self.get_similarity(node, other_node)\n            similarities.a..."
  },
  {
    "type": "function",
    "name": "calculate_duplicate_child_penalty",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 503,
    "end_line": 515,
    "code": "def calculate_duplicate_child_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate penalty for nodes that have duplicate children.\n        The penalty increases with each duplicate child.\n\n        Purpose: Discourages exploration of nodes that tend to generate duplicate states,\n        as these are likely to be less productive paths in the search space.\n        \"\"\"\n        duplicate_count = sum(1 for child in node.children if child.is_duplicate)\n        if duplicate_count > 0:\n            # Penalty increases quadratically with number of duplicates\n            return self.duplicate_child_penalty_constant * (duplicate_count**2)\n        return 0"
  },
  {
    "type": "function",
    "name": "calculate_duplicate_action_penalty",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 517,
    "end_line": 544,
    "code": "def calculate_duplicate_action_penalty(self, node: Node) -> float:\n        \"\"\"\n        Calculate penalty for nodes that have children with duplicate action names.\n        The penalty increases with each duplicate action.\n\n        Purpose: Discourages selecting nodes whose children perform the same type of action\n        multiple times, promoting more diverse action sequences.\n        \"\"\"\n        if not node.children:\n            return 0.0\n\n        # Count occurrences of each action name among children\n        action_counts = {}\n        for child in node.children:\n            if child.action:\n                action_name = child.action.__class__.__name__\n                action_counts[action_name] = action_counts.get(action_name, 0) + 1\n\n        # Sum up penalties for all action types that have duplicates\n        total_penalty = 0.0\n        for count in action_counts.values():\n            if count > 1:  # Only penalize actions that appear more than once\n                # Penalty increase..."
  },
  {
    "type": "function",
    "name": "get_similarity",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 546,
    "end_line": 562,
    "code": "def get_similarity(self, node_a: Node, node_b: Node) -> float:\n        \"\"\"\n        Retrieve the similarity between two nodes from the cache or compute it if not cached.\n        \"\"\"\n        if node_a.file_context is None or node_b.file_context is None:\n            return 0.0\n\n        node_ids = (\n            min(node_a.node_id, node_b.node_id),\n            max(node_a.node_id, node_b.node_id),\n        )\n        if node_ids in self._similarity_cache:\n            return self._similarity_cache[node_ids]\n\n        similarity = calculate_similarity(node_a.file_context, node_b.file_context)\n        self._similarity_cache[node_ids] = similarity\n        return similarity"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 565,
    "end_line": 576,
    "code": "def model_validate(cls: Type[\"Selector\"], obj: Any) -> \"Selector\":\n        if isinstance(obj, dict):\n            selector_type = obj.get(\"type\")\n            if selector_type == \"BestFirstSelector\":\n                return BestFirstSelector(**obj)\n            elif selector_type == \"SoftmaxSelector\":\n                return SoftmaxSelector(**obj)\n            elif selector_type == \"LLMSelector\":\n                return LLMSelector(**obj)\n            else:\n                raise ValueError(f\"Unknown selector type: {selector_type}\")\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "Selector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 578,
    "end_line": 581,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"type\"] = self.__class__.__name__\n        return dump"
  },
  {
    "type": "function",
    "name": "_select_node",
    "class_name": "BestFirstSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 587,
    "end_line": 610,
    "code": "def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        sorted_nodes = sorted(\n            nodes_with_scores, key=lambda x: x[1].final_score, reverse=True\n        )\n\n        # Log top nodes with detailed score breakdowns\n        top_nodes = sorted_nodes[: min(len(sorted_nodes), 10)]\n        logger.info(\"Comparing top nodes:\")\n        for i, (node, score) in enumerate(top_nodes):\n            logger.info(\n                f\"Node {node.node_id} - Visits: {node.visits} - \"\n                f\"Reward: {node.reward.value if node.reward else '-'} - \"\n                f\"\\nScore components: {score}\"\n            )\n\n        selected_node = sorted_nodes[0][0]\n        selected_score = sorted_nodes[0][1].final_score\n\n        logger.info(\n            f\"Selected Node {selected_node.node_id} with UCT Score: {selected_score:.2f}\"\n        )\n        return selected_node"
  },
  {
    "type": "function",
    "name": "_select_node",
    "class_name": "SoftmaxSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 616,
    "end_line": 650,
    "code": "def _select_node(self, nodes: List[Node]) -> Node:\n        # Move existing selection logic here\n        nodes_with_scores = [(node, self.uct_score(node)) for node in nodes]\n        uct_scores = [score.final_score for _, score in nodes_with_scores]\n\n        # Calculate softmax probabilities\n        softmax_scores = np.exp(uct_scores - np.max(uct_scores))\n        probabilities = softmax_scores / softmax_scores.sum()\n\n        # Log summary for top nodes\n        top_nodes = sorted(\n            zip(nodes, uct_scores, probabilities),\n            key=lambda x: x[1],\n            reverse=True,\n        )[:10]\n\n        logger.info(\"Softmax selection summary (top 10 nodes):\")\n        for node, score, prob in top_nodes:\n            logger.info(\n                f\"Node {node.node_id}: Visits={node.visits}, \"\n                f\"Reward={node.reward.value if node.reward else '-'}, \"\n                f\"UCTScore={score:.2f}, Probability={prob:.4f}\"\n            )\n\n        # Select a node based on the probabi..."
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "LLMSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 693,
    "end_line": 703,
    "code": "def __init__(\n        self, completion: CompletionModel = None, max_iterations: int = None, **kwargs\n    ):\n        # Initialize with all fields, including those from base class\n        all_kwargs = {\n            \"type\": \"LLMSelector\",\n            \"completion\": completion,\n            \"max_iterations\": max_iterations,\n            **kwargs,\n        }\n        super().__init__(**all_kwargs)"
  },
  {
    "type": "function",
    "name": "get_action_definitions",
    "class_name": "LLMSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 705,
    "end_line": 753,
    "code": "def get_action_definitions(self) -> str:\n        \"\"\"\n        Build a formatted string containing descriptions of all available actions.\n        \"\"\"\n        try:\n            from moatless_qa.actions import (\n                SemanticSearch,\n                FindClass,\n                FindFunction,\n                FindCodeSnippet,\n                Finish,\n                # Remove RequestMoreContext since it doesn't exist\n                # RequestMoreContext,\n            )\n\n            definitions = \"\\nAvailable Actions:\\n\"\n            available_actions = [\n                SemanticSearch,\n                FindClass,\n                FindFunction,\n                FindCodeSnippet,\n                Finish,\n                # Remove from this list as well\n                # RequestMoreContext,\n            ]\n\n            for action_class in available_actions:\n                try:\n                    schema = action_class.args_schema.model_json_schema()\n                    definitions += f\"\\n* **{schem..."
  },
  {
    "type": "function",
    "name": "build_ascii_tree",
    "class_name": "LLMSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 755,
    "end_line": 863,
    "code": "def build_ascii_tree(\n        self,\n        node: Node,\n        previous_attempts: str = \"\",\n        n_iterations: int = 0,\n        require_feedback: bool = True,\n    ) -> NodeSelection:\n        # Generate ASCII tree representation\n        ascii_tree = generate_ascii_tree(\n            node,\n            include_explanation=True,\n            use_color=False,\n            include_diffs=True,\n            include_action_details=False,\n            include_file_context=False,\n        )\n\n        # also print tree with colors so we can see it\n        ascii_tree_colored = generate_ascii_tree(\n            node,\n            use_color=True,\n            include_diffs=True,\n            include_action_details=False,\n            include_file_context=False,\n        )\n\n        # Construct the system message with context based on feedback requirement\n        system_message = f\"{SYSTEM_PROMPT}\\n\\n\"\n        if require_feedback:\n            system_message += (\n                f\"Here are some example responses..."
  },
  {
    "type": "function",
    "name": "select",
    "class_name": "LLMSelector",
    "file": "selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 865,
    "end_line": 904,
    "code": "def select(self, nodes: List[Node]) -> Node:\n        if len(nodes) == 1:\n            return nodes[0]\n\n        max_retries = 3\n        n_iterations = len(nodes)\n        available_node_ids = [node.node_id for node in nodes]\n        previous_attempts = \"\"\n\n        for attempt in range(max_retries):\n            # Get the selection from LLM, now passing n_iterations\n            selection = self.build_ascii_tree(nodes[0], previous_attempts, n_iterations)\n\n            # Find and return the selected node\n            for node in nodes:\n                if node.node_id == selection.node_id:\n                    # try:\n                    #     node.feedback = selection.explanation\n                    #     node.message = selection.explanation\n                    #     node.reward.explanation += f\"\\n{selection.explanation}\"\n                    # except AttributeError:\n                    #     logger.warning(f\"Node {node.node_id}, has no reward attribute\")\n                    return node\n\n         ..."
  },
  {
    "type": "function",
    "name": "format_examples",
    "class_name": null,
    "file": "prompt.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 1,
    "end_line": 8,
    "code": "def format_examples(examples):\n    formatted = []\n    for i, example in enumerate(examples, 1):\n        header = f\"Example {i}:\\n\\n\"\n        node_id = f\"<node_id>: {i}\\n\"\n        feedback = f\"<feedback>: {example}\"\n        formatted.append(header + node_id + feedback)\n    return \"\\n\\n\".join(formatted)"
  },
  {
    "type": "function",
    "name": "calculate_similarity",
    "class_name": null,
    "file": "similarity.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 7,
    "end_line": 58,
    "code": "def calculate_similarity(context_a: FileContext, context_b: FileContext) -> float:\n    \"\"\"\n    Calculates the similarity score between the two FileContext instances.\n\n    Returns:\n        float: The similarity score between 0 and 1.\n    \"\"\"\n    # Step 1: File path similarity\n    files_a = set(context_a._files.keys())\n    files_b = set(context_b._files.keys())\n    file_path_similarity = jaccard_similarity(files_a, files_b)\n\n    # Step 2: Span similarity\n    span_similarities = []\n    for file_path in files_a.intersection(files_b):\n        spans_a = context_a._files[file_path].span_ids\n        spans_b = context_b._files[file_path].span_ids\n        if spans_a or spans_b:\n            span_similarity = jaccard_similarity(spans_a, spans_b)\n            span_similarities.append(span_similarity)\n        else:\n            # If both have no spans, consider them fully similar\n            span_similarities.append(1.0)\n    if span_similarities:\n        average_span_similarity = sum(span_similarities..."
  },
  {
    "type": "function",
    "name": "jaccard_similarity",
    "class_name": null,
    "file": "similarity.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 61,
    "end_line": 72,
    "code": "def jaccard_similarity(set1: Set, set2: Set) -> float:\n    \"\"\"\n    Calculates the Jaccard similarity between two sets.\n\n    Returns:\n        float: Jaccard similarity score.\n    \"\"\"\n    intersection = set1.intersection(set2)\n    union = set1.union(set2)\n    if not union:\n        return 1.0  # Both sets are empty\n    return len(intersection) / len(union)"
  },
  {
    "type": "function",
    "name": "string_similarity",
    "class_name": null,
    "file": "similarity.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 75,
    "end_line": 85,
    "code": "def string_similarity(s1: str, s2: str) -> float:\n    \"\"\"\n    Calculates the similarity between two strings using difflib.\n\n    Returns:\n        float: Similarity score between 0 and 1.\n    \"\"\"\n    if not s1 and not s2:\n        return 1.0  # Both strings are empty\n    matcher = difflib.SequenceMatcher(None, s1, s2)\n    return matcher.ratio()"
  },
  {
    "type": "function",
    "name": "select",
    "class_name": "FeedbackSelector",
    "file": "feedback_selector.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/selector",
    "start_line": 18,
    "end_line": 48,
    "code": "def select(self, nodes: List[Node]) -> Optional[Node]:\n        \"\"\"Select a node based on existing feedback analysis.\"\"\"\n        if not nodes:\n            return None\n\n        for node in nodes:\n            # Check for existing feedback in node.completions\n            if hasattr(node, \"completions\") and \"feedback\" in node.completions:\n                feedback_completion: Completion = node.completions[\"feedback\"]\n                if feedback_completion and feedback_completion.response:\n                    try:\n                        # Extract feedback response data\n                        response_data = feedback_completion.response\n\n                        # If there's a suggested node ID, use it\n                        if \"suggested_node_id\" in response_data:\n                            suggested_node_id = response_data[\"suggested_node_id\"]\n                            if suggested_node_id == node.node_id:\n                                logger.info(\n                                    ..."
  },
  {
    "type": "function",
    "name": "__post_init__",
    "class_name": "ToolCall",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 25,
    "end_line": 27,
    "code": "def __post_init__(self):\n        # Ensure name is always a string\n        self.name = str(self.name)"
  },
  {
    "type": "function",
    "name": "tool_call_id",
    "class_name": "AssistantMessage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 38,
    "end_line": 47,
    "code": "def tool_call_id(self) -> Optional[str]:\n        \"\"\"Generate a deterministic tool call ID based on the tool call content\"\"\"\n        if not self.tool_call:\n            return None\n\n        # Create a string combining name and input for hashing\n        tool_str = f\"{str(self.tool_call.name)}:{json.dumps(self.tool_call.input, sort_keys=True)}\"\n        # Generate SHA-256 hash and take first 8 characters\n        hash_id = hashlib.sha256(tool_str.encode()).hexdigest()[:8]\n        return f\"call_{hash_id}\""
  },
  {
    "type": "function",
    "name": "from_completion_response",
    "class_name": "Usage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 62,
    "end_line": 128,
    "code": "def from_completion_response(\n        cls, completion_response: dict | BaseModel, model: str\n    ) -> Union[\"Usage\", None]:\n        if isinstance(completion_response, BaseModel) and hasattr(\n            completion_response, \"usage\"\n        ):\n            usage = completion_response.usage.model_dump()\n        elif isinstance(completion_response, dict) and \"usage\" in completion_response:\n            usage = completion_response[\"usage\"]\n        else:\n            logger.warning(\n                f\"No usage info available in completion response: {completion_response}\"\n            )\n            return None\n\n        logger.debug(f\"Usage: {json.dumps(usage, indent=2)}\")\n\n        prompt_tokens = usage.get(\"prompt_tokens\") or usage.get(\"input_tokens\", 0)\n\n        if usage.get(\"cache_creation_input_tokens\"):\n            prompt_tokens += usage[\"cache_creation_input_tokens\"]\n\n        completion_tokens = usage.get(\"completion_tokens\") or usage.get(\n            \"output_tokens\", 0\n        )\n\n        if..."
  },
  {
    "type": "function",
    "name": "__add__",
    "class_name": "Usage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 130,
    "end_line": 142,
    "code": "def __add__(self, other: \"Usage\") -> \"Usage\":\n        # Get completion cost, defaulting to 0 if not available\n        other_cost = getattr(other, \"completion_cost\", 0)\n        other_completion = getattr(other, \"completion_tokens\", 0)\n        other_prompt = getattr(other, \"prompt_tokens\", 0)\n        other_cached = getattr(other, \"cached_tokens\", 0)\n\n        return Usage(\n            completion_cost=self.completion_cost + other_cost,\n            completion_tokens=self.completion_tokens + other_completion,\n            prompt_tokens=self.prompt_tokens + other_prompt,\n            cached_tokens=self.cached_tokens + other_cached,\n        )"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "Usage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 144,
    "end_line": 150,
    "code": "def __str__(self) -> str:\n        return (\n            f\"Usage(cost: ${self.completion_cost:.4f}, \"\n            f\"completion tokens: {self.completion_tokens}, \"\n            f\"prompt tokens: {self.prompt_tokens}, \"\n            f\"cached tokens: {self.cached_tokens})\"\n        )"
  },
  {
    "type": "function",
    "name": "fix_null_tokens",
    "class_name": "Usage",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 154,
    "end_line": 160,
    "code": "def fix_null_tokens(cls, data: Any) -> Any:\n        if isinstance(data, dict):\n            for key, value in data.items():\n                if not value:\n                    data[key] = 0\n\n        return data"
  },
  {
    "type": "function",
    "name": "from_llm_completion",
    "class_name": "Completion",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 175,
    "end_line": 204,
    "code": "def from_llm_completion(\n        cls,\n        input_messages: list[dict],\n        completion_response: Any,\n        model: str,\n        usage: Usage | None = None,\n        retries: int | None = None,\n        flags: list[str] | None = None,\n    ) -> Optional[\"Completion\"]:\n        if isinstance(completion_response, BaseModel):\n            response = completion_response.model_dump()\n        elif isinstance(completion_response, dict):\n            response = completion_response\n        else:\n            logger.error(\n                f\"Unexpected completion response type: {type(completion_response)}\"\n            )\n            return None\n\n        if not usage:\n            usage = Usage.from_completion_response(completion_response, model)\n\n        return cls(\n            model=model,\n            input=input_messages,\n            response=response,\n            retries=retries,\n            usage=usage,\n            flags=flags or [],\n        )"
  },
  {
    "type": "function",
    "name": "__get__",
    "class_name": "NameDescriptor",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 208,
    "end_line": 211,
    "code": "def __get__(self, obj, cls=None) -> str:\n        if hasattr(cls, \"Config\") and hasattr(cls.Config, \"title\") and cls.Config.title:\n            return cls.Config.title\n        return cls.__name__"
  },
  {
    "type": "function",
    "name": "description",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 221,
    "end_line": 222,
    "code": "def description(cls):\n        return cls.model_json_schema().get(\"description\", \"\")"
  },
  {
    "type": "function",
    "name": "openai_schema",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 225,
    "end_line": 332,
    "code": "def openai_schema(cls, thoughts_in_action: bool = False) -> dict[str, Any]:\n        \"\"\"\n        Return the schema in the format of OpenAI's schema as jsonschema\n        \"\"\"\n        schema = cls.model_json_schema()\n        docstring = parse(cls.__doc__ or \"\")\n        parameters = {\n            k: v\n            for k, v in schema.items()\n            if k not in (\"title\", \"description\")\n            and (thoughts_in_action or k != \"thoughts\")\n        }\n\n        if not thoughts_in_action and parameters[\"properties\"].get(\"thoughts\"):\n            del parameters[\"properties\"][\"thoughts\"]\n\n        def remove_defaults(obj: dict) -> None:\n            \"\"\"Recursively remove default fields from a schema object\"\"\"\n            if isinstance(obj, dict):\n                if \"default\" in obj:\n                    del obj[\"default\"]\n                # Recurse into nested properties\n                for value in obj.values():\n                    remove_defaults(value)\n            elif isinstance(obj, list):\n  ..."
  },
  {
    "type": "function",
    "name": "anthropic_schema",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 335,
    "end_line": 359,
    "code": "def anthropic_schema(cls) -> dict[str, Any]:\n        schema = cls.model_json_schema()\n        del schema[\"title\"]\n\n        if \"description\" in schema:\n            description = schema[\"description\"]\n            del schema[\"description\"]\n        else:\n            description = None\n\n        response = {\n            \"name\": cls.name,\n            \"input_schema\": schema,\n        }\n\n        if description:\n            response[\"description\"] = description\n\n        # Exclude thoughts field from properties and required if it exists\n        if \"thoughts\" in schema.get(\"properties\", {}):\n            del schema[\"properties\"][\"thoughts\"]\n            if \"required\" in schema and \"thoughts\" in schema[\"required\"]:\n                schema[\"required\"].remove(\"thoughts\")\n\n        return response"
  },
  {
    "type": "function",
    "name": "model_validate_xml",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 362,
    "end_line": 384,
    "code": "def model_validate_xml(cls, xml_text: str) -> Self:\n        \"\"\"Parse XML format into model fields.\"\"\"\n        parsed_input = {}\n        # Fields that can be parsed from XML format\n        xml_fields = [\"path\", \"old_str\", \"new_str\", \"file_text\", \"insert_line\"]\n\n        for field in xml_fields:\n            start_tag = f\"<{field}>\"\n            end_tag = f\"</{field}>\"\n            if start_tag in xml_text and end_tag in xml_text:\n                start_idx = xml_text.index(start_tag) + len(start_tag)\n                end_idx = xml_text.index(end_tag)\n                content = xml_text[start_idx:end_idx]\n\n                # Handle both single-line and multi-line block content\n                if content:\n                    # If content starts/ends with newlines, preserve the inner content\n                    if content.startswith(\"\\n\") and content.endswith(\"\\n\"):\n                        # Remove first and last newline but preserve internal formatting\n                        content = content[1:..."
  },
  {
    "type": "function",
    "name": "model_validate_json",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 387,
    "end_line": 448,
    "code": "def model_validate_json(\n        cls,\n        json_data: str | bytes | bytearray,\n        **kwarg,\n    ) -> Self:\n        if not json_data:\n            raise ValidationError(\"Message is empty\")\n\n        try:\n            if isinstance(json_data,str):\n                json_data = json_data.strip(\"```json\\n\").strip(\"\\n```\")\n            parsed_data = json.loads(json_data, strict=False)\n\n            def unescape_values(obj):\n                if isinstance(obj, dict):\n                    return {k: unescape_values(v) for k, v in obj.items()}\n                elif isinstance(obj, list):\n                    return [unescape_values(v) for v in obj]\n                elif isinstance(obj, str) and \"\\\\\" in obj:\n                    return obj.encode().decode(\"unicode_escape\")\n                return obj\n\n            cleaned_data = unescape_values(parsed_data)\n            cleaned_json = json.dumps(cleaned_data)\n            return super().model_validate_json(cleaned_json, **kwarg)\n\n        except (json.JSO..."
  },
  {
    "type": "function",
    "name": "format_args_for_llm",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 450,
    "end_line": 460,
    "code": "def format_args_for_llm(self) -> str:\n        \"\"\"\n        Format the input arguments for LLM completion calls. Override in subclasses for custom formats.\n        Default implementation returns JSON format.\n        \"\"\"\n        return json.dumps(\n            self.model_dump(\n                exclude={\"thoughts\"} if hasattr(self, \"thoughts\") else None\n            ),\n            indent=2,\n        )"
  },
  {
    "type": "function",
    "name": "format_schema_for_llm",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 463,
    "end_line": 478,
    "code": "def format_schema_for_llm(cls, thoughts_in_action: bool = False) -> str:\n        \"\"\"\n        Format the schema description for LLM completion calls.\n        Default implementation returns JSON schema.\n        \"\"\"\n        schema = cls.model_json_schema()\n\n        if not thoughts_in_action and schema[\"properties\"].get(\"thoughts\"):\n            del schema[\"properties\"][\"thoughts\"]\n            schema[\"required\"] = sorted(\n                k\n                for k, v in schema[\"properties\"].items()\n                if \"default\" not in v and (thoughts_in_action or k != \"thoughts\")\n            )\n\n        return f\"Requires a JSON response with the following schema: {json.dumps(schema, ensure_ascii=False)}\""
  },
  {
    "type": "function",
    "name": "format_xml_schema",
    "class_name": "StructuredOutput",
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 481,
    "end_line": 496,
    "code": "def format_xml_schema(cls, xml_fields: dict[str, str]) -> str:\n        \"\"\"\n        Format XML schema description.\n        Used by actions that require XML-formatted input.\n\n        Args:\n            xml_fields: Dictionary mapping field names to their descriptions\n        \"\"\"\n        schema = [f\"Requires the following XML format:\"]\n\n        # Build example XML structure\n        example = []\n        for field_name, field_desc in xml_fields.items():\n            example.append(f\"<{field_name}>{field_desc}</{field_name}>\")\n\n        return \"\\n\".join(schema + example)"
  },
  {
    "type": "function",
    "name": "extract_json_from_message",
    "class_name": null,
    "file": "model.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 499,
    "end_line": 579,
    "code": "def extract_json_from_message(message: str) -> tuple[dict | str, list[dict]]:\n    \"\"\"\n    Extract JSON from a message, handling both code blocks and raw JSON.\n    Returns a tuple of (selected_json_dict, all_found_json_dicts).\n    \"\"\"\n\n    def clean_json_string(json_str: str) -> str:\n        # Remove single-line comments and clean control characters\n        lines = []\n        for line in json_str.split(\"\\n\"):\n            # Remove everything after // or #\n            line = line.split(\"//\")[0].split(\"#\")[0].rstrip()\n            # Clean control characters but preserve newlines and spaces\n            line = \"\".join(char for char in line if ord(char) >= 32 or char in \"\\n\\t\")\n            if line:  # Only add non-empty lines\n                lines.append(line)\n        return \"\\n\".join(lines)\n\n    all_found_jsons = []\n\n    # First try to find ```json blocks\n    try:\n        current_pos = 0\n        while True:\n            start = message.find(\"```json\", current_pos)\n            if start == -1:\n ..."
  },
  {
    "type": "function",
    "name": "create",
    "class_name": "CompletionResponse",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 39,
    "end_line": 54,
    "code": "def create(\n        cls,\n        text: str | None = None,\n        output: List[StructuredOutput] | StructuredOutput | None = None,\n        completion: Completion | None = None,\n    ) -> \"CompletionResponse\":\n        if isinstance(output, StructuredOutput):\n            outputs = [output]\n        elif isinstance(output, list):\n            outputs = output\n        else:\n            outputs = None\n\n        return cls(\n            text_response=text, structured_outputs=outputs, completion=completion\n        )"
  },
  {
    "type": "function",
    "name": "structured_output",
    "class_name": "CompletionResponse",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 57,
    "end_line": 66,
    "code": "def structured_output(self) -> Optional[StructuredOutput]:\n        \"\"\"Get the first structured output\"\"\"\n        if len(self.structured_outputs) > 1:\n            ignored_outputs = [\n                output.__class__.__name__ for output in self.structured_outputs[1:]\n            ]\n            logger.warning(\n                f\"Multiple structured outputs found in completion response, returning {self.structured_outputs[0].__class__.__name__} and ignoring: {ignored_outputs}\"\n            )\n        return self.structured_outputs[0] if self.structured_outputs else None"
  },
  {
    "type": "function",
    "name": "clone",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 101,
    "end_line": 112,
    "code": "def clone(self, **kwargs) -> \"CompletionModel\":\n        \"\"\"Create a copy of the completion model with optional parameter overrides.\n\n        Args:\n            **kwargs: Parameters to override in the cloned model\n\n        Returns:\n            A new CompletionModel instance with the specified overrides\n        \"\"\"\n        model_data = self.model_dump()\n        model_data.update(kwargs)\n        return CompletionModel.model_validate(model_data)"
  },
  {
    "type": "function",
    "name": "create_completion",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 114,
    "end_line": 259,
    "code": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        if not response_model:\n            raise CompletionRuntimeError(f\"Response model is required for completion\")\n\n        if isinstance(response_model, list) and len(response_model) > 1:\n            avalabile_actions = [\n                action for action in response_model if hasattr(action, \"name\")\n            ]\n            if not avalabile_actions:\n                raise CompletionRuntimeError(f\"No actions found in {response_model}\")\n\n            class TakeAction(StructuredOutput):\n                action: Union[tuple(response_model)] = Field(...)\n                action_type: str = Field(\n                    ..., description=\"The type of action being taken\"\n                )\n\n                @model_validator(mode=\"before\")\n                def validate_action(cls, data: dict) -> dict..."
  },
  {
    "type": "function",
    "name": "_litellm_base_completion",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 261,
    "end_line": 329,
    "code": "def _litellm_base_completion(\n        self,\n        messages: list[dict],\n        tools: list[dict] | None = None,\n        tool_choice: str | None = None,\n        response_format: dict | None = None,\n    ) -> Any:\n        \"\"\"Base method for making litellm completion calls with common parameters.\n\n        Args:\n            messages: List of message dictionaries\n            tools: Optional list of tool definitions for function calling\n            tool_choice: Optional tool choice configuration\n            response_format: Optional response format configuration\n\n        Returns:\n            The completion response from litellm\n        \"\"\"\n        litellm.drop_params = True\n\n        @tenacity.retry(\n            stop=tenacity.stop_after_attempt(6),\n            wait=tenacity.wait_exponential(multiplier=3),\n            retry=tenacity.retry_if_exception_type(Exception),\n            reraise=True,\n            before_sleep=lambda retry_state: logger.warning(\n                f\"Retrying litellm com..."
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 331,
    "end_line": 337,
    "code": "def model_dump(self, **kwargs):\n        dump = super().model_dump(**kwargs)\n        if \"model_api_key\" in dump:\n            dump[\"model_api_key\"] = None\n        if \"response_format\" in dump:\n            dump[\"response_format\"] = dump[\"response_format\"].value\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 340,
    "end_line": 356,
    "code": "def model_validate(cls, obj):\n        if isinstance(obj, dict) and \"response_format\" in obj:\n            if \"claude-3-5\" in obj[\"model\"]:\n                from moatless_qa.completion.anthropic import AnthtropicCompletionModel\n                return AnthtropicCompletionModel(**obj)\n\n            response_format = LLMResponseFormat(obj[\"response_format\"])\n            obj[\"response_format\"] = response_format\n\n            if response_format == LLMResponseFormat.TOOLS:\n                from moatless_qa.completion.tool_call import ToolCallCompletionModel\n                return ToolCallCompletionModel(**obj)\n            elif response_format == LLMResponseFormat.REACT:\n                from moatless_qa.completion.react import ReActCompletionModel\n                return ReActCompletionModel(**obj)\n\n        return cls(**obj)"
  },
  {
    "type": "function",
    "name": "set_api_key",
    "class_name": "CompletionModel",
    "file": "completion.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 359,
    "end_line": 366,
    "code": "def set_api_key(self) -> \"CompletionModel\":\n        \"\"\"\n        Update the model with the API key from en vars if model base URL is set but API key is not as we don't persist the API key.\n        \"\"\"\n        if self.model_base_url and not self.model_api_key:\n            self.model_api_key = os.getenv(\"CUSTOM_LLM_API_KEY\")\n\n        return self"
  },
  {
    "type": "function",
    "name": "supports_anthropic_computer_use",
    "class_name": "AnthtropicCompletionModel",
    "file": "anthropic.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 30,
    "end_line": 31,
    "code": "def supports_anthropic_computer_use(self):\n        return \"claude-3-5-sonnet-20241022\" in self.model"
  },
  {
    "type": "function",
    "name": "create_completion",
    "class_name": "AnthtropicCompletionModel",
    "file": "anthropic.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 33,
    "end_line": 214,
    "code": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        # Convert Message objects to dictionaries if needed\n        messages = [\n            msg.model_dump() if hasattr(msg, \"model_dump\") else msg for msg in messages\n        ]\n\n        total_usage = Usage()\n        retry_count = 0\n\n        tools = []\n        tool_choice = {\"type\": \"any\"}\n\n        actions = []\n        if not response_model:\n            tools = NOT_GIVEN\n            tool_choice = NOT_GIVEN\n        else:\n            if isinstance(response_model, list):\n                actions = response_model\n            elif response_model:\n                actions = [response_model]\n\n            for action in actions:\n                schema = action.anthropic_schema()\n\n                # Remove scratch pad field, use regular text block for thoughts\n                if \"thoughts\" in schem..."
  },
  {
    "type": "function",
    "name": "_inject_prompt_caching",
    "class_name": null,
    "file": "anthropic.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 217,
    "end_line": 243,
    "code": "def _inject_prompt_caching(\n    messages: list[\n        Union[\n            \"AnthropicMessagesUserMessageParam\", \"AnthopicMessagesAssistantMessageParam\"\n        ]\n    ],\n):\n    from anthropic.types.beta import BetaCacheControlEphemeralParam\n\n    \"\"\"\n    Set cache breakpoints for the 3 most recent turns\n    one cache breakpoint is left for tools/system prompt, to be shared across sessions\n    \"\"\"\n\n    breakpoints_remaining = 3\n    for message in reversed(messages):\n        # message[\"role\"] == \"user\" and\n        if isinstance(content := message[\"content\"], list):\n            if breakpoints_remaining:\n                breakpoints_remaining -= 1\n                content[-1][\"cache_control\"] = BetaCacheControlEphemeralParam(\n                    {\"type\": \"ephemeral\"}\n                )\n            else:\n                content[-1].pop(\"cache_control\", None)\n                # we'll only every have one extra turn per loop\n                break"
  },
  {
    "type": "function",
    "name": "create_completion",
    "class_name": "ReActCompletionModel",
    "file": "react.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 18,
    "end_line": 160,
    "code": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]],\n    ) -> CompletionResponse:\n        action_input_schemas = []\n\n        total_usage = Usage()\n        retry_count = 0\n\n        for action in response_model:\n            action_input_schemas.append(\n                f\" * {action.name} {action.format_schema_for_llm()}\"\n            )\n\n        system_prompt += dedent(f\"\"\"\\n# Response format\n\nUse the following format:\n\nThought: You should always think about what to do\nAction: The action to take followed by the input arguments based on the schema below\n\nUse one of the following actions and provide input arguments matching the schema.\n                            \n{'\\n\\n'.join(action_input_schemas)}\n\nImportant: Do not include multiple Thought-Action blocks. Do not include code blocks or additional text outside of this format.\n\"\"\")\n\n        messages.insert(0, {\"role\": \"system\", \"content\": system_pro..."
  },
  {
    "type": "function",
    "name": "_validate_react_format",
    "class_name": "ReActCompletionModel",
    "file": "react.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 162,
    "end_line": 190,
    "code": "def _validate_react_format(self, response_text: str):\n        # Split into lines and remove empty ones\n        lines = [line.strip() for line in response_text.split(\"\\n\") if line.strip()]\n\n        # Count occurrences of each section\n        thought_count = sum(1 for line in lines if line.startswith(\"Thought:\"))\n        action_count = sum(1 for line in lines if line.startswith(\"Action:\"))\n\n        # Check for multiple action blocks\n        if thought_count > 1 or action_count > 1:\n            logger.warning(\n                f\"Multiple Thought or Action sections found in response: {response_text}\"\n            )\n\n        # Check if all sections exist\n        if thought_count < 1 or action_count < 1:\n            raise ValueError(\"Response must have one 'Thought:' and 'Action:' section\")\n\n        # Find the starting lines for each section\n        thought_line = next(\n            (i for i, line in enumerate(lines) if line.startswith(\"Thought:\")), -1\n        )\n        action_line = next(\n    ..."
  },
  {
    "type": "function",
    "name": "create_completion",
    "class_name": "ToolCallCompletionModel",
    "file": "tool_call.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/completion",
    "start_line": 21,
    "end_line": 159,
    "code": "def create_completion(\n        self,\n        messages: List[dict],\n        system_prompt: str,\n        response_model: List[type[StructuredOutput]] | type[StructuredOutput],\n    ) -> CompletionResponse:\n        tools = []\n\n        if isinstance(response_model, list):\n            tools.extend(\n                [\n                    r.openai_schema(thoughts_in_action=self.thoughts_in_action)\n                    for r in response_model\n                ]\n            )\n        elif response_model:\n            tools.append(response_model.openai_schema())\n        else:\n            tools = None\n\n        total_usage = Usage()\n        retry_count = 0\n\n        messages.insert(0, {\"role\": \"system\", \"content\": system_prompt})\n\n        retries = tenacity.Retrying(\n            retry=tenacity.retry_if_not_exception_type(\n                (APIError, BadRequestError, NotFoundError, AuthenticationError)\n            ),\n            stop=tenacity.stop_after_attempt(3),\n        )\n\n        def _do_completion():..."
  },
  {
    "type": "function",
    "name": "get_reward",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 85,
    "end_line": 121,
    "code": "def get_reward(self, node: Node) -> Tuple[Optional[Reward], Optional[Completion]]:\n        if node.action.name != \"Finish\":\n            logger.warning(\n                f\"TerminalValueFunction can only evaluate finished solutions, but got action {node.action.name}\"\n            )\n            return None, None\n\n        user_message = self._create_message(node)\n        messages = [user_message]\n        system_prompt = self._build_system_prompt(node)\n\n        try:\n            response_model = (\n                ProvideRewardWithFeedback if self.include_feedback else ProvideReward\n            )\n            completion_response = self.completion_model.create_completion(\n                messages=messages,\n                system_prompt=system_prompt,\n                response_model=response_model,\n            )\n\n            if completion_response.structured_output:\n                output = completion_response.structured_output\n                reward = Reward(\n                    value=output.value..."
  },
  {
    "type": "function",
    "name": "_show_existing_solutions",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 123,
    "end_line": 179,
    "code": "def _show_existing_solutions(self, node: Node) -> bool:\n        \"\"\"Format existing solutions with node IDs below current. Returns True if any solutions were found.\"\"\"\n        root_node = node.get_root()\n        leaf_nodes = root_node.get_leaf_nodes()\n\n        # Filter for finished nodes with lower IDs\n        existing_solutions = [\n            n for n in leaf_nodes if n.is_finished() and n.node_id < node.node_id\n        ]\n\n        if not existing_solutions:\n            return False\n\n        attempts_message = \"\\n# Previous Solution Attempts\\n\"\n        for i, solution_node in enumerate(existing_solutions, 1):\n            attempts_message += f\"\\n## Attempt {i} (Node{solution_node.node_id})\\n\"\n\n            # Show reward if exists\n            if solution_node.reward:\n                attempts_message += f\"\\nReward: {solution_node.reward.value}/100\\n\"\n                if solution_node.reward.explanation:\n                    attempts_message += (\n                        f\"Explanation: {solutio..."
  },
  {
    "type": "function",
    "name": "_create_message",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 181,
    "end_line": 246,
    "code": "def _create_message(self, node: Node) -> ChatCompletionUserMessage:\n        previous_nodes = node.get_trajectory()[:-1]\n\n        message = node.get_root().message\n\n        # Add history if enabled\n        if self.show_history:\n            formatted_history: List[str] = []\n            counter = 0\n            for previous_node in previous_nodes:\n                if previous_node.action:\n                    counter += 1\n                    formatted_state = (\n                        f\"\\n## {counter}. Action: {previous_node.action.name}\\n\"\n                    )\n                    formatted_state += previous_node.action.to_prompt()\n\n                    if previous_node.observation:\n                        formatted_state += (\n                            f\"\\n\\nObservation: {previous_node.observation.summary}\"\n                        )\n                        formatted_history.append(formatted_state)\n                    else:\n                        logger.warning(\n                           ..."
  },
  {
    "type": "function",
    "name": "_build_system_prompt",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 248,
    "end_line": 311,
    "code": "def _build_system_prompt(self, node: Node):\n        action = Action.get_action_by_args_class(type(node.action))\n        trajectory_length = len(node.get_trajectory())\n\n        prompt = \"\"\"You are evaluating a finished solution to determine how well it solves the original task.\n\nYour role is to evaluate the CURRENT solution independently\"\"\"\n\n        if self.show_previous_solutions:\n            prompt += \", while using previous attempts for context and comparison\"\n        prompt += \".\\n\\n\"\n\n        prompt += \"\"\"Focus on:\n1. Whether the CURRENT solution fully addresses the requirements\n2. The quality and correctness of the CURRENT implementation\n3. Any potential issues or limitations in the CURRENT solution\n\nThe user message contains the following sections:\n- <task>: The original task description\"\"\"\n\n        if self.show_history:\n            prompt += (\n                \"\\n- <history>: Actions and outputs that led to the CURRENT solution\"\n            )\n\n        if self.show_previous_soluti..."
  },
  {
    "type": "function",
    "name": "_format_evaluation_criteria",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 314,
    "end_line": 318,
    "code": "def _format_evaluation_criteria(criteria_list: List[str]) -> str:\n        formatted_criteria = \"\\n# Evaluation Criteria:\\n\"\n        for criterion in criteria_list:\n            formatted_criteria += f\"* {criterion}\\n\"\n        return formatted_criteria"
  },
  {
    "type": "function",
    "name": "_format_reward_scale",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 321,
    "end_line": 335,
    "code": "def _format_reward_scale(\n        reward_scale_list: List[RewardScaleEntry], min_value: int, max_value: int\n    ) -> str:\n        formatted_scale = \"\\n# Reward Scale and Guidelines:\\n\"\n        sorted_entries = sorted(reward_scale_list, key=lambda x: -x.max_value)\n\n        formatted_scale += f\"The reward value must be an integer between {min_value} and {max_value}, where:\\n\\n\"\n\n        for entry in sorted_entries:\n            if entry.min_value == entry.max_value:\n                formatted_scale += f\"* **{entry.min_value}**: {entry.description}\\n\"\n            else:\n                formatted_scale += f\"* **{entry.min_value} to {entry.max_value}**: {entry.description}\\n\"\n\n        return formatted_scale"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 337,
    "end_line": 347,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion_model\"] = self.completion_model.model_dump(**kwargs)\n        dump[\"value_function_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        if self.coding_value_function:\n            dump[\"coding_value_function\"] = self.coding_value_function.model_dump(\n                **kwargs\n            )\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "TerminalValueFunction",
    "file": "terminal.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 350,
    "end_line": 373,
    "code": "def model_validate(cls, obj: Any) -> \"TerminalValueFunction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion_model\", None)\n            value_function_class_path = obj.pop(\"value_function_class\", None)\n\n            if completion_data:\n                obj[\"completion_model\"] = CompletionModel.model_validate(\n                    completion_data\n                )\n            else:\n                obj[\"completion_model\"] = None\n\n            if value_function_class_path:\n                module_name, class_name = value_function_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                value_function_class = getattr(module, class_name)\n                instance = value_function_class(**obj)\n            else:\n                instance = cls(**obj)\n\n            return instance\n\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CodingValueFunction",
    "file": "coding.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 39,
    "end_line": 43,
    "code": "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._terminal_function = TerminalValueFunction(\n            completion_model=self.completion_model\n        )"
  },
  {
    "type": "function",
    "name": "get_reward",
    "class_name": "CodingValueFunction",
    "file": "coding.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 45,
    "end_line": 131,
    "code": "def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        if node.observation.expect_correction and self.correction_award is not None:\n            # Start with the base correction award\n            correction_penalty = 0\n            current_node = node.parent\n\n            # Check parent nodes for expect_correction\n            while (\n                current_node\n                and current_node.observation\n                and current_node.observation.expect_correction\n            ):\n                if (\n                    current_node.observation\n                    and current_node.observation.expect_correction\n                ):\n                    correction_penalty += 25\n                current_node = current_node.parent\n\n            # Calculate final reward with penalty, minimum of -100\n            final_reward = max(-100, self.correction_award - correction_penalty)\n            logger.info(\n                f\"Expecting a correction, base reward {self.correct..."
  },
  {
    "type": "function",
    "name": "get_reward",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 38,
    "end_line": 129,
    "code": "def get_reward(self, node: Node) -> Tuple[Reward, Optional[Completion]]:\n        # First get coding value function result if enabled\n        coding_reward = None\n        if self.coding_value_function:\n            coding_reward, _ = self.coding_value_function.get_reward(node)\n\n        messages = self.message_generator.generate(node)\n        if messages is None:\n            messages = []  # Ensure we have a valid list\n        last_message = \"\"\n        # Handle automatic reward cases by adding them to the message\n        if node.observation.expect_correction and self.correction_award is not None:\n            last_message += \"# Automatic Reward Assessment\\n\"\n            last_message += f\"Action expects a correction. Suggested value: {self.correction_award}\\n\\n\"\n\n        if node.action.name in [\"Reject\", \"Error\"]:\n            last_message += \"# Automatic Reward Assessment\\n\"\n            last_message += (\n                f\"{node.action.name} action detected. Suggested value: -100\\n\\n\"\n      ..."
  },
  {
    "type": "function",
    "name": "_create_system_prompt",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 131,
    "end_line": 163,
    "code": "def _create_system_prompt(\n        self, node: Node, coding_reward: Optional[Reward] = None\n    ) -> str:\n        base_prompt = self._build_system_prompt(node)\n\n        if coding_reward:\n            base_prompt += \"\"\"\n# Coding Value Function Context\n<coding_assessment>\nThe automated coding value function has provided the following assessment:\n* Value: {coding_reward.value}\n* Explanation: {coding_reward.explanation}\nIt's based on coding heuristics, and may not be perfect.\n\nEvaluation Guidelines:\n1. Consider the automated assessment above\n2. Either reinforce its reasoning or explain why you disagree\n3. Provide your own comprehensive evaluation\n</coding_assessment>\n\"\"\".format(coding_reward=coding_reward)\n\n        if self.include_search_tree:\n            base_prompt += \"\"\"\n# Search Tree Analysis\n<search_tree_guidelines>\n* Use the provided search tree visualization to understand the full solution space\n* Consider any existing finished states in your evaluation\n* Guide the agent toward novel..."
  },
  {
    "type": "function",
    "name": "_build_system_prompt",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 165,
    "end_line": 207,
    "code": "def _build_system_prompt(self, node: Node):\n        action = Action.get_action_by_args_class(type(node.action))\n        trajectory_length = len(node.get_trajectory())\n\n        base_prompt = action.get_value_function_prompt()\n\n        criteria_list = action.get_evaluation_criteria(trajectory_length)\n        reward_scale_list = action.get_reward_scale(trajectory_length)\n        min_value, max_value = action.get_reward_range(trajectory_length)\n\n        evaluation_criteria_text = ValueFunction._format_evaluation_criteria(\n            criteria_list\n        )\n        reward_scale_text = ValueFunction._format_reward_scale(\n            reward_scale_list, min_value, max_value\n        )\n\n        prompt = base_prompt + evaluation_criteria_text + reward_scale_text\n\n        prompt += f\"\"\"\n# Feedback Structure:\n\n* **Explanation**: Offer a detailed explanation and reasoning behind your decision, focusing on the **last executed action**, its relation to previous actions and its impact.\n* **Feedback to..."
  },
  {
    "type": "function",
    "name": "_format_evaluation_criteria",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 210,
    "end_line": 214,
    "code": "def _format_evaluation_criteria(criteria_list: List[str]) -> str:\n        formatted_criteria = \"\\n# Evaluation Criteria:\\n\"\n        for criterion in criteria_list:\n            formatted_criteria += f\"* {criterion}\\n\"\n        return formatted_criteria"
  },
  {
    "type": "function",
    "name": "_format_reward_scale",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 217,
    "end_line": 231,
    "code": "def _format_reward_scale(\n        reward_scale_list: List[RewardScaleEntry], min_value: int, max_value: int\n    ) -> str:\n        formatted_scale = \"\\n# Reward Scale and Guidelines:\\n\"\n        sorted_entries = sorted(reward_scale_list, key=lambda x: -x.max_value)\n\n        formatted_scale += f\"The reward value must be an integer between {min_value} and {max_value}, where:\\n\\n\"\n\n        for entry in sorted_entries:\n            if entry.min_value == entry.max_value:\n                formatted_scale += f\"* **{entry.min_value}**: {entry.description}\\n\"\n            else:\n                formatted_scale += f\"* **{entry.min_value} to {entry.max_value}**: {entry.description}\\n\"\n\n        return formatted_scale"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 233,
    "end_line": 243,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"completion_model\"] = self.completion_model.model_dump(**kwargs)\n        dump[\"value_function_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        if self.coding_value_function:\n            dump[\"coding_value_function\"] = self.coding_value_function.model_dump(\n                **kwargs\n            )\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 246,
    "end_line": 277,
    "code": "def model_validate(cls, obj: Any) -> \"ValueFunction\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            completion_data = obj.pop(\"completion_model\", None)\n            value_function_class_path = obj.pop(\"value_function_class\", None)\n            coding_value_function_data = obj.pop(\"coding_value_function\", None)\n\n            if completion_data:\n                obj[\"completion_model\"] = CompletionModel.model_validate(\n                    completion_data\n                )\n            else:\n                obj[\"completion_model\"] = None\n\n            if coding_value_function_data:\n                from moatless_qa.value_function.coding import CodingValueFunction\n\n                obj[\"coding_value_function\"] = CodingValueFunction.model_validate(\n                    coding_value_function_data\n                )\n\n            if value_function_class_path:\n                module_name, class_name = value_function_class_path.rsplit(\".\", 1)\n                module = importlib..."
  },
  {
    "type": "function",
    "name": "_combine_rewards",
    "class_name": "ValueFunction",
    "file": "base.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/value_function",
    "start_line": 279,
    "end_line": 287,
    "code": "def _combine_rewards(self, reward1: Reward, reward2: Reward) -> Reward:\n        \"\"\"Combine two rewards by averaging their values and concatenating explanations.\"\"\"\n        combined_value = (reward1.value + reward2.value) // 2  # Integer division\n        combined_explanation = (\n            \"Combined Assessment:\\n\"\n            f\"1. General Assessment: {reward1.explanation}\\n\"\n            f\"2. Code Quality Assessment: {reward2.explanation}\"\n        )\n        return Reward(value=combined_value, explanation=combined_explanation)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 24,
    "end_line": 37,
    "code": "def __init__(self, **data):\n        super().__init__(**data)\n        from git import Repo\n\n        self._repo = Repo(path=self.repo_path)\n\n        if not self._repo.heads:\n            logger.error(f\"Repo at {self.repo_path} has no branches\")\n\n        if data.get(\"commit\"):\n            checkout_commit(self.repo_path, data[\"commit\"])\n\n        self.current_commit = self._repo.head.commit.hexsha\n        self.initial_commit = self.current_commit"
  },
  {
    "type": "function",
    "name": "from_repo",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 40,
    "end_line": 95,
    "code": "def from_repo(cls, git_repo_url: str, repo_path: str, commit: Optional[str] = None):\n        logger.info(\n            f\"Create GitRepository for {git_repo_url} with commit {commit} on path {repo_path} \"\n        )\n        \n        # 检查目标路径是否存在，如果存在但有问题则删除\n        if os.path.exists(repo_path):\n            try:\n                # 尝试检查这是否是一个有效的git仓库\n                import subprocess\n                result = subprocess.run(\n                    [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\n                    cwd=repo_path,\n                    capture_output=True,\n                    check=True,\n                )\n                # 如果是有效仓库但需要特定commit，我们检查commit是否存在\n                if commit:\n                    try:\n                        subprocess.run(\n                            [\"git\", \"cat-file\", \"-e\", commit],\n                            cwd=repo_path,\n                            capture_output=True,\n                            check=True,\n                        )\n                    ..."
  },
  {
    "type": "function",
    "name": "from_dict",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 98,
    "end_line": 103,
    "code": "def from_dict(cls, data: dict):\n        return cls.from_repo(\n            git_repo_url=data[\"repo_url\"],\n            repo_path=data[\"path\"],\n            commit=data[\"commit\"],\n        )"
  },
  {
    "type": "function",
    "name": "restore_from_snapshot",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 105,
    "end_line": 116,
    "code": "def restore_from_snapshot(self, snapshot: dict):\n        self.current_commit = snapshot[\"commit\"]\n\n        if snapshot.get(\"patch\"):\n            self.current_diff = snapshot[\"patch\"]\n\n        try:\n            self.clean_untracked_files()\n            self._repo.git.reset(\"--hard\", \"HEAD\")  # Discard all local changes\n            self._repo.git.checkout(\"-f\", self.current_commit)  # Force checkout\n        except Exception as e:\n            logger.error(f\"Error checking out commit {self.current_commit}: {e}\")"
  },
  {
    "type": "function",
    "name": "clean_untracked_files",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 120,
    "end_line": 125,
    "code": "def clean_untracked_files(self):\n        try:\n            self._repo.git.clean(\"-fd\")\n            logger.info(\"Removed all untracked files.\")\n        except Exception as e:\n            logger.error(f\"Error removing untracked files: {e}\")"
  },
  {
    "type": "function",
    "name": "dict",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 127,
    "end_line": 133,
    "code": "def dict(self):\n        return {\n            \"type\": \"git\",\n            \"repo_path\": self.repo_path,\n            \"git_repo_url\": self.repo_url,\n            \"commit\": self.initial_commit,\n        }"
  },
  {
    "type": "function",
    "name": "snapshot",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 135,
    "end_line": 139,
    "code": "def snapshot(self) -> dict:\n        return {\n            \"commit\": self.current_commit,\n            \"patch\": self.diff(),\n        }"
  },
  {
    "type": "function",
    "name": "create_empty_file",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 141,
    "end_line": 143,
    "code": "def create_empty_file(self, file_path: str):\n        super().create_empty_file(file_path)\n        self.commit(file_path)"
  },
  {
    "type": "function",
    "name": "save_file",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 145,
    "end_line": 148,
    "code": "def save_file(self, file_path: str, updated_content: Optional[str] = None):\n        file = super().save_file(file_path, updated_content)\n        self.commit(file_path)\n        return file"
  },
  {
    "type": "function",
    "name": "commit",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 150,
    "end_line": 188,
    "code": "def commit(self, file_path: str | None = None):\n        commit_message = self.commit_message(file_path)\n\n        try:\n            if file_path:\n                self._repo.index.add([file_path])\n            else:\n                self._repo.index.add(\"*\")\n            self._repo.index.commit(commit_message)\n            self.current_commit = self._repo.head.commit.hexsha\n\n            logger.info(\n                f\"Committed changes to git with message '{commit_message}' and commit hash '{self.current_commit}'\"\n            )\n            self.clean_untracked_files()  # Clean untracked files after commit\n        except FileNotFoundError as e:\n            logger.error(\n                f\"Error committing changes: Current working directory not found. {e}\"\n            )\n            # Attempt to change to the repository directory\n            try:\n                os.chdir(self.repo_path)\n                logger.info(f\"Changed working directory to {self.repo_path}\")\n                # Retry the commit..."
  },
  {
    "type": "function",
    "name": "commit_message",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 190,
    "end_line": 213,
    "code": "def commit_message(self, file_path: str | None = None) -> str:\n        if file_path:\n            diff = self._repo.git.diff(\"HEAD\", file_path)\n        else:\n            diff = self._repo.git.diff(\"HEAD\")\n\n        if not diff:\n            return \"No changes.\"\n\n        if self.completion and self.generate_commit_message:\n            prompt = f\"Generate a concise commit message for the following git diff\"\n            if file_path:\n                prompt += f\" of file {file_path}\"\n            prompt += f\":\\n\\n{diff}\\n\\nCommit message:\"\n\n            try:\n                response = self.completion.create_text_completion(\n                    messages=[ChatCompletionUserMessage(role=\"user\", content=prompt)],\n                )\n                return response.choices[0].message.content.strip()\n            except Exception as e:\n                logging.error(f\"Error generating commit message: {e}\")\n\n        return \"Automated commit by Moatless Tools\""
  },
  {
    "type": "function",
    "name": "diff",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 215,
    "end_line": 236,
    "code": "def diff(self, ignore_paths: Optional[List[str]] = None):\n        logger.info(f\"Get diff between {self.initial_commit} and {self.current_commit}\")\n\n        if ignore_paths:\n            exclude_patterns = [f\":(exclude){path}\" for path in ignore_paths]\n            diff_command = [\n                self.initial_commit,\n                self.current_commit,\n                \"--\",\n            ] + exclude_patterns\n            return self._repo.git.diff(*diff_command)\n        else:\n            try:\n                return self._repo.git.diff(self.initial_commit, self.current_commit)\n            except Exception as e:\n                logger.error(f\"Error getting diff: {e}\")\n\n            if self.current_diff:\n                logger.info(f\"Returning cached diff\")\n                return self.current_diff\n            else:\n                return None"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "GitRepository",
    "file": "git.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 238,
    "end_line": 247,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump.update(\n            {\n                \"repo_path\": self.repo_path,\n                \"git_repo_url\": self.repo_url,\n                \"commit\": self.initial_commit,\n            }\n        )\n        return dump"
  },
  {
    "type": "function",
    "name": "get_file_content",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 10,
    "end_line": 11,
    "code": "def get_file_content(self, file_path: str) -> Optional[str]:\n        pass"
  },
  {
    "type": "function",
    "name": "file_exists",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 13,
    "end_line": 14,
    "code": "def file_exists(self, file_path: str) -> bool:\n        return True"
  },
  {
    "type": "function",
    "name": "save_file",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 16,
    "end_line": 17,
    "code": "def save_file(self, file_path: str, updated_content: str):\n        pass"
  },
  {
    "type": "function",
    "name": "is_directory",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 19,
    "end_line": 20,
    "code": "def is_directory(self, file_path: str) -> bool:\n        return False"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 22,
    "end_line": 27,
    "code": "def model_dump(self, **kwargs) -> Dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"repository_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 30,
    "end_line": 45,
    "code": "def model_validate(cls, obj: Any) -> \"Repository\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            repository_class_path = obj.pop(\"repository_class\", None)\n\n            if repository_class_path:\n                module_name, class_name = repository_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                repository_class = getattr(module, class_name)\n                instance = repository_class(**obj)\n            else:\n                return None\n\n            return instance\n\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "list_directory",
    "class_name": "Repository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 48,
    "end_line": 53,
    "code": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        \"\"\"\n        Lists files and directories in the specified directory.\n        Returns a dictionary with 'files' and 'directories' lists.\n        \"\"\"\n        pass"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 59,
    "end_line": 61,
    "code": "def __init__(self, files: Dict[str, str] = None, **kwargs):\n        files = files or {}\n        super().__init__(files=files, **kwargs)"
  },
  {
    "type": "function",
    "name": "get_file_content",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 63,
    "end_line": 64,
    "code": "def get_file_content(self, file_path: str) -> Optional[str]:\n        return self.files.get(file_path)"
  },
  {
    "type": "function",
    "name": "file_exists",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 66,
    "end_line": 67,
    "code": "def file_exists(self, file_path: str) -> bool:\n        return file_path in self.files"
  },
  {
    "type": "function",
    "name": "save_file",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 69,
    "end_line": 70,
    "code": "def save_file(self, file_path: str, updated_content: str):\n        self.files[file_path] = updated_content"
  },
  {
    "type": "function",
    "name": "is_directory",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 72,
    "end_line": 73,
    "code": "def is_directory(self, file_path: str) -> bool:\n        return False"
  },
  {
    "type": "function",
    "name": "list_directory",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 75,
    "end_line": 76,
    "code": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        return {\"files\": [], \"directories\": []}"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 78,
    "end_line": 79,
    "code": "def model_dump(self) -> Dict:\n        return {\"files\": self.files}"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "InMemRepository",
    "file": "repository.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 82,
    "end_line": 83,
    "code": "def model_validate(cls, obj: Dict):\n        return cls(files=obj.get(\"files\", {}))"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 29,
    "end_line": 34,
    "code": "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._content = kwargs.get(\"_content\", \"\")\n        self._repo_path = kwargs.get(\"repo_path\", None)\n        self._module = kwargs.get(\"_module\", None)\n        self._last_modified = kwargs.get(\"_last_modified\", None)"
  },
  {
    "type": "function",
    "name": "from_file",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 37,
    "end_line": 38,
    "code": "def from_file(cls, repo_path: str, file_path: str):\n        return cls(file_path=file_path, repo_path=repo_path)"
  },
  {
    "type": "function",
    "name": "from_content",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 41,
    "end_line": 42,
    "code": "def from_content(cls, file_path: str, content: str):\n        return cls(file_path=file_path, _content=content)"
  },
  {
    "type": "function",
    "name": "get_file_content",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 44,
    "end_line": 45,
    "code": "def get_file_content(self, file_path: str) -> Optional[str]:\n        return"
  },
  {
    "type": "function",
    "name": "has_been_modified",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 47,
    "end_line": 65,
    "code": "def has_been_modified(self) -> bool:\n        if not self._repo_path:\n            raise ValueError(\"CodeFile must be initialized with a repo path\")\n\n        try:\n            full_file_path = os.path.join(self._repo_path, self.file_path)\n            current_mod_time = datetime.fromtimestamp(os.path.getmtime(full_file_path))\n            is_modified = (\n                self._last_modified is None or current_mod_time > self._last_modified\n            )\n            if is_modified and self._last_modified:\n                logger.debug(\n                    f\"File {self.file_path} has been modified: {self._last_modified} -> {current_mod_time}\"\n                )\n\n            return is_modified\n        except FileNotFoundError:\n            logger.warning(f\"File {self.file_path} not found\")\n            return False"
  },
  {
    "type": "function",
    "name": "save",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 67,
    "end_line": 73,
    "code": "def save(self, updated_content: str):\n        full_file_path = os.path.join(self._repo_path, self.file_path)\n        with open(full_file_path, \"w\") as f:\n            f.write(updated_content)\n            self._content = updated_content\n            self._last_modified = datetime.fromtimestamp(os.path.getmtime(f.name))\n            self._module = None"
  },
  {
    "type": "function",
    "name": "supports_codeblocks",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 76,
    "end_line": 77,
    "code": "def supports_codeblocks(self):\n        return self.module is not None"
  },
  {
    "type": "function",
    "name": "content",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 80,
    "end_line": 87,
    "code": "def content(self):\n        if self.has_been_modified():\n            with open(os.path.join(self._repo_path, self.file_path)) as f:\n                self._content = f.read()\n                self._last_modified = datetime.fromtimestamp(os.path.getmtime(f.name))\n                self._module = None\n\n        return self._content"
  },
  {
    "type": "function",
    "name": "module",
    "class_name": "CodeFile",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 90,
    "end_line": 98,
    "code": "def module(self) -> Module | None:\n        if self._module is None or self.has_been_modified() and self.content.strip():\n            parser = get_parser_by_path(self.file_path)\n            if parser:\n                self._module = parser.parse(self.content)\n            else:\n                return None\n\n        return self._module"
  },
  {
    "type": "function",
    "name": "repo_dir",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 105,
    "end_line": 106,
    "code": "def repo_dir(self):\n        return self.repo_path"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 108,
    "end_line": 109,
    "code": "def model_dump(self) -> Dict:\n        return {\"type\": \"file\", \"repo_path\": self.repo_path}"
  },
  {
    "type": "function",
    "name": "get_full_path",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 111,
    "end_line": 135,
    "code": "def get_full_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the full file path by combining repo_path and file_path.\n        All paths are treated as relative to repo_path, even if they start with '/'.\n\n        Args:\n            file_path: The file path to process (e.g., 'file.py' or '/src/file.py')\n\n        Returns:\n            str: The full path relative to repo_path\n        \"\"\"\n        # Strip leading slash if present\n        file_path = file_path.lstrip(\"/\")\n\n        # If file_path starts with repo_dir, make it relative\n        if file_path.startswith(self.repo_dir):\n            file_path = file_path.replace(self.repo_dir, \"\").lstrip(\"/\")\n\n        # Claude sets /repo/, remove it\n        if file_path.startswith(\"/repo/\"):\n            file_path = file_path.replace(\"/repo/\", \"\")\n        elif file_path.startswith(\"repo/\"):\n            file_path = file_path.replace(\"repo/\", \"\")\n\n        return os.path.join(self.repo_path, file_path)"
  },
  {
    "type": "function",
    "name": "get_relative_path",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 137,
    "end_line": 149,
    "code": "def get_relative_path(self, file_path: str) -> str:\n        \"\"\"\n        Generates the relative path by removing repo_path from the full path.\n\n        Args:\n            file_path: The file path to process\n\n        Returns:\n            str: The relative path\n        \"\"\"\n\n        full_path = self.get_full_path(file_path)\n        return full_path.replace(self.repo_path, \"\").lstrip(\"/\")"
  },
  {
    "type": "function",
    "name": "get_file_content",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 151,
    "end_line": 156,
    "code": "def get_file_content(self, file_path: str) -> str | None:\n        full_path = self.get_full_path(file_path)\n        if os.path.exists(full_path):\n            with open(full_path) as f:\n                return f.read()\n        return None"
  },
  {
    "type": "function",
    "name": "snapshot",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 158,
    "end_line": 159,
    "code": "def snapshot(self) -> dict:\n        return {}"
  },
  {
    "type": "function",
    "name": "restore_from_snapshot",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 161,
    "end_line": 162,
    "code": "def restore_from_snapshot(self, snapshot: dict):\n        pass"
  },
  {
    "type": "function",
    "name": "path",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 165,
    "end_line": 166,
    "code": "def path(self):\n        return self.repo_path"
  },
  {
    "type": "function",
    "name": "is_directory",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 168,
    "end_line": 169,
    "code": "def is_directory(self, path: str):\n        return os.path.isdir(self.get_full_path(path))"
  },
  {
    "type": "function",
    "name": "get_file",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 171,
    "end_line": 187,
    "code": "def get_file(self, file_path: str):\n        if file_path.startswith(self.repo_dir):\n            file_path = file_path.replace(self.repo_dir, \"\")\n            if file_path.startswith(\"/\"):\n                file_path = file_path[1:]\n\n        full_file_path = self.get_full_path(file_path)\n        if not os.path.exists(full_file_path):\n            logger.debug(f\"File not found: {full_file_path}\")\n            return None\n\n        if not os.path.isfile(full_file_path):\n            logger.warning(f\"{full_file_path} is not a file\")\n            return None\n\n        file = CodeFile.from_file(file_path=file_path, repo_path=self.repo_path)\n        return file"
  },
  {
    "type": "function",
    "name": "file_exists",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 189,
    "end_line": 191,
    "code": "def file_exists(self, file_path: str):\n        full_path = Path(self.get_full_path(file_path))\n        return full_path.exists()"
  },
  {
    "type": "function",
    "name": "create_empty_file",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 193,
    "end_line": 200,
    "code": "def create_empty_file(self, file_path: str):\n        full_file_path = self.get_full_path(file_path)\n        if not os.path.exists(os.path.dirname(full_file_path)):\n            logger.info(f\"Creating directory for {full_file_path}\")\n            os.makedirs(os.path.dirname(full_file_path))\n\n        with open(full_file_path, \"w\") as f:\n            f.write(\"\")"
  },
  {
    "type": "function",
    "name": "save_file",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 202,
    "end_line": 209,
    "code": "def save_file(self, file_path: str, updated_content: str):\n        assert updated_content, \"Updated content must be provided\"\n\n        if not self.file_exists(file_path):\n            file = self.create_empty_file(file_path)\n\n        with open(self.get_full_path(file_path), \"w\") as f:\n            f.write(updated_content)"
  },
  {
    "type": "function",
    "name": "matching_files",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 211,
    "end_line": 281,
    "code": "def matching_files(self, file_pattern: str):\n        \"\"\"\n        Returns a list of files matching the given pattern within the repository.\n\n        Parameters:\n            file_pattern (str): The glob pattern to match files.\n\n        Returns:\n            List[str]: A list of relative file paths matching the pattern.\n        \"\"\"\n\n        try:\n            # If absolute path, log warning and remove first slash\n            if file_pattern.startswith(\"/\"):\n                logger.warning(\n                    f\"Converting absolute path {file_pattern} to relative path\"\n                )\n                file_pattern = file_pattern[1:]\n\n            # Split pattern into directory and filename parts\n            pattern_parts = file_pattern.split(\"/\")\n            filename = pattern_parts[-1]\n\n            # Fix invalid ** patterns in filename (e.g. **.py -> **/*.py)\n            if \"**.\" in filename:\n                filename = filename.replace(\"**.\", \"**/*.\")\n                pattern_parts[-1] = filen..."
  },
  {
    "type": "function",
    "name": "find_files",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 283,
    "end_line": 289,
    "code": "def find_files(self, file_patterns: list[str]) -> set[str]:\n        found_files = set()\n        for file_pattern in file_patterns:\n            matched_files = self.matching_files(file_pattern)\n            found_files.update(matched_files)\n\n        return found_files"
  },
  {
    "type": "function",
    "name": "has_matching_files",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 291,
    "end_line": 296,
    "code": "def has_matching_files(self, file_pattern: str):\n        for _matched_file in glob.iglob(\n            file_pattern, root_dir=self.repo_path, recursive=True\n        ):\n            return True\n        return False"
  },
  {
    "type": "function",
    "name": "file_match",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 298,
    "end_line": 306,
    "code": "def file_match(self, file_pattern: str, file_path: str):\n        match = False\n        for matched_file in glob.iglob(\n            file_pattern, root_dir=self.repo_path, recursive=True\n        ):\n            if matched_file == file_path:\n                match = True\n                break\n        return match"
  },
  {
    "type": "function",
    "name": "find_by_pattern",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 308,
    "end_line": 314,
    "code": "def find_by_pattern(self, patterns: list[str]) -> List[str]:\n        matched_files = []\n        for pattern in patterns:\n            matched_files.extend(\n                glob.iglob(f\"**/{pattern}\", root_dir=self.repo_path, recursive=True)\n            )\n        return matched_files"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 316,
    "end_line": 320,
    "code": "def model_dump(self) -> Dict:\n        return {\n            \"type\": \"file\",\n            \"path\": self.repo_path,\n        }"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 323,
    "end_line": 325,
    "code": "def model_validate(cls, obj: Dict):\n        repo = cls(repo_path=obj[\"path\"])\n        return repo"
  },
  {
    "type": "function",
    "name": "find_exact_matches",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 327,
    "end_line": 412,
    "code": "def find_exact_matches(\n        self, search_text: str, file_pattern: Optional[str] = None\n    ) -> List[tuple[str, int]]:\n        \"\"\"\n        Uses grep to search for exact text matches in files.\n        \"\"\"\n        matches = []\n        if not file_pattern:\n            file_pattern = \".\"\n\n        try:\n            # Remove '**' and everything after it\n            grep_pattern = file_pattern\n            if \"**\" in grep_pattern:\n                grep_pattern = grep_pattern.split(\"**\")[0]\n\n            if not grep_pattern:\n                grep_pattern = \".\"\n\n            # Always escape special regex characters to handle them literally\n            escaped_search_text = (\n                search_text.replace(\"[\", \"\\\\[\")\n                .replace(\"]\", \"\\\\]\")\n                .replace(\".\", \"\\\\.\")\n                .replace(\"+\", \"\\\\+\")\n                .replace(\"*\", \"\\\\*\")\n                .replace(\"?\", \"\\\\?\")\n                .replace(\"|\", \"\\\\|\")\n                .replace(\"{\", \"\\\\{\")\n                .rep..."
  },
  {
    "type": "function",
    "name": "list_directory",
    "class_name": "FileRepository",
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 414,
    "end_line": 441,
    "code": "def list_directory(self, directory_path: str = \"\") -> Dict[str, List[str]]:\n        \"\"\"\n        Lists files and directories in the specified directory.\n        Returns a dictionary with 'files' and 'directories' lists.\n        \"\"\"\n        full_path = self.get_full_path(directory_path)\n\n        if not os.path.exists(full_path):\n            return {\"files\": [], \"directories\": []}\n\n        if not os.path.isdir(full_path):\n            return {\"files\": [], \"directories\": []}\n\n        files = []\n        directories = []\n\n        for entry in os.listdir(full_path):\n            entry_path = os.path.join(full_path, entry)\n            relative_path = os.path.relpath(entry_path, self.repo_path).replace(\n                os.sep, \"/\"\n            )\n\n            if os.path.isfile(entry_path):\n                files.append(relative_path)\n            elif os.path.isdir(entry_path):\n                directories.append(relative_path)\n\n        return {\"files\": sorted(files), \"directories\": sorted(directories..."
  },
  {
    "type": "function",
    "name": "remove_duplicate_lines",
    "class_name": null,
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 444,
    "end_line": 457,
    "code": "def remove_duplicate_lines(replacement_lines, original_lines):\n    \"\"\"\n    Removes overlapping lines at the end of replacement_lines that match the beginning of original_lines.\n    \"\"\"\n    if not replacement_lines or not original_lines:\n        return replacement_lines\n\n    max_overlap = min(len(replacement_lines), len(original_lines))\n\n    for overlap in range(max_overlap, 0, -1):\n        if replacement_lines[-overlap:] == original_lines[:overlap]:\n            return replacement_lines[:-overlap]\n\n    return replacement_lines"
  },
  {
    "type": "function",
    "name": "do_diff",
    "class_name": null,
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/repository",
    "start_line": 460,
    "end_line": 471,
    "code": "def do_diff(\n    file_path: str, original_content: str, updated_content: str\n) -> Optional[str]:\n    return \"\".join(\n        difflib.unified_diff(\n            original_content.strip().splitlines(True),\n            updated_content.strip().splitlines(True),\n            fromfile=file_path,\n            tofile=file_path,\n            lineterm=\"\\n\",\n        )\n    )"
  },
  {
    "type": "function",
    "name": "supports_codeblocks",
    "class_name": null,
    "file": "__init__.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 8,
    "end_line": 9,
    "code": "def supports_codeblocks(path: str):\n    return path.endswith(\".py\")"
  },
  {
    "type": "function",
    "name": "get_parser_by_path",
    "class_name": null,
    "file": "__init__.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 12,
    "end_line": 18,
    "code": "def get_parser_by_path(file_path: str) -> CodeParser | None:\n    if file_path.endswith(\".py\"):\n        return PythonParser()\n    elif file_path.endswith(\".java\"):\n        return JavaParser()\n    else:\n        return None"
  },
  {
    "type": "function",
    "name": "__post_init__",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 26,
    "end_line": 28,
    "code": "def __post_init__(self):\n        if not self.code_block.type == CodeBlockType.MODULE:\n            self.code_block.type = CodeBlockType.MODULE"
  },
  {
    "type": "function",
    "name": "__getattr__",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 31,
    "end_line": 32,
    "code": "def __getattr__(self, name):\n        return getattr(self.code_block, name)"
  },
  {
    "type": "function",
    "name": "module",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 35,
    "end_line": 36,
    "code": "def module(self) -> \"Module\":  # noqa: F821\n        return self"
  },
  {
    "type": "function",
    "name": "find_span_by_id",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 38,
    "end_line": 39,
    "code": "def find_span_by_id(self, span_id: str) -> BlockSpan | None:\n        return self.spans_by_id.get(span_id)"
  },
  {
    "type": "function",
    "name": "sum_tokens",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 41,
    "end_line": 51,
    "code": "def sum_tokens(self, span_ids: set[str] | None = None):\n        tokens = self.tokens\n        if span_ids:\n            for span_id in span_ids:\n                span = self.spans_by_id.get(span_id)\n                if span:\n                    tokens += span.tokens\n            return tokens\n\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens"
  },
  {
    "type": "function",
    "name": "show_spans",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 53,
    "end_line": 111,
    "code": "def show_spans(\n        self,\n        span_ids: list[str] | None = None,\n        show_related: bool = False,\n        max_tokens: int = 2000,\n    ) -> bool:\n        for span in self.spans_by_id.values():\n            span.visible = False\n\n        checked_span_ids = set()\n        span_ids_to_check = []\n\n        tokens = 0\n        for span_id in span_ids:\n            span = self.spans_by_id.get(span_id)\n            if not span:\n                return False\n\n            tokens += span.tokens\n            checked_span_ids.add(span_id)\n            span_ids_to_check.append(span_id)\n            span.visible = True\n\n        if not show_related:\n            return True\n\n        # Add imports from module\n        for span in self.spans.values():\n            if (\n                span.span_type == SpanType.INITATION\n                and span.span_id not in checked_span_ids\n            ):\n                span_ids_to_check.append(span.span_id)\n\n        while span_ids_to_check:\n            span_id = span_..."
  },
  {
    "type": "function",
    "name": "find_related_span_ids",
    "class_name": "Module",
    "file": "module.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 113,
    "end_line": 149,
    "code": "def find_related_span_ids(self, span_id: Optional[str] = None) -> set[str]:\n        related_span_ids = set()\n\n        blocks = self.find_blocks_by_span_id(span_id)\n        for block in blocks:\n            # Find successors (outgoing relationships)\n            successors = list(self._graph.successors(block.path_string()))\n            for succ in successors:\n                node_data = self._graph.nodes[succ]\n                if \"block\" in node_data:\n                    span = node_data[\"block\"].belongs_to_span\n                    related_span_ids.add(span.span_id)\n\n            # Find predecessors (incoming relationships)\n            predecessors = list(self._graph.predecessors(block.path_string()))\n            for pred in predecessors:\n                node_data = self._graph.nodes[pred]\n                if \"block\" in node_data:\n                    span = node_data[\"block\"].belongs_to_span\n                    related_span_ids.add(span.span_id)\n\n            # Always add parent class initati..."
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "CodeBlockTypeGroup",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 31,
    "end_line": 32,
    "code": "def __str__(self):\n        return self.value"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CodeBlockType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 74,
    "end_line": 76,
    "code": "def __init__(self, value: str, group: CodeBlockTypeGroup):\n        self._value = value\n        self.group = group"
  },
  {
    "type": "function",
    "name": "display_name",
    "class_name": "CodeBlockType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 79,
    "end_line": 80,
    "code": "def display_name(self):\n        return self._value"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "CodeBlockType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 82,
    "end_line": 83,
    "code": "def __str__(self):\n        return self._value"
  },
  {
    "type": "function",
    "name": "from_string",
    "class_name": "CodeBlockType",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 86,
    "end_line": 109,
    "code": "def from_string(cls, tag: str) -> Optional[\"CodeBlockType\"]:\n        if not tag.startswith(\"definition\"):\n            return None\n\n        tag_to_block_type = {\n            \"definition.assignment\": cls.ASSIGNMENT,\n            \"definition.block_delimiter\": cls.BLOCK_DELIMITER,\n            \"definition.call\": cls.CALL,\n            \"definition.class\": cls.CLASS,\n            \"definition.code\": cls.CODE,\n            \"definition.comment\": cls.COMMENT,\n            \"definition.compound\": cls.COMPOUND,\n            \"definition.constructor\": cls.CONSTRUCTOR,\n            \"definition.dependent_clause\": cls.DEPENDENT_CLAUSE,\n            \"definition.error\": cls.ERROR,\n            \"definition.export\": cls.EXPORT,\n            \"definition.function\": cls.FUNCTION,\n            \"definition.import\": cls.IMPORT,\n            \"definition.module\": cls.MODULE,\n            \"definition.statement\": cls.STATEMENT,\n            \"definition.test_suite\": cls.TEST_SUITE,\n            \"definition.test_case\": cls.TEST_CASE,\n..."
  },
  {
    "type": "function",
    "name": "from_block_paths",
    "class_name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 137,
    "end_line": 142,
    "code": "def from_block_paths(block_paths: list[BlockPath]) -> \"PathTree\":\n        tree = PathTree()\n        for block_path in block_paths:\n            tree.add_to_tree(block_path)\n\n        return tree"
  },
  {
    "type": "function",
    "name": "child_tree",
    "class_name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 144,
    "end_line": 145,
    "code": "def child_tree(self, key: str) -> Optional[\"PathTree\"]:\n        return self.tree.get(key, None)"
  },
  {
    "type": "function",
    "name": "merge",
    "class_name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 147,
    "end_line": 154,
    "code": "def merge(self, other: \"PathTree\"):\n        if other.show:\n            self.show = True\n\n        for key, value in other.tree.items():\n            if key not in self.tree:\n                self.tree[key] = PathTree()\n            self.tree[key].merge(value)"
  },
  {
    "type": "function",
    "name": "extend_tree",
    "class_name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 156,
    "end_line": 158,
    "code": "def extend_tree(self, paths: list[list[str]]):\n        for path in paths:\n            self.add_to_tree(path)"
  },
  {
    "type": "function",
    "name": "add_to_tree",
    "class_name": "PathTree",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 160,
    "end_line": 179,
    "code": "def add_to_tree(self, path: list[str]):\n        if path is None:\n            return\n\n        if len(path) == 0:\n            self.show = True\n            return\n\n        if len(path) == 1:\n            if path[0] not in self.tree:\n                self.tree[path[0]] = PathTree(show=True)\n            else:\n                self.tree[path[0]].show = True\n\n            return\n\n        if path[0] not in self.tree:\n            self.tree[path[0]] = PathTree(show=False)\n\n        self.tree[path[0]].add_to_tree(path[1:])"
  },
  {
    "type": "function",
    "name": "__post_init__",
    "class_name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 213,
    "end_line": 215,
    "code": "def __post_init__(self):\n        if not self.external_path and not self.path:\n            raise ValueError(\"Cannot create Reference without external_path or path.\")"
  },
  {
    "type": "function",
    "name": "__hash__",
    "class_name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 217,
    "end_line": 218,
    "code": "def __hash__(self):\n        return hash((self.scope, tuple(self.path)))"
  },
  {
    "type": "function",
    "name": "__eq__",
    "class_name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 220,
    "end_line": 221,
    "code": "def __eq__(self, other):\n        return (self.scope, self.path) == (other.scope, other.path)"
  },
  {
    "type": "function",
    "name": "full_path",
    "class_name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 223,
    "end_line": 224,
    "code": "def full_path(self):\n        return self.external_path + self.path"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "Relationship",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 226,
    "end_line": 237,
    "code": "def __str__(self):\n        start_node = self.identifier if self.identifier else \"\"\n\n        end_node = \"\"\n        if self.external_path:\n            end_node = \"/\".join(self.external_path)\n        if self.path:\n            if self.external_path:\n                end_node += \"/\"\n            end_node += \".\".join(self.path)\n\n        return f\"({start_node})-[:{self.type.name} {{scope: {self.scope.value}}}]->({end_node})\""
  },
  {
    "type": "function",
    "name": "block_type",
    "class_name": "BlockSpan",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 267,
    "end_line": 268,
    "code": "def block_type(self):\n        return self.initiating_block.type if self.initiating_block else None"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "BlockSpan",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 270,
    "end_line": 271,
    "code": "def __str__(self):\n        return f\"{self.span_id} ({self.span_type.value}, {self.tokens} tokens)\""
  },
  {
    "type": "function",
    "name": "get_first_child_block_path",
    "class_name": "BlockSpan",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 273,
    "end_line": 277,
    "code": "def get_first_child_block_path(self):\n        for block_path in self.block_paths:\n            if len(block_path) == len(self.parent_block_path):\n                continue\n            return block_path"
  },
  {
    "type": "function",
    "name": "__post_init__",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 310,
    "end_line": 322,
    "code": "def __post_init__(self):\n        self._content_lines = None\n\n        if self.children:\n            for child in self.children:\n                child.parent = self\n\n        if self.pre_code and not self.indentation and not self.pre_lines:\n            pre_code_lines = self.pre_code.split(\"\\n\")\n            self.pre_lines = len(pre_code_lines) - 1\n            self.indentation = (\n                pre_code_lines[-1] if self.pre_lines > 0 else self.pre_code\n            )"
  },
  {
    "type": "function",
    "name": "content_lines",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 325,
    "end_line": 328,
    "code": "def content_lines(self):\n        if self._content_lines is None:\n            self._content_lines = self.content.split(\"\\n\")\n        return self._content_lines"
  },
  {
    "type": "function",
    "name": "validate_pre_code",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 330,
    "end_line": 335,
    "code": "def validate_pre_code(self):\n        if self.pre_code and not re.match(r\"^[ \\n\\\\]*$\", self.pre_code):\n            raise ValueError(\n                f\"Failed to parse code block with type {self.type} and content `{self.content}`. \"\n                f\"Expected pre_code to only contain spaces and line breaks. Got `{self.pre_code}`\"\n            )"
  },
  {
    "type": "function",
    "name": "last",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 337,
    "end_line": 340,
    "code": "def last(self):\n        if self.next:\n            return self.next.last()\n        return self"
  },
  {
    "type": "function",
    "name": "insert_child",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 342,
    "end_line": 347,
    "code": "def insert_child(self, index: int, child: \"CodeBlock\"):\n        if index == 0 and self.children[0].pre_lines == 0:\n            self.children[0].pre_lines = 1\n\n        self.children.insert(index, child)\n        child.parent = self"
  },
  {
    "type": "function",
    "name": "insert_children",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 349,
    "end_line": 352,
    "code": "def insert_children(self, index: int, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.insert_child(index, child)\n            index += 1"
  },
  {
    "type": "function",
    "name": "append_child",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 354,
    "end_line": 357,
    "code": "def append_child(self, child: \"CodeBlock\"):\n        self.children.append(child)\n        self.span_ids.update(child.span_ids)\n        child.parent = self"
  },
  {
    "type": "function",
    "name": "append_children",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 359,
    "end_line": 361,
    "code": "def append_children(self, children: list[\"CodeBlock\"]):\n        for child in children:\n            self.append_child(child)"
  },
  {
    "type": "function",
    "name": "replace_children",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 363,
    "end_line": 370,
    "code": "def replace_children(\n        self, start_index: int, end_index: int, children: list[\"CodeBlock\"]\n    ):\n        self.children = (\n            self.children[:start_index] + children + self.children[end_index:]\n        )\n        for child in children:\n            child.parent = self"
  },
  {
    "type": "function",
    "name": "replace_child",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 372,
    "end_line": 379,
    "code": "def replace_child(self, index: int, child: \"CodeBlock\"):\n        # TODO: Do a proper update of everything when replacing child blocks\n        child.pre_code = self.children[index].pre_code\n        child.pre_lines = self.children[index].pre_lines\n        self.sync_indentation(self.children[index], child)\n\n        self.children[index] = child\n        child.parent = self"
  },
  {
    "type": "function",
    "name": "remove_child",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 381,
    "end_line": 382,
    "code": "def remove_child(self, index: int):\n        del self.children[index]"
  },
  {
    "type": "function",
    "name": "sync_indentation",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 384,
    "end_line": 403,
    "code": "def sync_indentation(self, original_block: \"CodeBlock\", updated_block: \"CodeBlock\"):\n        original_indentation_length = len(original_block.indentation) + len(\n            self.indentation\n        )\n        updated_indentation_length = len(updated_block.indentation) + len(\n            updated_block.parent.indentation\n        )\n\n        # To handle separate code blocks provdided out of context\n        if (\n            original_indentation_length == updated_indentation_length\n            and len(updated_block.indentation) == 0\n        ):\n            updated_block.indentation = \" \" * original_indentation_length\n\n        elif original_indentation_length > updated_indentation_length:\n            additional_indentation = \" \" * (\n                original_indentation_length - updated_indentation_length\n            )\n            updated_block.add_indentation(additional_indentation)"
  },
  {
    "type": "function",
    "name": "replace_by_path",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 405,
    "end_line": 415,
    "code": "def replace_by_path(self, path: list[str], new_block: \"CodeBlock\"):\n        if not path:\n            return\n\n        for i, child in enumerate(self.children):\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    self.replace_child(i, new_block)\n                    return\n                else:\n                    child.replace_by_path(path[1:], new_block)"
  },
  {
    "type": "function",
    "name": "__str__",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 417,
    "end_line": 418,
    "code": "def __str__(self):\n        return f\"{self.display_name} ({self.type.display_name} {self.start_line} - {self.end_line})\""
  },
  {
    "type": "function",
    "name": "to_string",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 420,
    "end_line": 421,
    "code": "def to_string(self):\n        return self._to_string()"
  },
  {
    "type": "function",
    "name": "sum_tokens",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 423,
    "end_line": 426,
    "code": "def sum_tokens(self):\n        tokens = self.tokens\n        tokens += sum([child.sum_tokens() for child in self.children])\n        return tokens"
  },
  {
    "type": "function",
    "name": "get_all_child_blocks",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 428,
    "end_line": 433,
    "code": "def get_all_child_blocks(self) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child in self.children:\n            blocks.append(child)\n            blocks.extend(child.get_all_child_blocks())\n        return blocks"
  },
  {
    "type": "function",
    "name": "get_children",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 435,
    "end_line": 440,
    "code": "def get_children(\n        self, exclude_blocks: list[CodeBlockType] = None\n    ) -> list[\"CodeBlock\"]:\n        if exclude_blocks is None:\n            exclude_blocks = []\n        return [child for child in self.children if child.type not in exclude_blocks]"
  },
  {
    "type": "function",
    "name": "show_related_spans",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 442,
    "end_line": 448,
    "code": "def show_related_spans(\n        self,\n        span_id: Optional[str] = None,  # TODO: Set max tokens to show\n    ):\n        related_spans = self.find_related_spans(span_id)\n        for span in related_spans:\n            span.visible = True"
  },
  {
    "type": "function",
    "name": "has_visible_children",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 450,
    "end_line": 458,
    "code": "def has_visible_children(self):\n        for child in self.children:\n            if child.is_visible:\n                return True\n\n            if child.has_visible_children():\n                return True\n\n        return False"
  },
  {
    "type": "function",
    "name": "is_visible",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 461,
    "end_line": 462,
    "code": "def is_visible(self):\n        return self.belongs_to_span and self.belongs_to_span.visible"
  },
  {
    "type": "function",
    "name": "_to_string",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 464,
    "end_line": 482,
    "code": "def _to_string(self) -> str:\n        contents = \"\"\n\n        if self.pre_lines:\n            contents += \"\\n\" * (self.pre_lines - 1)\n            for i, line in enumerate(self.content_lines):\n                if i == 0 and line:\n                    contents += \"\\n\" + self.indentation + line\n                elif line:\n                    contents += \"\\n\" + line\n                else:\n                    contents += \"\\n\"\n        else:\n            contents += self.pre_code + self.content\n\n        for _i, child in enumerate(self.children):\n            contents += child._to_string()\n\n        return contents"
  },
  {
    "type": "function",
    "name": "_build_path_tree",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 484,
    "end_line": 522,
    "code": "def _build_path_tree(\n        self, block_paths: list[str], include_references: bool = False\n    ):\n        path_tree = PathTree()\n\n        for block_path in block_paths:\n            if block_path:\n                path = block_path.split(\".\")\n                if include_references:\n                    block = self.find_by_path(path)\n                    if block:\n                        if self.type == CodeBlockType.CLASS:\n                            references = [\n                                self._fix_reference_path(reference)\n                                for reference in self.get_all_relationships(\n                                    exclude_types=[\n                                        CodeBlockType.FUNCTION,\n                                        CodeBlockType.TEST_CASE,\n                                    ]\n                                )\n                                if reference\n                                and reference.scope != ReferenceScope.EXTERNAL\n          ..."
  },
  {
    "type": "function",
    "name": "to_tree",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 524,
    "end_line": 633,
    "code": "def to_tree(\n        self,\n        indent: int = 0,\n        current_span: BlockSpan | None = None,\n        highlight_spans: set[str] | None = None,\n        only_identifiers: bool = False,\n        show_full_path: bool = True,\n        show_tokens: bool = False,\n        show_spans: bool = False,\n        debug: bool = False,\n        exclude_not_highlighted: bool = False,\n        include_line_numbers: bool = False,\n        include_types: list[CodeBlockType] | None = None,\n        include_parameters: bool = False,\n        include_block_delimiters: bool = False,\n        include_references: bool = False,\n        include_merge_history: bool = False,\n    ):\n        if not include_merge_history and self.type == CodeBlockType.BLOCK_DELIMITER:\n            return \"\"\n\n        indent_str = \" \" * indent\n\n        highlighted = False\n\n        child_tree = \"\"\n        for _i, child in enumerate(self.children):\n            if child.belongs_to_span and (\n                not current_span\n                or cu..."
  },
  {
    "type": "function",
    "name": "_to_prompt_string",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 635,
    "end_line": 688,
    "code": "def _to_prompt_string(\n        self,\n        show_span_id: bool = False,\n        span_marker: SpanMarker = SpanMarker.COMMENT,\n        show_line_numbers: bool = False,\n    ) -> str:\n        contents = \"\"\n\n        if show_span_id:\n            contents += \"\\n\\n\"\n            if span_marker == SpanMarker.COMMENT:\n                span_comment = self.create_comment(\n                    f\"span_id: {self.belongs_to_span.span_id}\"\n                )\n                contents += f\"{self.indentation}{span_comment}\"\n            elif span_marker == SpanMarker.TAG:\n                contents += f\"\\n<span id='{self.belongs_to_span.span_id}'>\"\n\n            if not self.pre_lines:\n                contents += \"\\n\"\n\n        def print_line(line_number: int):\n            if not show_line_numbers:\n                return \"\"\n\n            # Don't print out line numbers on out commented code to make it harder for the LLM to select it\n            if (\n                line_number == self.start_line\n                and..."
  },
  {
    "type": "function",
    "name": "to_prompt",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 690,
    "end_line": 776,
    "code": "def to_prompt(\n        self,\n        span_ids: set[str] | None = None,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n        show_outcommented_code: bool = True,\n        outcomment_code_comment: str = \"...\",\n        show_span_id: bool = False,\n        current_span_id: Optional[str] = None,\n        show_line_numbers: bool = False,\n        exclude_block_types: list[CodeBlockType] | None = None,\n        include_block_types: list[CodeBlockType] | None = None,\n    ):\n        contents = \"\"\n        show_new_span_id = (\n            show_span_id\n            and self.belongs_to_span\n            and (not current_span_id or current_span_id != self.belongs_to_span.span_id)\n        )\n        contents += self._to_prompt_string(\n            show_span_id=show_new_span_id, show_line_numbers=show_line_numbers\n        )\n\n        has_outcommented_code = False\n        for _i, child in enumerate(self.children):\n            show_child = True\n\n            if exclude_block_ty..."
  },
  {
    "type": "function",
    "name": "__eq__",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 778,
    "end_line": 782,
    "code": "def __eq__(self, other):\n        if not isinstance(other, CodeBlock):\n            return False\n\n        return self.full_path() == other.full_path()"
  },
  {
    "type": "function",
    "name": "compare_indentation",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 784,
    "end_line": 787,
    "code": "def compare_indentation(self, other_block: \"CodeBlock\"):\n        existing_indentation = len(self.indentation)\n        new_indentation = len(other_block.indentation)\n        return existing_indentation - new_indentation"
  },
  {
    "type": "function",
    "name": "find_block_by_type",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 789,
    "end_line": 798,
    "code": "def find_block_by_type(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if self.type == block_type:\n            return self\n\n        for child in self.children:\n            block = child.find_block_by_type(block_type)\n            if block:\n                return block\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_type_in_parents",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 800,
    "end_line": 810,
    "code": "def find_type_in_parents(self, block_type: CodeBlockType) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type == block_type:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_in_parents(block_type)\n\n        return None"
  },
  {
    "type": "function",
    "name": "structure_block",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 812,
    "end_line": 819,
    "code": "def structure_block(self):\n        if self.type.group == CodeBlockTypeGroup.STRUCTURE:\n            return self\n\n        if self.parent:\n            return self.parent.structure_block()\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_type_group_in_parents",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 821,
    "end_line": 833,
    "code": "def find_type_group_in_parents(\n        self, block_type_group: CodeBlockTypeGroup\n    ) -> Optional[\"CodeBlock\"]:\n        if not self.parent:\n            return None\n\n        if self.parent.type.group == block_type_group:\n            return self.parent\n\n        if self.parent:\n            return self.parent.find_type_group_in_parents(block_type_group)\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_spans_by_line_numbers",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 835,
    "end_line": 871,
    "code": "def find_spans_by_line_numbers(\n        self, start_line: int, end_line: int | None = None\n    ) -> list[BlockSpan]:\n        spans = []\n        for child in self.children:\n            if end_line is None:\n                end_line = start_line\n\n            if child.end_line < start_line:\n                continue\n\n            if child.start_line > end_line:\n                if not spans:\n                    last_block = self.find_last_by_end_line(end_line)\n                    if last_block:\n                        spans.append(last_block.belongs_to_span)\n                return spans\n\n            if (\n                child.belongs_to_span\n                and child.belongs_to_span.span_id not in spans\n                and (\n                    not child.children\n                    or child.children[0].start_line > end_line\n                    or (child.start_line >= start_line and child.end_line <= end_line)\n                    or child.start_line == start_line\n                    or child...."
  },
  {
    "type": "function",
    "name": "dict",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 873,
    "end_line": 875,
    "code": "def dict(self, **kwargs):\n        # TODO: Add **kwargs to dict call\n        return super().dict(exclude={\"parent\", \"merge_history\"})"
  },
  {
    "type": "function",
    "name": "display_name",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 878,
    "end_line": 882,
    "code": "def display_name(self):\n        if self.full_path():\n            return self.path_string()\n        else:\n            return \"<module>\""
  },
  {
    "type": "function",
    "name": "path_string",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 884,
    "end_line": 885,
    "code": "def path_string(self):\n        return \".\".join(self.full_path())"
  },
  {
    "type": "function",
    "name": "full_path",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 887,
    "end_line": 895,
    "code": "def full_path(self):\n        path = []\n        if self.parent:\n            path.extend(self.parent.full_path())\n\n        if self.identifier:\n            path.append(self.identifier)\n\n        return path"
  },
  {
    "type": "function",
    "name": "module",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 898,
    "end_line": 901,
    "code": "def module(self) -> \"Module\":  # noqa: F821\n        if self.parent:\n            return self.parent.module\n        return None"
  },
  {
    "type": "function",
    "name": "root",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 904,
    "end_line": 905,
    "code": "def root(self) -> \"Module\":  # noqa: F821\n        return self.module"
  },
  {
    "type": "function",
    "name": "get_blocks",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 907,
    "end_line": 920,
    "code": "def get_blocks(\n        self, has_identifier: bool, include_types: list[CodeBlockType] | None = None\n    ) -> list[\"CodeBlock\"]:\n        blocks = [self]\n\n        for child in self.children:\n            if has_identifier and not child.identifier:\n                continue\n\n            if include_types and child.type not in include_types:\n                continue\n\n            blocks.extend(child.get_indexable_blocks())\n        return blocks"
  },
  {
    "type": "function",
    "name": "find_reference",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 922,
    "end_line": 947,
    "code": "def find_reference(self, ref_path: [str]) -> Relationship | None:\n        for child in self.children:\n            if child.type == CodeBlockType.IMPORT:\n                for reference in child.relationships:\n                    if (\n                        reference.path[len(reference.path) - len(ref_path) :]\n                        == ref_path\n                    ):\n                        return reference\n\n            child_path = child.full_path()\n\n            if child_path[len(child_path) - len(ref_path) :] == ref_path:\n                if self.type == CodeBlockType.CLASS:\n                    return Relationship(scope=ReferenceScope.CLASS, path=child_path)\n                if self.type == CodeBlockType.MODULE:\n                    return Relationship(scope=ReferenceScope.GLOBAL, path=child_path)\n\n                return Relationship(scope=ReferenceScope.LOCAL, path=child_path)\n\n        if self.parent:\n            reference = self.parent.find_reference(ref_path)\n            if reference:..."
  },
  {
    "type": "function",
    "name": "get_all_relationships",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 949,
    "end_line": 962,
    "code": "def get_all_relationships(\n        self, exclude_types: list[CodeBlockType] = None\n    ) -> list[Relationship]:\n        if exclude_types is None:\n            exclude_types = []\n        references = []\n        references.extend(self.relationships)\n        for childblock in self.children:\n            if not exclude_types or childblock.type not in exclude_types:\n                references.extend(\n                    childblock.get_all_relationships(exclude_types=exclude_types)\n                )\n\n        return references"
  },
  {
    "type": "function",
    "name": "is_complete",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 964,
    "end_line": 967,
    "code": "def is_complete(self):\n        if self.type == CodeBlockType.COMMENTED_OUT_CODE:\n            return False\n        return all(child.is_complete() for child in self.children)"
  },
  {
    "type": "function",
    "name": "find_errors",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 969,
    "end_line": 982,
    "code": "def find_errors(self) -> list[str]:\n        errors = []\n\n        if self.children:\n            for child in self.children:\n                errors.extend(child.find_errors())\n\n        if self.type == CodeBlockType.ERROR:\n            if self.validation_errors:\n                errors.extend(self.validation_errors)\n            else:\n                errors.append(f\"Found validation errors in {self.path_string()}\")\n\n        return errors"
  },
  {
    "type": "function",
    "name": "create_commented_out_block",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 984,
    "end_line": 991,
    "code": "def create_commented_out_block(self, comment_out_str: str = \"...\"):\n        return CodeBlock(\n            type=CodeBlockType.COMMENTED_OUT_CODE,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=1,\n            content=self.create_comment(comment_out_str),\n        )"
  },
  {
    "type": "function",
    "name": "create_comment_block",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 993,
    "end_line": 1000,
    "code": "def create_comment_block(self, comment: str = \"...\", pre_lines: int = 1):\n        return CodeBlock(\n            type=CodeBlockType.COMMENT,\n            indentation=self.indentation,\n            parent=self,\n            pre_lines=pre_lines,\n            content=self.create_comment(comment),\n        )"
  },
  {
    "type": "function",
    "name": "create_comment",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1002,
    "end_line": 1004,
    "code": "def create_comment(self, comment: str) -> str:\n        symbol = get_comment_symbol(\"python\")  # FIXME: Derive language from Module\n        return f\"{symbol} {comment}\""
  },
  {
    "type": "function",
    "name": "add_indentation",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1006,
    "end_line": 1020,
    "code": "def add_indentation(self, indentation: str):\n        if self.pre_lines:\n            self.indentation += indentation\n\n        # TODO: Find a more graceful way to solve multi line blocks\n        if \"\\n\" in self.content:\n            lines = self.content.split(\"\\n\")\n            content = lines[0]\n            for line in lines[1:]:\n                if line.startswith(\" \"):\n                    content += \"\\n\" + indentation + line\n            self.content = content\n\n        for child in self.children:\n            child.add_indentation(indentation)"
  },
  {
    "type": "function",
    "name": "find_by_path",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1022,
    "end_line": 1036,
    "code": "def find_by_path(self, path: list[str]) -> Optional[\"CodeBlock\"]:\n        if path is None:\n            return None\n\n        if not path:\n            return self\n\n        for child in self.children:\n            if child.identifier == path[0]:\n                if len(path) == 1:\n                    return child\n                else:\n                    return child.find_by_path(path[1:])\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_blocks_by_span_id",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1038,
    "end_line": 1047,
    "code": "def find_blocks_by_span_id(self, span_id: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            blocks.append(self)\n\n        for child in self.children:\n            # TODO: Optimize to just check relevant children (by mapping spans?\n            blocks.extend(child.find_blocks_by_span_id(span_id))\n\n        return blocks"
  },
  {
    "type": "function",
    "name": "find_last_before_span",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1049,
    "end_line": 1066,
    "code": "def find_last_before_span(\n        self, span_id: str, last_before_span: Optional[\"CodeBlock\"] = None\n    ) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return last_before_span\n\n        for child in self.children:\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return last_before_span\n\n            if child.belongs_to_span and child.belongs_to_span.span_id != span_id:\n                last_before_span = child\n\n            result = child.find_last_before_span(span_id, last_before_span)\n            if result:\n                return result\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_first_by_span_id",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1068,
    "end_line": 1077,
    "code": "def find_first_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        if self.belongs_to_span and self.belongs_to_span.span_id == span_id:\n            return self\n\n        for child in self.children:\n            found = child.find_first_by_span_id(span_id)\n            if found:\n                return found\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_last_by_span_id",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1079,
    "end_line": 1088,
    "code": "def find_last_by_span_id(self, span_id: str) -> Optional[\"CodeBlock\"]:\n        for child in reversed(self.children):\n            if child.belongs_to_span and child.belongs_to_span.span_id == span_id:\n                return child\n\n            found = child.find_last_by_span_id(span_id)\n            if found:\n                return found\n\n        return None"
  },
  {
    "type": "function",
    "name": "has_any_block",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1090,
    "end_line": 1094,
    "code": "def has_any_block(self, blocks: list[\"CodeBlock\"]) -> bool:\n        for block in blocks:\n            if block.full_path()[: len(self.full_path())] == self.full_path():\n                return True\n        return False"
  },
  {
    "type": "function",
    "name": "find_by_identifier",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1096,
    "end_line": 1110,
    "code": "def find_by_identifier(\n        self,\n        identifier: str,\n        type: CodeBlockType | None = None,\n        recursive: bool = False,\n    ):\n        for child in self.children:\n            if child.identifier == identifier and (not type or child.type == type):\n                return child\n\n            if recursive:\n                found = child.find_by_identifier(identifier, type, recursive)\n                if found:\n                    return found\n        return None"
  },
  {
    "type": "function",
    "name": "find_blocks_with_identifier",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1112,
    "end_line": 1118,
    "code": "def find_blocks_with_identifier(self, identifier: str) -> list[\"CodeBlock\"]:\n        blocks = []\n        for child_block in self.children:\n            if child_block.identifier == identifier:\n                blocks.append(child_block)\n            blocks.extend(child_block.find_blocks_with_identifier(identifier))\n        return blocks"
  },
  {
    "type": "function",
    "name": "find_incomplete_blocks_with_type",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1120,
    "end_line": 1121,
    "code": "def find_incomplete_blocks_with_type(self, block_type: CodeBlockType):\n        return self.find_incomplete_blocks_with_types([block_type])"
  },
  {
    "type": "function",
    "name": "find_incomplete_blocks_with_types",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1123,
    "end_line": 1134,
    "code": "def find_incomplete_blocks_with_types(self, block_types: [CodeBlockType]):\n        matching_blocks = []\n        for child_block in self.children:\n            if child_block.type in block_types and not child_block.is_complete():\n                matching_blocks.append(child_block)\n\n            if child_block.children:\n                matching_blocks.extend(\n                    child_block.find_incomplete_blocks_with_types(block_types)\n                )\n\n        return matching_blocks"
  },
  {
    "type": "function",
    "name": "find_blocks_with_types",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1136,
    "end_line": 1146,
    "code": "def find_blocks_with_types(\n        self, block_types: list[CodeBlockType]\n    ) -> list[\"CodeBlock\"]:\n        matching_blocks = []\n        if self.type in block_types:\n            matching_blocks.append(self)\n        for child_block in self.children:\n            matching_blocks.extend(\n                child_block.find_blocks_with_types(block_types=block_types)\n            )\n        return matching_blocks"
  },
  {
    "type": "function",
    "name": "has_blocks_with_types",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1148,
    "end_line": 1154,
    "code": "def has_blocks_with_types(self, block_types: list[CodeBlockType]) -> bool:\n        if self.type in block_types:\n            return True\n        for child_block in self.children:\n            if child_block.has_blocks_with_types(block_types):\n                return True\n        return False"
  },
  {
    "type": "function",
    "name": "has_placeholders",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1156,
    "end_line": 1157,
    "code": "def has_placeholders(self):\n        return self.find_blocks_with_type(CodeBlockType.COMMENTED_OUT_CODE)"
  },
  {
    "type": "function",
    "name": "find_blocks_with_type",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1159,
    "end_line": 1160,
    "code": "def find_blocks_with_type(self, block_type: CodeBlockType) -> list[\"CodeBlock\"]:\n        return self.find_blocks_with_types([block_type])"
  },
  {
    "type": "function",
    "name": "find_first_by_start_line",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1162,
    "end_line": 1175,
    "code": "def find_first_by_start_line(self, start_line: int) -> Optional[\"CodeBlock\"]:\n        for child in self.children:\n            if child.start_line >= start_line:\n                return child\n\n            if child.end_line >= start_line:\n                if not child.children:\n                    return child\n\n                found = child.find_first_by_start_line(start_line)\n                if found:\n                    return found\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_blocks_by_line_numbers",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1177,
    "end_line": 1192,
    "code": "def find_blocks_by_line_numbers(\n        self,\n        start_line: int,\n        end_line: int | None = None,\n        include_parents: bool = False,\n    ) -> List[\"CodeBlock\"]:\n        blocks = []\n        block = self\n        while block.next and (end_line is None or block.start_line <= end_line):\n            if include_parents and block.has_lines(start_line, end_line):\n                blocks.append(block)\n            elif block.start_line >= start_line:\n                blocks.append(block)\n            block = block.next\n\n        return blocks"
  },
  {
    "type": "function",
    "name": "find_last_by_end_line",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1194,
    "end_line": 1212,
    "code": "def find_last_by_end_line(\n        self, end_line: int, tokens: Optional[int] = None\n    ) -> Optional[\"CodeBlock\"]:\n        last_child = None\n        for child in self.children:\n            if child.start_line > end_line or (tokens and child.tokens > tokens):\n                return last_child\n\n            if tokens:\n                tokens -= child.tokens\n\n            last_child = child\n\n            if child.end_line > end_line:\n                found = child.find_last_by_end_line(end_line, tokens=tokens)\n                if found:\n                    return found\n\n        return None"
  },
  {
    "type": "function",
    "name": "line_within_token_context",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1214,
    "end_line": 1235,
    "code": "def line_within_token_context(self, line_number: int, tokens: int) -> bool:\n        if tokens <= 0:\n            return False\n\n        if self.end_line < line_number:\n            if not self.next:\n                return False\n            if self.next.start_line > line_number:\n                return True\n            else:\n                return self.next.line_within_token_context(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if not self.previous:\n                return False\n            elif self.previous.end_line < line_number:\n                return True\n            else:\n                return self.previous.line_within_token_context(\n                    line_number, tokens - self.tokens\n                )"
  },
  {
    "type": "function",
    "name": "find_last_previous_block_with_block_group",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1237,
    "end_line": 1246,
    "code": "def find_last_previous_block_with_block_group(\n        self, block_group: CodeBlockTypeGroup\n    ):\n        if not self.previous:\n            return None\n\n        if self.previous.type.group == block_group:\n            return self.previous\n\n        return self.previous.find_last_previous_block_with_block_group(block_group)"
  },
  {
    "type": "function",
    "name": "find_next_block_with_block_group",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1248,
    "end_line": 1255,
    "code": "def find_next_block_with_block_group(self, block_group: CodeBlockTypeGroup):\n        if not self.next:\n            return None\n\n        if self.next.type.group == block_group:\n            return self.next\n\n        return self.next.find_next_block_with_block_group(block_group)"
  },
  {
    "type": "function",
    "name": "tokens_from_line",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1257,
    "end_line": 1261,
    "code": "def tokens_from_line(self, line_number: int) -> Optional[int]:\n        if not self.previous or self.previous.end_line < line_number:\n            return self.tokens\n\n        return self.tokens + self.previous.tokens_from_line(line_number)"
  },
  {
    "type": "function",
    "name": "last_block_until_line",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1263,
    "end_line": 1285,
    "code": "def last_block_until_line(self, line_number: int, tokens: int) -> \"CodeBlock\":\n        if self.end_line < line_number:\n            if (\n                not self.next\n                or self.next.start_line > line_number\n                or self.next.tokens > tokens\n            ):\n                return self\n            else:\n                return self.next.last_block_until_line(\n                    line_number, tokens - self.tokens\n                )\n        else:\n            if (\n                not self.previous\n                or self.previous.end_line < line_number\n                or self.next.tokens > tokens\n            ):\n                return self\n            else:\n                return self.previous.last_block_until_line(\n                    line_number, tokens - self.tokens\n                )"
  },
  {
    "type": "function",
    "name": "get_all_span_ids",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1287,
    "end_line": 1296,
    "code": "def get_all_span_ids(self, include_self: bool = True) -> set[str]:\n        span_ids = set()\n\n        if include_self and self.belongs_to_span:\n            span_ids.add(self.belongs_to_span.span_id)\n\n        for child in self.children:\n            span_ids.update(child.get_all_span_ids())\n\n        return span_ids"
  },
  {
    "type": "function",
    "name": "get_all_spans",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1298,
    "end_line": 1300,
    "code": "def get_all_spans(self, include_self: bool = True) -> list[BlockSpan]:\n        span_ids = self.get_all_span_ids(include_self=include_self)\n        return [self.module.find_span_by_id(span_id) for span_id in span_ids]"
  },
  {
    "type": "function",
    "name": "has_span",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1302,
    "end_line": 1303,
    "code": "def has_span(self, span_id: str):\n        return self.has_any_span({span_id})"
  },
  {
    "type": "function",
    "name": "has_any_span",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1305,
    "end_line": 1307,
    "code": "def has_any_span(self, span_ids: set[str]):\n        all_span_ids = self.get_all_span_ids(include_self=False)\n        return any([span_id in all_span_ids for span_id in span_ids])"
  },
  {
    "type": "function",
    "name": "belongs_to_any_span",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1309,
    "end_line": 1310,
    "code": "def belongs_to_any_span(self, span_ids: set[str]):\n        return self.belongs_to_span and self.belongs_to_span.span_id in span_ids"
  },
  {
    "type": "function",
    "name": "has_lines",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1312,
    "end_line": 1316,
    "code": "def has_lines(self, start_line: int, end_line: int | None = None):\n        # Returns True if any part of the block is within the provided line range\n        if end_line is None:\n            return self.end_line >= start_line\n        return not (self.end_line < start_line or self.start_line > end_line)"
  },
  {
    "type": "function",
    "name": "is_within_lines",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1318,
    "end_line": 1319,
    "code": "def is_within_lines(self, start_line: int, end_line: int):\n        return self.start_line >= start_line and self.end_line <= end_line"
  },
  {
    "type": "function",
    "name": "has_content",
    "class_name": "CodeBlock",
    "file": "codeblocks.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks",
    "start_line": 1321,
    "end_line": 1335,
    "code": "def has_content(self, query: str, span_id: Optional[str] = None):\n        if (\n            self.content\n            and query in self.content\n            and (\n                not span_id\n                or (self.belongs_to_span and self.belongs_to_span.span_id == span_id)\n            )\n        ):\n            return True\n\n        if span_id and not self.has_span(span_id):\n            return False\n\n        return any(child.has_content(query, span_id) for child in self.children)"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "JavaParser",
    "file": "java.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 8,
    "end_line": 12,
    "code": "def __init__(self, **kwargs):\n        super().__init__(Language(java.language()), **kwargs)\n        self.queries = []\n        self.queries.extend(self._build_queries(\"java.scm\"))\n        self.gpt_queries = []"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 27,
    "end_line": 36,
    "code": "def __init__(self, **kwargs):\n        language = Language(tspython.language())\n\n        super().__init__(language, **kwargs)\n\n        self.queries = []\n        self.queries.extend(self._build_queries(\"python.scm\"))\n\n        if self.apply_gpt_tweaks:\n            self.gpt_queries.extend(self._build_queries(\"python_gpt.scm\"))"
  },
  {
    "type": "function",
    "name": "language",
    "class_name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 39,
    "end_line": 40,
    "code": "def language(self):\n        return \"python\""
  },
  {
    "type": "function",
    "name": "pre_process",
    "class_name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 42,
    "end_line": 61,
    "code": "def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        if (\n            codeblock.type == CodeBlockType.FUNCTION\n            and codeblock.identifier == \"__init__\"\n        ):\n            codeblock.type = CodeBlockType.CONSTRUCTOR\n\n        # Handle line breaks after assignment without \\\n        if (\n            codeblock.type == CodeBlockType.ASSIGNMENT\n            and codeblock.content_lines[0].strip().endswith(\"=\")\n            and node_match.check_child\n            and node_match.first_child\n            and node_match.check_child.start_point[0]\n            < node_match.first_child.start_point[0]\n        ):\n            logger.debug(\n                f\"Parsed block with type ASSIGNMENT with line break but no ending \\\\: {codeblock.content_lines[0]}\"\n            )\n            codeblock.content_lines[0] = codeblock.content_lines[0] + \" \\\\\""
  },
  {
    "type": "function",
    "name": "post_process",
    "class_name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 63,
    "end_line": 130,
    "code": "def post_process(self, codeblock: CodeBlock):\n        if codeblock.type == CodeBlockType.COMMENT and self.is_outcommented_code(\n            codeblock.content\n        ):\n            codeblock.type = CodeBlockType.COMMENTED_OUT_CODE\n\n        if codeblock.type == CodeBlockType.ASSIGNMENT:\n            for reference in codeblock.relationships:\n                reference.type = RelationshipType.TYPE\n\n        new_references = []\n        for reference in codeblock.relationships:\n            # Set parent class path as reference path on self\n            if reference.path and reference.path[0] == \"self\":\n                class_block = codeblock.find_type_in_parents(CodeBlockType.CLASS)\n                if class_block:\n                    reference.scope = ReferenceScope.CLASS\n                    if len(reference.path) > 1:\n                        reference.path = class_block.full_path() + reference.path[1:2]\n                        reference.identifier = codeblock.identifier\n\n            # Set paren..."
  },
  {
    "type": "function",
    "name": "is_outcommented_code",
    "class_name": "PythonParser",
    "file": "python.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 132,
    "end_line": 135,
    "code": "def is_outcommented_code(self, comment):\n        return comment.startswith(\"# ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )"
  },
  {
    "type": "function",
    "name": "is_supported",
    "class_name": null,
    "file": "create.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 6,
    "end_line": 7,
    "code": "def is_supported(language: str) -> bool:\n    return language and language in [\"python\", \"java\"]"
  },
  {
    "type": "function",
    "name": "create_parser_by_ext",
    "class_name": null,
    "file": "create.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 10,
    "end_line": 16,
    "code": "def create_parser_by_ext(ext: str, **kwargs) -> CodeParser | None:\n    if ext == \".py\":\n        return PythonParser(**kwargs)\n    elif ext == \".java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Extension {ext} is not supported.\")"
  },
  {
    "type": "function",
    "name": "create_parser",
    "class_name": null,
    "file": "create.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 19,
    "end_line": 25,
    "code": "def create_parser(language: str, **kwargs) -> CodeParser | None:\n    if language == \"python\":\n        return PythonParser(**kwargs)\n    elif language == \"java\":\n        return JavaParser(**kwargs)\n\n    raise NotImplementedError(f\"Language {language} is not supported.\")"
  },
  {
    "type": "function",
    "name": "get_comment_symbol",
    "class_name": null,
    "file": "comment.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 75,
    "end_line": 78,
    "code": "def get_comment_symbol(language):\n    if language:\n        return comment_symbols.get(language.lower(), None)\n    return \"#\""
  },
  {
    "type": "function",
    "name": "_find_type",
    "class_name": null,
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 44,
    "end_line": 48,
    "code": "def _find_type(node: Node, type: str):\n    for i, child in enumerate(node.children):\n        if child.type == type:\n            return i, child\n    return None, None"
  },
  {
    "type": "function",
    "name": "find_type",
    "class_name": null,
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 51,
    "end_line": 55,
    "code": "def find_type(node: Node, types: list[str]):\n    for child in node.children:\n        if child.type in types:\n            return child\n    return None"
  },
  {
    "type": "function",
    "name": "find_nested_type",
    "class_name": null,
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 58,
    "end_line": 67,
    "code": "def find_nested_type(node: Node, type: str, levels: int = -1):\n    if levels == 0:\n        return None\n    if node.type == type:\n        return node\n    for child in node.children:\n        found_node = find_nested_type(child, type, levels - 1)\n        if found_node:\n            return found_node\n    return None"
  },
  {
    "type": "function",
    "name": "__init__",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 71,
    "end_line": 115,
    "code": "def __init__(\n        self,\n        language: Language,\n        encoding: str = \"utf8\",\n        max_tokens_in_span: int = 500,\n        min_tokens_for_docs_span: int = 100,\n        min_lines_to_parse_block: Optional[\n            int\n        ] = None,  # If this is set code will just be parsed if they have more line than this\n        enable_code_graph: bool = True,\n        index_callback: Callable[[CodeBlock], None] | None = None,\n        tokenizer: Callable[[str], list] | None = None,\n        apply_gpt_tweaks: bool = False,\n        debug: bool = False,\n    ):\n        try:\n            self.tree_parser = Parser()\n            self.tree_parser.language = language\n            self.tree_language = language\n        except Exception as e:\n            logger.warning(f\"Could not get parser for language {language}.\")\n            raise e\n        self.apply_gpt_tweaks = apply_gpt_tweaks\n        self.index_callback = index_callback\n        self.debug = debug\n        self.encoding = encoding\n        s..."
  },
  {
    "type": "function",
    "name": "language",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 118,
    "end_line": 119,
    "code": "def language(self):\n        pass"
  },
  {
    "type": "function",
    "name": "_extract_node_type",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 121,
    "end_line": 127,
    "code": "def _extract_node_type(self, query: str):\n        pattern = r\"\\(\\s*(\\w+)\"\n        match = re.search(pattern, query)\n        if match:\n            return match.group(1)\n        else:\n            return None"
  },
  {
    "type": "function",
    "name": "_build_queries",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 129,
    "end_line": 150,
    "code": "def _build_queries(self, query_file: str):\n        with (\n            resources.files(\"moatless_qa.codeblocks.parser.queries\")\n            .joinpath(query_file)\n            .open() as file\n        ):\n            query_list = file.read().strip().split(\"\\n\\n\")\n            parsed_queries = []\n            for i, query in enumerate(query_list):\n                try:\n                    node_type = self._extract_node_type(query)\n                    parsed_queries.append(\n                        (\n                            f\"{query_file}:{i+1}\",\n                            node_type,\n                            self.tree_language.query(query),\n                        )\n                    )\n                except Exception as e:\n                    logging.error(f\"Could not parse query {query}:{i+1}\")\n                    raise e\n            return parsed_queries"
  },
  {
    "type": "function",
    "name": "parse_code",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 152,
    "end_line": 412,
    "code": "def parse_code(\n        self,\n        content_bytes: bytes,\n        node: Node,\n        start_byte: int = 0,\n        level: int = 0,\n        file_path: Optional[str] = None,\n        parent_block: CodeBlock | None = None,\n        current_span: BlockSpan | None = None,\n    ) -> tuple[CodeBlock, Node, BlockSpan]:\n        node_match = self.find_in_tree(node)\n\n        if not parent_block and node.children:\n            node_match.first_child = node.children[0]\n        elif node.type == \"ERROR\":\n            node_match.block_type = CodeBlockType.ERROR\n\n        pre_code = content_bytes[start_byte : node.start_byte].decode(self.encoding)\n        end_line = node.end_point[0]\n\n        # Skip parsing of non structure blocks if they have less lines than min_lines_to_parse_implementation\n        # But still parse classes and modules\n        if (\n            node_match.first_child\n            and self._min_lines_to_parse_block\n            and node_match.block_type\n            not in [CodeBlockType.MOD..."
  },
  {
    "type": "function",
    "name": "is_commented_out_code",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 414,
    "end_line": 418,
    "code": "def is_commented_out_code(self, node: Node):\n        comment = node.text.decode(\"utf8\").strip()\n        return comment.startswith(f\"{get_comment_symbol(self.language)} ...\") or any(\n            keyword in comment.lower() for keyword in commented_out_keywords\n        )"
  },
  {
    "type": "function",
    "name": "find_in_tree",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 420,
    "end_line": 444,
    "code": "def find_in_tree(self, node: Node) -> NodeMatch | None:\n        if self.apply_gpt_tweaks:\n            match = self.find_match_with_gpt_tweaks(node)\n            if match:\n                self.debug_log(\n                    f\"find_in_tree() GPT match: {match.block_type} on {node}\"\n                )\n                return match\n\n        if not node.parent and node.children:\n            return NodeMatch(\n                block_type=CodeBlockType.MODULE, first_child=node.children[0]\n            )\n\n        match = self.find_match(node)\n        if match:\n            self.debug_log(\n                f\"find_in_tree() Found match on node type {node.type} with block type {match.block_type}\"\n            )\n            return match\n        else:\n            self.debug_log(\n                f\"find_in_tree() Found no match on node type {node.type} set block type {CodeBlockType.CODE}\"\n            )\n            return NodeMatch(block_type=CodeBlockType.CODE)"
  },
  {
    "type": "function",
    "name": "find_match_with_gpt_tweaks",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 446,
    "end_line": 459,
    "code": "def find_match_with_gpt_tweaks(self, node: Node) -> NodeMatch | None:\n        for label, node_type, query in self.gpt_queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label, capture_from_parent=True)\n            if match:\n                self.debug_log(\n                    f\"find_match_with_gpt_tweaks() Found match on node {node.type} with query {label}\"\n                )\n                if not match.query:\n                    match.query = label\n                return match\n\n        return None"
  },
  {
    "type": "function",
    "name": "find_match",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 461,
    "end_line": 478,
    "code": "def find_match(self, node: Node) -> NodeMatch | None:\n        self.debug_log(f\"find_match() node type {node.type}\")\n\n        queries = 0\n        for label, node_type, query in self.queries:\n            if node_type and node.type != node_type and node_type != \"_\":\n                continue\n            match = self._find_match(node, query, label)\n            queries += 1\n            if match:\n                self.debug_log(\n                    f\"find_match() Found match on node {node.type} with query {label}\"\n                )\n                if not match.query:\n                    match.query = label\n                return match\n\n        return None"
  },
  {
    "type": "function",
    "name": "_find_match",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 480,
    "end_line": 566,
    "code": "def _find_match(\n        self, node: Node, query, label: str, capture_from_parent: bool = False\n    ) -> NodeMatch | None:\n        if capture_from_parent:\n            captures = query.captures(node.parent)\n        else:\n            captures = query.captures(node)\n\n        node_match = NodeMatch()\n\n        if not captures:\n            return None\n\n        root_node = None\n        logger.info(captures)\n        for capture in captures:\n            # 安全地解包捕获结果，确保即使格式变化也能正常工作\n            if len(capture) >= 2:\n                found_node, tag = capture[0], capture[1]\n            else:\n                continue  # 跳过不符合预期格式的捕获结果\n                \n            self.debug_log(f\"[{label}] Found tag {tag} on node {found_node}\")\n\n            if tag == \"root\" and not root_node and node == found_node:\n                self.debug_log(f\"[{label}] Root node {found_node}\")\n                root_node = found_node\n\n            if not root_node:\n                continue\n\n            if tag == \"no_children\" and f..."
  },
  {
    "type": "function",
    "name": "create_references",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 568,
    "end_line": 652,
    "code": "def create_references(self, code, content_bytes, identifier, node_match):\n        references = []\n        if node_match.block_type == CodeBlockType.IMPORT and node_match.relationships:\n            module_nodes = [\n                ref for ref in node_match.relationships if ref[1] == \"reference.module\"\n            ]\n            if module_nodes:\n                module_reference_id = self.get_content(\n                    module_nodes[0][0], content_bytes\n                )\n                if len(node_match.relationships) > 1:\n                    for ref_node in node_match.relationships:\n                        if ref_node == module_nodes[0]:\n                            continue\n                        elif ref_node[1] == \"reference.alias\":\n                            reference_id = self.get_content(ref_node[0], content_bytes)\n                            references.append(\n                                Relationship(\n                                    scope=ReferenceScope.EXTERNAL,\n       ..."
  },
  {
    "type": "function",
    "name": "create_parameters",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 654,
    "end_line": 673,
    "code": "def create_parameters(self, content_bytes, node_match, references):\n        parameters = []\n        for parameter in node_match.parameters:\n            parameter_type = (\n                self.get_content(parameter[1], content_bytes) if parameter[1] else None\n            )\n            parameter_id = self.get_content(parameter[0], content_bytes)\n\n            parameters.append(Parameter(identifier=parameter_id, type=parameter_type))\n\n            if parameter_type:\n                parameter_type = parameter_type.replace('\"', \"\")\n\n                type_split = parameter_type.split(\".\")\n\n                reference = Relationship(\n                    scope=ReferenceScope.LOCAL, identifier=parameter_id, path=type_split\n                )\n                references.append(reference)\n        return parameters"
  },
  {
    "type": "function",
    "name": "add_to_index",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 675,
    "end_line": 677,
    "code": "def add_to_index(self, codeblock: CodeBlock):\n        if self.index_callback:\n            self.index_callback(codeblock)"
  },
  {
    "type": "function",
    "name": "pre_process",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 679,
    "end_line": 680,
    "code": "def pre_process(self, codeblock: CodeBlock, node_match: NodeMatch):\n        pass"
  },
  {
    "type": "function",
    "name": "post_process",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 682,
    "end_line": 683,
    "code": "def post_process(self, codeblock: CodeBlock):\n        pass"
  },
  {
    "type": "function",
    "name": "get_previous",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 685,
    "end_line": 693,
    "code": "def get_previous(self, node: Node, origin_node: Node):\n        if node == origin_node:\n            return node.start_byte\n        if node.prev_sibling:\n            return node.prev_sibling.end_byte\n        elif node.parent:\n            return self.get_previous(node.parent, origin_node)\n        else:\n            return node.start_byte"
  },
  {
    "type": "function",
    "name": "get_parent_next",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 695,
    "end_line": 705,
    "code": "def get_parent_next(self, node: Node, orig_node: Node):\n        self.debug_log(f\"get_parent_next: {node.type} - {orig_node.type}\")\n        if node != orig_node:\n            if node.next_sibling:\n                self.debug_log(\n                    f\"get_parent_next: node.next_sibling -> {node.next_sibling}\"\n                )\n                return node.next_sibling\n            else:\n                return self.get_parent_next(node.parent, orig_node)\n        return None"
  },
  {
    "type": "function",
    "name": "has_error",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 707,
    "end_line": 712,
    "code": "def has_error(self, node: Node):\n        if node.type == \"ERROR\":\n            return True\n        if node.children:\n            return any(self.has_error(child) for child in node.children)\n        return False"
  },
  {
    "type": "function",
    "name": "parse",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 714,
    "end_line": 738,
    "code": "def parse(self, content, file_path: Optional[str] = None) -> Module:\n        if isinstance(content, str):\n            content_in_bytes = bytes(content, self.encoding)\n        elif isinstance(content, bytes):\n            content_in_bytes = content\n        else:\n            raise ValueError(\"Content must be either a string or bytes\")\n\n        # TODO: make thread safe?\n        self.spans_by_id = {}\n        self._span_counter = {}\n\n        # TODO: Should me moved to a central CodeGraph\n        if self._enable_code_graph:\n            self._graph = nx.DiGraph()\n\n        tree = self.tree_parser.parse(content_in_bytes)\n        root_node = tree.walk().node\n\n        module, _, _ = self.parse_code(content_in_bytes, root_node, file_path=file_path)\n        module.spans_by_id = self.spans_by_id\n        module.file_path = file_path\n        module.language = self.language\n        module._graph = self._graph\n        return module"
  },
  {
    "type": "function",
    "name": "get_content",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 740,
    "end_line": 741,
    "code": "def get_content(self, node: Node, content_bytes: bytes) -> str:\n        return content_bytes[node.start_byte : node.end_byte].decode(self.encoding)"
  },
  {
    "type": "function",
    "name": "_create_new_span",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 743,
    "end_line": 889,
    "code": "def _create_new_span(\n        self, current_span: BlockSpan | None, block: CodeBlock\n    ) -> BlockSpan | None:\n        # Set documentation phase on comments in the start of structure blocks if more than min_tokens_for_docs_span\n        # TODO: This is isn't valid in other languages, try to set block type to docstring?\n        block_types_with_document_span = [\n            CodeBlockType.MODULE\n        ]  # TODO: Make this configurable\n\n        # Set initation phase on imports in module blocks\n        if block.type == CodeBlockType.IMPORT and (\n            not current_span\n            or current_span.span_type != SpanType.INITATION\n            or block.parent.type == CodeBlockType.MODULE\n        ):\n            span_type = SpanType.INITATION\n            span_id = self._create_span_id(block, label=\"imports\")\n\n        elif block.type == CodeBlockType.COMMENT and (\n            not current_span\n            or current_span.block_type in block_types_with_document_span\n            and (\n       ..."
  },
  {
    "type": "function",
    "name": "_create_span_id",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 891,
    "end_line": 916,
    "code": "def _create_span_id(self, block: CodeBlock, label: Optional[str] = None):\n        if block.type.group == CodeBlockTypeGroup.STRUCTURE:\n            structure_block = block\n        else:\n            structure_block = block.find_type_group_in_parents(\n                CodeBlockTypeGroup.STRUCTURE\n            )\n\n        if not structure_block:\n            return \"unknown\"\n\n        span_id = structure_block.path_string()\n        if label and span_id:\n            span_id += f\":{label}\"\n        elif label and not span_id:\n            span_id = label\n        elif not span_id:\n            span_id = \"impl\"\n\n        if span_id in self._span_counter:\n            self._span_counter[span_id] += 1\n            span_id += f\":{self._span_counter[span_id]}\"\n        else:\n            self._span_counter[span_id] = 1\n\n        return span_id"
  },
  {
    "type": "function",
    "name": "_count_tokens",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 918,
    "end_line": 921,
    "code": "def _count_tokens(self, content: str):\n        if not self.tokenizer:\n            return 0\n        return len(self.tokenizer(content))"
  },
  {
    "type": "function",
    "name": "debug_log",
    "class_name": "CodeParser",
    "file": "parser.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/codeblocks/parser",
    "start_line": 923,
    "end_line": 925,
    "code": "def debug_log(self, message: str):\n        if self.debug:\n            logger.debug(message)"
  },
  {
    "type": "function",
    "name": "anthropic_schema",
    "class_name": "FeedbackResponse",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 36,
    "end_line": 60,
    "code": "def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_feedback\",\n            \"description\": \"Provide feedback on the current state\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"analysis\": {\n                        \"type\": \"string\",\n                        \"description\": \"Brief analysis of parent state and lessons from alternative attempts\",\n                    },\n                    \"feedback\": {\n                        \"type\": \"string\",\n                        \"description\": \"Clear, actionable guidance for your next action\",\n                    },\n                    \"suggested_node_id\": {\n                        \"type\": [\"integer\", \"null\"],\n                        \"description\": \"ID of the node that should be expanded next (optional)\",\n                    },\n             ..."
  },
  {
    "type": "function",
    "name": "to_dict",
    "class_name": "FeedbackResponse",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 62,
    "end_line": 67,
    "code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert Message objects to dictionaries\"\"\"\n        return {\n            \"role\": self.role if hasattr(self, \"role\") else \"assistant\",\n            \"content\": self.content if hasattr(self, \"content\") else str(self),\n        }"
  },
  {
    "type": "function",
    "name": "model_post_init",
    "class_name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 84,
    "end_line": 96,
    "code": "def model_post_init(self, __context) -> None:\n        \"\"\"Initialize feedback file after model initialization\"\"\"\n        super().model_post_init(__context)\n\n        # Set instance directory if not provided\n        if not self.instance_dir:\n            self.instance_dir = os.getcwd()\n\n        # Set feedback file path\n        if not self.feedback_file:\n            # Create instance directory if it doesn't exist\n            os.makedirs(self.instance_dir, exist_ok=True)\n            self.feedback_file = os.path.join(self.instance_dir, \"feedback.txt\")"
  },
  {
    "type": "function",
    "name": "generate_feedback",
    "class_name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 101,
    "end_line": 165,
    "code": "def generate_feedback(\n        self, node: Node, actions: List[Action] | None = None\n    ) -> FeedbackData | None:\n        if not node.parent:\n            logger.info(\n                f\"Node {node.node_id} has no parent node, skipping feedback generation\"\n            )\n            return None\n\n        messages = self._create_analysis_messages(\n            node,\n        )\n        system_prompt = self._create_system_prompt(actions)\n\n        try:\n            completion_response = self.completion_model.create_completion(\n                messages=messages,\n                system_prompt=system_prompt,\n                response_model=FeedbackResponse,\n            )\n\n            # Store the completion in the node\n            node.completions[\"feedback\"] = completion_response.completion\n\n            logger.debug(f\"Raw completion content: {completion_response.completion}\")\n            feedback_response: FeedbackResponse = completion_response.structured_output\n            print(f'feedback: {feedba..."
  },
  {
    "type": "function",
    "name": "_create_analysis_messages",
    "class_name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 167,
    "end_line": 270,
    "code": "def _create_analysis_messages(\n        self, current_node: Node\n    ) -> List[ChatCompletionUserMessage]:\n        messages = []\n\n        # Only get siblings that have been run (have actions set)\n        sibling_nodes = [\n            s for s in current_node.get_sibling_nodes() if s.action is not None\n        ]\n\n        # Format tree visualization section\n        if self.include_tree:\n            tree_message = \"# Search Tree Visualization\\n\"\n            tree_message += \"<search_tree>\\n\"\n            tree_message += generate_ascii_tree(\n                current_node.get_root(),\n                current=current_node,\n                include_explanation=True,\n                use_color=False,\n                include_diffs=True,\n                include_action_details=False,\n                include_file_context=False,\n                show_trajectory=True,\n            )\n            tree_message += \"\\n</search_tree>\\n\\n\"\n            messages.append(\n                ChatCompletionUserMessage(role=\"..."
  },
  {
    "type": "function",
    "name": "_create_system_prompt",
    "class_name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 272,
    "end_line": 372,
    "code": "def _create_system_prompt(\n        self,\n        actions: List[Action],\n    ) -> str:\n        start_num = 1\n        base_prompt = \"\"\"\nYou are a feedback agent that guides an AI assistant's next action.\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n⚠️  CRITICAL: ACTION AGENT LIMITATIONS  ⚠️\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nThe action agent receiving your feedback:\n• CANNOT see the search tree\n• Has NO CONTEXT about node relationships\n• Only knows about actions in its direct trajectory\n• Cannot understand references to nodes without proper context\n• Is at a new node that has NO ACTION YET - it needs your guidance for what to do next\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📋  REQUIRED FEEDBACK STRUCTURE\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n1. CURRENT NODE CONTEXT\n   You must start by describing:\n   • Position in tree: \"You ar..."
  },
  {
    "type": "function",
    "name": "save_feedback",
    "class_name": "FeedbackAgent",
    "file": "feedback_agent.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 374,
    "end_line": 427,
    "code": "def save_feedback(\n        self,\n        node: Node,\n        feedback: FeedbackResponse,\n        system_prompt: str | None = None,\n        messages: List | None = None,\n        raw_completion: str | None = None,\n    ) -> None:\n        \"\"\"Save raw prompts and responses to feedback file\"\"\"\n        # Setup file path\n        if self.persist_path:\n            save_dir = os.path.dirname(self.persist_path)\n            base_name = os.path.splitext(os.path.basename(self.persist_path))[0]\n            self.feedback_file = os.path.join(save_dir, f\"{base_name}_feedback.txt\")\n            os.makedirs(save_dir, exist_ok=True)\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        feedback_entry = [\n            \"=\" * 80,\n            f\"Node {node.node_id} - {timestamp}\",\n            \"=\" * 80,\n            \"\",\n            \"SYSTEM PROMPT\",\n            \"-\" * 80,\n            system_prompt if system_prompt else \"No system prompt provided\",\n            \"\",\n            \"MESSAGES\",\n          ..."
  },
  {
    "type": "function",
    "name": "generate_feedback",
    "class_name": "FeedbackGenerator",
    "file": "feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 16,
    "end_line": 20,
    "code": "def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node.\"\"\"\n        pass"
  },
  {
    "type": "function",
    "name": "model_dump",
    "class_name": "FeedbackGenerator",
    "file": "feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 22,
    "end_line": 27,
    "code": "def model_dump(self, **kwargs) -> dict[str, Any]:\n        dump = super().model_dump(**kwargs)\n        dump[\"feedback_class\"] = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n        return dump"
  },
  {
    "type": "function",
    "name": "model_validate",
    "class_name": "FeedbackGenerator",
    "file": "feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 30,
    "end_line": 49,
    "code": "def model_validate(cls, obj: Any) -> \"FeedbackGenerator\":\n        if isinstance(obj, dict):\n            obj = obj.copy()\n            feedback_class_path = obj.pop(\n                \"feedback_class\",\n                \"moatless_qa.feedback.ground_truth_feedback.GroundTruthFeedbackGenerator\",\n            )\n\n            try:\n                module_name, class_name = feedback_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                feedback_class = getattr(module, class_name)\n                return feedback_class(**obj)\n            except (ImportError, AttributeError) as e:\n                logger.warning(\n                    f\"Failed to load feedback generator class {feedback_class_path}, defaulting to RewardFeedbackGenerator: {e}\"\n                )\n                return 0\n\n        return super().model_validate(obj)"
  },
  {
    "type": "function",
    "name": "anthropic_schema",
    "class_name": "GroundTruthResponse",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 36,
    "end_line": 64,
    "code": "def anthropic_schema(cls) -> Dict[str, Any]:\n        \"\"\"Provide schema in format expected by Anthropic's tool calling\"\"\"\n        return {\n            \"type\": \"custom\",\n            \"name\": \"provide_ground_truth_feedback\",\n            \"description\": \"Provide feedback on ground truth support\",\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"analysis\": {\n                        \"type\": \"string\",\n                        \"description\": \"Detailed analysis of whether node response is supported by ground truth\",\n                    },\n                    \"has_ground_truth\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Whether the response has ground truth support\",\n                    },\n                    \"feedback\": {\n                        \"type\": \"string\",\n                        \"description\": \"Detailed feedback on response quality\",\n                    },\n                    \"sug..."
  },
  {
    "type": "function",
    "name": "to_dict",
    "class_name": "GroundTruthResponse",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 66,
    "end_line": 71,
    "code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert Message objects to dictionaries\"\"\"\n        return {\n            \"role\": self.role if hasattr(self, \"role\") else \"assistant\",\n            \"content\": self.content if hasattr(self, \"content\") else str(self),\n        }"
  },
  {
    "type": "function",
    "name": "generate_feedback",
    "class_name": "GroundTruthFeedbackGenerator",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 86,
    "end_line": 132,
    "code": "def generate_feedback(\n        self, node: Node, actions: List[ActionArguments] | None = None\n    ) -> FeedbackData | None:\n        \"\"\"Generate feedback based on the node\"\"\"\n        if not node.parent:\n            logger.info(\n                f\"Node {node.node_id} has no parent node, skipping feedback generation\"\n            )\n            return None\n        \n        messages = self._create_analysis_messages(node)\n        system_prompt = self._create_system_prompt()\n        \n        try:\n            completion_response = self.completion_model.create_completion(\n                messages=messages,\n                system_prompt=system_prompt,\n                response_model=GroundTruthResponse,\n            )\n            \n            # Store the completion in the node\n            node.completions[\"ground_truth_feedback\"] = completion_response.completion\n            \n            logger.debug(f\"Raw completion content: {completion_response.completion}\")\n            feedback_response: GroundTru..."
  },
  {
    "type": "function",
    "name": "_create_analysis_messages",
    "class_name": "GroundTruthFeedbackGenerator",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 134,
    "end_line": 218,
    "code": "def _create_analysis_messages(\n        self, current_node: Node\n    ) -> List[ChatCompletionUserMessage]:\n        \"\"\"Create messages for analysis\"\"\"\n        messages = []\n        \n        # Only get siblings that have been run (have actions set)\n        sibling_nodes = [\n            s for s in current_node.get_sibling_nodes() if s.action is not None\n        ]\n        \n        # Format tree visualization section\n        if self.include_tree:\n            tree_message = \"# Search Tree Visualization\\n\"\n            tree_message += \"<search_tree>\\n\"\n            tree_message += generate_ascii_tree(\n                current_node.get_root(),\n                current=current_node,\n                include_explanation=True,\n                use_color=False,\n                include_diffs=True,\n                include_action_details=False,\n                include_file_context=False,\n                show_trajectory=True,\n            )\n            tree_message += \"\\n</search_tree>\\n\\n\"\n            messag..."
  },
  {
    "type": "function",
    "name": "_create_system_prompt",
    "class_name": "GroundTruthFeedbackGenerator",
    "file": "ground_truth_feedback.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/feedback",
    "start_line": 220,
    "end_line": 272,
    "code": "def _create_system_prompt(self) -> str:\n        \"\"\"Create system prompt\"\"\"\n        system_prompt = \"\"\"You are a feedback agent responsible for evaluating the quality of AI assistant responses.\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📋  YOUR TASK\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n1. Analyze whether the current node's response has reliable ground truth support\n   • Evaluate if the response is based on reliable facts\n   • Check for unsupported claims\n   • Analyze the completeness and correctness of the response\n   • Determine if the response truly addresses the problem posed in the original task\n\n2. Evaluate the quality of the response\n   • Whether it comprehensively answers the question\n   • Whether there are errors or misleading information\n   • Whether sufficient context and explanation is provided\n   • Whether there are better alternative ways to respond\n\n3. Provide specific feedback\n   • Point out ..."
  },
  {
    "type": "function",
    "name": "retry_clone",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 10,
    "end_line": 40,
    "code": "def retry_clone(repo_url, repo_dir, max_attempts=3):\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    for attempt in range(max_attempts):\n        try:\n            logger.info(f\"Cloning {repo_url} to {repo_dir} (attempt {attempt + 1})\")\n            result = subprocess.run(\n                [\"git\", \"clone\", repo_url, repo_dir],\n                check=True,\n                text=True,\n                capture_output=True,\n            )\n            logger.info(f\"Cloned {repo_url} to {repo_dir}. Output: {result.stdout}\")\n            return\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"Clone attempt {attempt + 1} failed: {e.stderr}\")\n            if attempt < max_attempts - 1:\n                if \"Connection res..."
  },
  {
    "type": "function",
    "name": "setup_github_repo",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 43,
    "end_line": 55,
    "code": "def setup_github_repo(repo: str, base_commit: str, base_dir: str = \"/tmp/repos\") -> str:\n    repo_name = get_repo_dir_name(repo)\n    repo_url = f\"https://github.com/{repo}.git\"\n    path = f\"{base_dir}/{repo_name}\"\n    logger.info(\n        f\"Clone Github repo {repo_url} to {path} and checkout commit {base_commit}\"\n    )\n    if not os.path.exists(path):\n        os.makedirs(path)\n        logger.info(f\"Directory '{path}' was created.\")\n    maybe_clone(repo_url, path)\n    checkout_commit(path, base_commit)\n    return path"
  },
  {
    "type": "function",
    "name": "get_repo_dir_name",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 58,
    "end_line": 59,
    "code": "def get_repo_dir_name(repo: str):\n    return repo.replace(\"/\", \"_\")"
  },
  {
    "type": "function",
    "name": "clone_and_checkout",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 62,
    "end_line": 115,
    "code": "def clone_and_checkout(repo_url, repo_dir, commit):\n    \"\"\"Clone the repository and checkout to the specific commit.\"\"\"\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    # 首先尝试常规克隆，避免设置深度限制\n    subprocess.run(\n        [\"git\", \"clone\", repo_url, repo_dir],\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n    \n    # 尝试直接检出提交\n    try:\n        subprocess.run(\n            [\"git\", \"checkout\", commit],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError:\n        # 如果直接检出失败，尝试获取所有历史然后再检出\n        subprocess.run(\n            [\"git\", \"fetch\", \"--unshallow\", \"origin\"],\n            cwd=repo_dir,\n            check=Fals..."
  },
  {
    "type": "function",
    "name": "maybe_clone",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 118,
    "end_line": 134,
    "code": "def maybe_clone(repo_url, repo_dir):\n    # 如果是使用file://协议的URL，确保使用绝对路径\n    if repo_url.startswith(\"file://\"):\n        # 将file://后面的相对路径转换为绝对路径\n        path_part = repo_url[7:]  # 去掉\"file://\"前缀\n        if not os.path.isabs(path_part):\n            abs_path = os.path.abspath(path_part)\n            repo_url = f\"file://{abs_path}\"\n            \n    if not os.path.exists(f\"{repo_dir}/.git\"):\n        logger.info(f\"Cloning repo '{repo_url}'\")\n        try:\n            retry_clone(repo_url, repo_dir)\n        except Exception as e:\n            logger.error(f\"Clone failed after multiple attempts: {e}\")\n            raise ValueError(f\"Failed to clone repo '{repo_url}' to '{repo_dir}'\")\n        logger.info(f\"Repo '{repo_url}' was cloned to '{repo_dir}'\")"
  },
  {
    "type": "function",
    "name": "pull_latest",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 137,
    "end_line": 144,
    "code": "def pull_latest(repo_dir):\n    subprocess.run(\n        [\"git\", \"pull\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "type": "function",
    "name": "clean_and_reset_state",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 147,
    "end_line": 161,
    "code": "def clean_and_reset_state(repo_dir):\n    subprocess.run(\n        [\"git\", \"clean\", \"-fd\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )\n    subprocess.run(\n        [\"git\", \"reset\", \"--hard\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "type": "function",
    "name": "create_branch",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 164,
    "end_line": 175,
    "code": "def create_branch(repo_dir, branch_name):\n    try:\n        subprocess.run(\n            [\"git\", \"branch\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "type": "function",
    "name": "create_and_checkout_branch",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 178,
    "end_line": 206,
    "code": "def create_and_checkout_branch(repo_dir, branch_name):\n    try:\n        branches = subprocess.run(\n            [\"git\", \"branch\"],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        ).stdout.split(\"\\n\")\n        branches = [branch.strip() for branch in branches]\n        if branch_name in branches:\n            subprocess.run(\n                [\"git\", \"checkout\", branch_name],\n                cwd=repo_dir,\n                check=True,\n                text=True,\n                capture_output=True,\n            )\n        else:\n            subprocess.run(\n                [\"git\", \"checkout\", \"-b\", branch_name],\n                cwd=repo_dir,\n                check=True,\n                text=True,\n                capture_output=True,\n            )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "type": "function",
    "name": "commit_changes",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 209,
    "end_line": 216,
    "code": "def commit_changes(repo_dir, commit_message):\n    subprocess.run(\n        [\"git\", \"commit\", \"-m\", commit_message, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "type": "function",
    "name": "checkout_branch",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 219,
    "end_line": 226,
    "code": "def checkout_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"checkout\", branch_name],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "type": "function",
    "name": "push_branch",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 229,
    "end_line": 236,
    "code": "def push_branch(repo_dir, branch_name):\n    subprocess.run(\n        [\"git\", \"push\", \"origin\", branch_name, \"--no-verify\"],\n        cwd=repo_dir,\n        check=True,\n        text=True,\n        capture_output=True,\n    )"
  },
  {
    "type": "function",
    "name": "get_diff",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 239,
    "end_line": 244,
    "code": "def get_diff(repo_dir):\n    output = subprocess.run(\n        [\"git\", \"diff\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )\n\n    return output.stdout"
  },
  {
    "type": "function",
    "name": "stage_all_files",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 247,
    "end_line": 250,
    "code": "def stage_all_files(repo_dir):\n    subprocess.run(\n        [\"git\", \"add\", \".\"], cwd=repo_dir, check=True, text=True, capture_output=True\n    )"
  },
  {
    "type": "function",
    "name": "checkout_commit",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 253,
    "end_line": 265,
    "code": "def checkout_commit(repo_dir, commit_hash):\n    logger.info(f\"Checking out commit {commit_hash} in {repo_dir}\")\n    try:\n        subprocess.run(\n            [\"git\", \"reset\", \"--hard\", commit_hash],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "type": "function",
    "name": "create_and_checkout_new_branch",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 268,
    "end_line": 279,
    "code": "def create_and_checkout_new_branch(repo_dir: str, branch_name: str):\n    try:\n        subprocess.run(\n            [\"git\", \"checkout\", \"-b\", branch_name],\n            cwd=repo_dir,\n            check=True,\n            text=True,\n            capture_output=True,\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(e.stderr)\n        raise e"
  },
  {
    "type": "function",
    "name": "setup_repo",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 282,
    "end_line": 286,
    "code": "def setup_repo(repo_url, repo_dir, branch_name=\"master\"):\n    maybe_clone(repo_url, repo_dir)\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)"
  },
  {
    "type": "function",
    "name": "clean_and_reset_repo",
    "class_name": null,
    "file": "repo.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 289,
    "end_line": 292,
    "code": "def clean_and_reset_repo(repo_dir, branch_name=\"master\"):\n    clean_and_reset_state(repo_dir)\n    checkout_branch(repo_dir, branch_name)\n    pull_latest(repo_dir)"
  },
  {
    "type": "function",
    "name": "parse_explanation",
    "class_name": null,
    "file": "parse.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 8,
    "end_line": 15,
    "code": "def parse_explanation(response_content, keyword=\"feedback\") -> str:\n    explanation_pattern = r\"<{keyword}>\\s*(.*?)\\s*(?:</{keyword}>|<Feedback_to_Alternative_Branch>|<Reward>|$)\"\n    match = re.search(explanation_pattern, response_content, re.DOTALL | re.IGNORECASE)\n\n    if match:\n        return match.group(1).strip()\n    else:\n        return response_content"
  },
  {
    "type": "function",
    "name": "parse_value",
    "class_name": null,
    "file": "parse.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 18,
    "end_line": 77,
    "code": "def parse_value(response_content, keyword=\"reward\", allowed_values=None):\n    \"\"\"\n    Parse the value associated with a given keyword from the LLM response content.\n\n    Args:\n    response_content (str): The content of the LLM response.\n    keyword (str): The keyword to search for (default: 'reward').\n    allowed_values (list or range, optional): A list or range of allowed values.\n\n    Returns:\n    int: The parsed integer value, or None if not found, not an integer, or not in allowed_values.\n    \"\"\"\n    value_patterns = [\n        rf\"<\\s*{keyword}\\s*>\\s*:?\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"<\\s*{keyword}\\s*>(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"{keyword}:\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"\\*\\*{keyword}\\*\\*\\s*:?\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"\\*\\*{keyword.capitalize()}\\*\\*\\s*:?\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"{keyword.capitalize()}:\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf\"<\\s*{keyword.capitalize()}\\s*>\\s*:?\\s*(?:[Nn]ode[_\\s-]?)?(-?\\d+)\",\n        rf..."
  },
  {
    "type": "function",
    "name": "parse_node_id",
    "class_name": null,
    "file": "parse.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 80,
    "end_line": 129,
    "code": "def parse_node_id(response_content) -> Optional[int]:\n    \"\"\"\n    Parse the node_id from the LLM response content.\n    Looks for patterns like:\n    - \"expand node 5\"\n    - \"node_id: 5\"\n    - \"Node ID: 5\"\n    - \"suggested node: 5\"\n    - Or any JSON structure containing node_id or suggested_node_id\n\n    Args:\n    response_content (str): The content of the LLM response.\n\n    Returns:\n    int: The parsed node ID, or None if not found or not a valid integer.\n    \"\"\"\n    node_patterns = [\n        r\"expand\\s*node\\s*(\\d+)\",\n        r\"node_id\\s*:?\\s*(\\d+)\",\n        r\"node\\s*id\\s*:?\\s*(\\d+)\",\n        r\"suggested\\s*node\\s*:?\\s*(\\d+)\",\n        r\"suggested_node_id\\s*:?\\s*(\\d+)\",\n        r\"expand\\s*node\\s*#?(\\d+)\",\n        r\"node\\s*#?(\\d+)\",\n        # JSON-like patterns\n        r'\"node_id\"\\s*:\\s*(\\d+)',\n        r'\"suggested_node_id\"\\s*:\\s*(\\d+)',\n    ]\n\n    matched_value = None\n    try:\n        # Try each pattern\n        for pattern in node_patterns:\n            match = re.search(pattern, response_c..."
  },
  {
    "type": "function",
    "name": "is_test",
    "class_name": null,
    "file": "file.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 5,
    "end_line": 20,
    "code": "def is_test(file_path: str) -> bool:\n    path = Path(file_path)\n\n    # All files in test directories are considered test files\n    if any(part in [\"testing\"] for part in path.parts):\n        return True\n\n    test_file_patterns = [\n        \"unittest_*.py\",\n        \"test_*.py\",\n        \"tests_*.py\",\n        \"*_test.py\",\n        \"test.py\",\n        \"tests.py\",\n    ]\n    return any(fnmatch.fnmatch(path.name, pattern) for pattern in test_file_patterns)"
  },
  {
    "type": "function",
    "name": "count_tokens",
    "class_name": null,
    "file": "tokenizer.py",
    "path": "/home/stu/Desktop/my_codeqa/codeqa/moatless_qa/utils",
    "start_line": 8,
    "end_line": 48,
    "code": "def count_tokens(content: str, model: str = \"gpt-3.5-turbo\") -> int:\n    global _enc, _voyageai\n\n    if model.startswith(\"voyage\"):\n        if _voyageai is None:\n            voyageai_import_err = (\n                \"`voyageai` package not found, please run `pip install voyageai`\"\n            )\n            try:\n                import voyageai\n            except ImportError as e:\n                raise ImportError(voyageai_import_err) from e\n\n            _voyageai = voyageai.Client()\n\n        return _voyageai.count_tokens([content])\n\n    if _enc is None:\n        tiktoken_import_err = (\n            \"`tiktoken` package not found, please run `pip install tiktoken`\"\n        )\n        try:\n            import tiktoken\n        except ImportError as e:\n            raise ImportError(tiktoken_import_err) from e\n\n        # set tokenizer cache temporarily\n        should_revert = False\n        if \"TIKTOKEN_CACHE_DIR\" not in os.environ:\n            should_revert = True\n            os.environ[\"TIKTOKEN_C..."
  }
]